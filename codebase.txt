{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Career APO Explorer - Automation Potential Analysis</title>
    <meta name="description" content="Analyze automation potential for careers using O*NET data. Get insights into tasks, knowledge, skills, abilities, and technologies that shape the future of work." />
    <meta name="author" content="Career APO Explorer" />

    <meta property="og:title" content="Career APO Explorer - Automation Potential Analysis" />
    <meta property="og:description" content="Analyze automation potential for careers using O*NET data. Get insights into tasks, knowledge, skills, abilities, and technologies that shape the future of work." />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@lovable_dev" />
    <meta name="twitter:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitAny": false,
    "noFallthroughCasesInSwitch": false,

    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}
import {
  assertEquals,
  assert,
} from "https://deno.land/std@0.168.0/testing/asserts.ts";

Deno.env.set("GEMINI_API_KEY", "fake-key");
Deno.env.set("SUPABASE_URL", "http://localhost:54321");
Deno.env.set("SUPABASE_SERVICE_ROLE_KEY", "fake-role");

// Track intervals to clear after test
const _setInterval = globalThis.setInterval;
const _clearInterval = globalThis.clearInterval;
const __intervalIds: number[] = [];
globalThis.setInterval = ((handler: TimerHandler, timeout?: number, ...args: any[]): number => {
  const id = _setInterval(handler as any, timeout as any, ...args);
  __intervalIds.push(id);
  return id;
}) as any;

const originalFetch = globalThis.fetch;

globalThis.fetch = async (input: Request | string, init?: RequestInit): Promise<Response> => {
  if (typeof input === "string" && input.includes("gemini-2.5-flash")) {
    return new Response(
      JSON.stringify({
        candidates: [
          {
            content: {
              parts: [
                {
                  text:
                    '{"category":"Automate","explanation":"Routine task","confidence":0.9}',
                },
              ],
            },
          },
        ],
      }),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  }
  if (typeof input === "string" && input.includes("/rest/v1/ai_task_assessments")) {
    return new Response(null, { status: 201 });
  }
  return originalFetch(input as any, init);
};

const { handler } = await import(
  "../functions/intelligent-task-assessment/index.ts"
);

Deno.test("intelligent-task-assessment returns assessments", async () => {
  const req = new Request("http://localhost", {
    method: "POST",
    body: JSON.stringify({
      occupationCode: "15-1252",
      occupationTitle: "Software Developer",
      tasks: ["Write unit tests"],
      userId: crypto.randomUUID(),
    }),
    headers: { "Content-Type": "application/json" },
  });
  const resp = await handler(req);
  assertEquals(resp.status, 200);
  const data = await resp.json();
  assert(data.assessments.length === 1);
  assertEquals(data.assessments[0].category, "Automate");

// Clear intervals created during handler execution
for (const id of __intervalIds) _clearInterval(id as any);
__intervalIds.length = 0;
});
import { assertEquals } from "https://deno.land/std@0.168.0/testing/asserts.ts";

Deno.env.set("GEMINI_API_KEY", "fake");
Deno.env.set("SUPABASE_URL", "http://localhost:54321");
Deno.env.set("SUPABASE_SERVICE_ROLE_KEY", "fake");

// Track intervals to clear after test
const _setInterval = globalThis.setInterval;
const _clearInterval = globalThis.clearInterval;
const __intervalIds: number[] = [];
globalThis.setInterval = ((handler: TimerHandler, timeout?: number, ...args: any[]): number => {
  const id = _setInterval(handler as any, timeout as any, ...args);
  __intervalIds.push(id);
  return id;
}) as any;

const originalFetch = globalThis.fetch;
globalThis.fetch = async (input: Request | string): Promise<Response> => {
  if (typeof input === "string" && input.includes("gemini-2.5-flash")) {
    return new Response(
      JSON.stringify({
        candidates: [
          { content: { parts: [{ text: '[{"skill":"SQL","recommendation":"Take intro SQL","effortHours":5}]' }] } },
        ],
      }),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  }
  if (typeof input === "string" && input.includes("ai_skill_recommendations")) {
    return new Response(null, { status: 201 });
  }
  return originalFetch(input as any);
};

import { handler } from "../functions/personalized-skill-recommendations/index.ts";


Deno.test("personalized-skill-recommendations", async () => {
  const req = new Request("http://localhost", {
    method: "POST",
    body: JSON.stringify({
      occupationCode: "15-1252",
      occupationTitle: "Software Dev",
      gapSkills: ["SQL"],
      userId: crypto.randomUUID(),
    }),
    headers: { "Content-Type": "application/json" },
  });
  const resp = await handler(req);
  assertEquals(resp.status, 200);
  const data = await resp.json();
  assertEquals(data.recommendations[0].skill, "SQL");

// Clear intervals
for (const id of __intervalIds) _clearInterval(id as any);
__intervalIds.length = 0;
});
import {
  assertEquals,
  assert,
} from "https://deno.land/std@0.168.0/testing/asserts.ts";
import { GeminiClient } from "../lib/GeminiClient.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

Deno.env.set("GEMINI_API_KEY", "fake-key");
Deno.env.set("SUPABASE_URL", "http://localhost:54321");
Deno.env.set("SUPABASE_SERVICE_ROLE_KEY", "fake-service-role-key");

// Track intervals to clear after test to avoid leak detection
const _setInterval = globalThis.setInterval;
const _clearInterval = globalThis.clearInterval;
const __intervalIds: number[] = [];
globalThis.setInterval = (
  handler: TimerHandler,
  timeout?: number,
  ...args: any[]
): number => {
  const id = _setInterval(handler, timeout as any, ...args);
  __intervalIds.push(id);
  return id;
};

// Mock global fetch for Gemini and Supabase insert
const originalFetch = globalThis.fetch;

globalThis.fetch = async (input: Request | string, init?: RequestInit): Promise<Response> => {
  // Mock Gemini request
  if (typeof input === "string" && input.includes("gemini-2.5-flash")) {
    return new Response(
      JSON.stringify({
        candidates: [
          { content: { parts: [{ text: "Mock Gemini response" }] } },
        ],
        usageMetadata: { totalTokens: 10 },
      }),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  }
  // Mock Supabase insert
  if (typeof input === "string" && input.includes("/rest/v1/llm_logs")) {
    return new Response(null, { status: 201 });
  }
  return originalFetch(input as any, init);
};

// Import function handler (dynamic import to allow env mocks first)
const { handler } = await import("../functions/ai-career-coach/index.ts");

Deno.test("ai-career-coach returns valid JSON", async () => {
  const body = {
    message: "Hello coach!",
    userProfile: {
      id: crypto.randomUUID(),
      occupationCode: "15-1252",
      careerGoals: "Become a senior engineer",
    },
  };
  const req = new Request("http://localhost", {
    method: "POST",
    body: JSON.stringify(body),
    headers: { "Content-Type": "application/json" },
  });

  const resp = await handler(req);
  assertEquals(resp.status, 200);
  const data = await resp.json();
  assert(data.response.includes("Mock Gemini response"));
  assertEquals(data.usage.totalTokens, 10);

// Clear any intervals started during handler execution
for (const id of __intervalIds) _clearInterval(id);
__intervalIds.length = 0;
});
import { assertEquals } from "https://deno.land/std@0.168.0/testing/asserts.ts";

const originalFetch = globalThis.fetch;
Deno.env.set("SERPAPI_KEY", "fake");

globalThis.fetch = async (input: Request | string): Promise<Response> => {
  if (typeof input === "string" && input.includes("serpapi.com")) {
    return new Response(
      JSON.stringify({
        organic_results: [
          { title: "SQL Course", link: "https://example.com/sql", snippet: "Free" },
        ],
      }),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  }
  return originalFetch(input as any);
};

const { handler } = await import("../functions/free-courses/index.ts");

Deno.test("free-courses returns list", async () => {
  const req = new Request("http://localhost", {
    method: "POST",
    body: JSON.stringify({ skill: "SQL", limit: 1 }),
    headers: { "Content-Type": "application/json" },
  });
  const resp = await handler(req);
  assertEquals(resp.status, 200);
  const data = await resp.json();
  assertEquals(data.results[0].title, "SQL Course");
});
// supabase/lib/RateLimiter.ts
// Simple in-memory (per-edge-instance) token bucket with fallback to KV (Deno 1.42+)
// For production you would swap to a durable store (Redis, R2, Supabase KV).

export interface RateLimitOptions {
  windowMs: number; // e.g. 60_000 for 1 minute
  max: number; // max requests per window
}

const buckets: Record<string, { tokens: number; reset: number }> = {};

export function rateLimit(ip: string, opts: RateLimitOptions): {
  allowed: boolean;
  remaining: number;
  resetMs: number;
} {
  const now = Date.now();
  const bucket = buckets[ip] ?? { tokens: opts.max, reset: now + opts.windowMs };
  if (now > bucket.reset) {
    bucket.tokens = opts.max;
    bucket.reset = now + opts.windowMs;
  }
  const allowed = bucket.tokens > 0;
  if (allowed) bucket.tokens -= 1;
  buckets[ip] = bucket;
  return { allowed, remaining: bucket.tokens, resetMs: bucket.reset - now };
}
// supabase/lib/GeminiClient.ts
// Simple wrapper around Google Generative Language Gemini 2.5 Flash
// Designed for reuse in Supabase Edge Functions (Deno runtime)

import { z } from "https://esm.sh/zod@3.22.4";

export const generationConfigSchema = z
  .object({
    temperature: z.number().min(0).max(1).optional().default(0.2),
    topK: z.number().min(1).max(40).optional().default(1),
    topP: z.number().min(0).max(1).optional().default(0.8),
    maxOutputTokens: z.number().min(1).max(4096).optional().default(2048),
  })
  .strict();

export type GenerationConfig = z.infer<typeof generationConfigSchema>;

export interface GeminiUsageMetadata {
  totalTokens: number;
  promptTokens?: number;
  completionTokens?: number;
}

export interface GeminiResponse {
  text: string;
  usageMetadata?: GeminiUsageMetadata;
}

export class GeminiClient {
  private readonly apiKey: string;
  private readonly baseUrl =
    "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent";

  constructor(apiKey?: string) {
    const key = apiKey || Deno.env.get("GEMINI_API_KEY");
    if (!key) {
      throw new Error("GEMINI_API_KEY env var not set");
    }
    this.apiKey = key;
  }

  async generateContent(
    prompt: string,
    config: Partial<GenerationConfig> = {},
  ): Promise<GeminiResponse> {
    if (!prompt.trim()) throw new Error("Prompt cannot be empty");
    const generationConfig = generationConfigSchema.parse(config);

    const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contents: [{ parts: [{ text: prompt }] }],
        generationConfig,
      }),
    });

    if (!response.ok) {
      const err = await response.text();
      throw new Error(`Gemini API error ${response.status}: ${err}`);
    }

    const { candidates, usageMetadata } = await response.json();
    const text: string = candidates?.[0]?.content?.parts?.[0]?.text ?? "";
    return { text, usageMetadata };
  }
}
// supabase/lib/SerpApiClient.ts
// Minimal SerpAPI wrapper for course search
import { z } from "https://esm.sh/zod@3.22.4";

const serpApiKey = Deno.env.get("SERPAPI_KEY");
if (!serpApiKey) {
  console.warn("SERPAPI_KEY not set — free-courses edge fn will fail");
}

const resultSchema = z.object({
  title: z.string(),
  link: z.string().url(),
  snippet: z.string().optional(),
});
export type CourseResult = z.infer<typeof resultSchema>;

export async function searchCourses(query: string, limit = 5): Promise<CourseResult[]> {
  if (!serpApiKey) throw new Error("SERPAPI_KEY missing");
  const url = `https://serpapi.com/search.json?engine=google&q=${encodeURIComponent(query)}&num=${limit}&api_key=${serpApiKey}`;
  const resp = await fetch(url);
  if (!resp.ok) throw new Error(`SerpAPI error ${resp.status}`);
  const data = await resp.json();
  const results = (data.organic_results || []).slice(0, limit).map((r: any) => ({
    title: r.title,
    link: r.link,
    snippet: r.snippet,
  }));
  return z.array(resultSchema).parse(results);
}
// deno run -A supabase/lib/scripts/ingest_onet_metadata.ts <path-to-onet-csv-root>
// Ingest O*NET classification, descriptor, crosswalk and T2 taxonomy CSVs into Supabase.
// Requires SUPABASE_SERVICE_ROLE_KEY & SUPABASE_URL env vars.
// Focuses on Phase-II high-priority tables.

import {
  createClient,
  SupabaseClient,
} from "https://esm.sh/@supabase/supabase-js@2.39.3";
import { parse } from "https://deno.land/std@0.224.0/csv/mod.ts";
import { join } from "https://deno.land/std@0.224.0/path/mod.ts";

// Debug utilities
const DEBUG = Deno.env.get("INGEST_DEBUG") === "1";
const logDebug = (...args: unknown[]) => {
  if (DEBUG) console.debug("[INGEST][DEBUG]", ...args);
};
const logInfo = (...args: unknown[]) => console.log("[INGEST]", ...args);
const logWarn = (...args: unknown[]) => console.warn("[INGEST][WARN]", ...args);

if (import.meta.main) {
  const [rootDir] = Deno.args;
  if (!rootDir) {
    console.error("Usage: deno run -A ingest_onet_metadata.ts <root-onet-folder>");
    Deno.exit(1);
  }

  const supabaseUrl = Deno.env.get("SUPABASE_URL");
  const serviceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");
  if (!supabaseUrl || !serviceKey) {
    console.error("Missing SUPABASE env vars");
    Deno.exit(1);
  }

  const client = createClient(supabaseUrl, serviceKey, {
    auth: { persistSession: false },
  });

  const steps = [
    ingestJobZones,
    ingestBrightOutlook,
    ingestStem,
    ingestCareerClusters,
    ingestIndustries,
    ingestDescriptors,
    ingestToolsTech,
  ];
  for (const step of steps) {
    try {
      const label = `STEP:${step.name}`;
      console.time(label);
      await step(client, rootDir);
      console.timeEnd(label);
    } catch (e) {
      console.error(`Step ${step.name} failed:`, e);
    }
  }
  console.log("✅ O*NET metadata ingest complete");
}

async function ingestJobZones(client: SupabaseClient, root: string) {
  const path = join(root, "Job Zones.txt");
  const rows = await readCsv(path);
  for (const r of rows) {
    const id = Number(r.JobZoneCode);
    await client.from("job_zones").upsert({ id, name: r.JobZoneTitle });
  }
  console.log(`→ job_zones: ${rows.length}`);
}

async function ingestBrightOutlook(client: SupabaseClient, root: string) {
  // Bright Outlook not present in O*NET 29.3; skip
  console.log("→ bright_outlook_flags: skipped (not present in O*NET 29.3)");
  return;
  const rows = await readCsv(path);
  for (const r of rows) {
    const id = Number(r.BrightOutlookCode);
    await client
      .from("bright_outlook_flags")
      .upsert({ id, slug: r.BrightOutlookFlag, description: r.Description });
  }
  console.log(`→ bright_outlook_flags: ${rows.length}`);
}

async function ingestStem(client: SupabaseClient, root: string) {
  const path = join(root, "Stem.txt");
  try {
    const rows = await readCsv(path);
    for (const r of rows) {
      const id = Number(r.StemCode);
      await client.from("stem_categories").upsert({ id, name: r.StemTitle });
    }
    console.log(`→ stem_categories: ${rows.length}`);
  } catch (e) {
    if (e instanceof Deno.errors.NotFound) {
      console.log("→ stem_categories: skipped (Stem.txt not found)");
    } else {
      throw e;
    }
  }
}

async function ingestCareerClusters(client: SupabaseClient, root: string) {
  const path = join(root, "Career Clusters.txt");
  try {
    const rows = await readCsv(path);
    for (const r of rows) {
      const id = Number(r.ClusterCode);
      await client
        .from("career_clusters")
        .upsert({ id, name: r.ClusterTitle });
    }
    console.log(`→ career_clusters: ${rows.length}`);
  } catch (e) {
    if (e instanceof Deno.errors.NotFound) {
      console.log("→ career_clusters: skipped (Career Clusters.txt not found)");
    } else {
      throw e;
    }
  }
}

async function ingestIndustries(client: SupabaseClient, root: string) {
  const path = join(root, "Industries.txt");
  try {
    const rows = await readCsv(path);
    for (const r of rows) {
      const id = Number(r.NAICSCode);
      await client
        .from("industries")
        .upsert({ id, naics_code: r.NAICSCode, name: r.IndustryTitle });
    }
    console.log(`→ industries: ${rows.length}`);
  } catch (e) {
    if (e instanceof Deno.errors.NotFound) {
      console.log("→ industries: skipped (Industries.txt not found)");
    } else {
      throw e;
    }
  }
}

async function ingestDescriptors(client: SupabaseClient, root: string) {
  // Example for Abilities.txt; extend similarly for each descriptor family
  const abilityPath = join(root, "Abilities.txt");
  try {
    const abilities = await readCsv(abilityPath);
    logDebug("abilities sample row keys", abilities[0] ? Object.keys(abilities[0]) : []);
    // Ensure family row
    const { data: fam, error: famUpsertErr } = await client
      .from("descriptor_families")
      .upsert({ slug: "abilities", name: "Abilities" })
      .select()
      .single();
    logDebug("descriptor_families upsert result", { fam, famUpsertErr, hasId: !!(fam as any)?.id });
    let familyId = (fam as any)?.id;
    if (!familyId) {
      const { data: fam2, error: famSelErr } = await client
        .from("descriptor_families")
        .select("id, slug, name")
        .eq("slug", "abilities")
        .maybeSingle();
      logWarn("descriptor_families select fallback", { fam2, famSelErr });
      familyId = (fam2 as any)?.id;
    }
    if (!familyId) {
      console.log("→ descriptors.abilities: skipped (descriptor family id unresolved)");
      return;
    }
    for (const a of abilities) {
      const { error: descErr } = await client.from("descriptors").upsert({
        family_id: familyId,
        code: a.ElementID,
        name: a.ElementName,
        description: a.Description,
      });
      if (descErr) {
        logWarn("descriptor upsert error", { code: a?.ElementID, name: a?.ElementName, error: descErr });
      }
    }
    console.log(`→ descriptors.abilities: ${abilities.length}`);
  } catch (e) {
    if (e instanceof Deno.errors.NotFound) {
      console.log("→ descriptors.abilities: skipped (Abilities.txt not found)");
    } else {
      throw e;
    }
  }
}

async function ingestToolsTech(client: SupabaseClient, root: string) {
  const path = join(root, "Tools Used.txt");
  try {
    const rows = await readCsv(path);
    logDebug("tools_technology sample row keys", rows[0] ? Object.keys(rows[0]) : []);
    for (const r of rows) {
      await client.from("tools_technology").upsert({
        onet_code: r.ONETCode,
        tool_name: r.Tool,
        category: r.Category,
      });
    }
    console.log(`→ tools_technology: ${rows.length}`);
  } catch (e) {
    if (e instanceof Deno.errors.NotFound) {
      console.log("→ tools_technology: skipped (Tools Used.txt not found)");
    } else {
      throw e;
    }
  }
}

async function readCsv(filePath: string) {
  logDebug("readCsv start", { filePath });
  const text = await Deno.readTextFile(filePath);
  try {
    const rows = await parse(text, { skipFirstRow: true, separator: "\t" });
    logDebug("readCsv parsed (normal)", { filePath, rows: Array.isArray(rows) ? rows.length : 0 });
    return rows as Record<string, string>[];
  } catch (e) {
    logWarn("readCsv parser error; attempting line-by-line recovery", { filePath, error: String(e) });
    // Try to recover by parsing line by line, skipping bad lines
    const lines = text.split("\n");
    const header = lines[0];
    const goodRows: Record<string, string>[] = [];
    let badCount = 0;
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i];
      try {
        const parsed = await parse(header + "\n" + line, { skipFirstRow: false, separator: "\t" });
        if (parsed && parsed.length > 0) goodRows.push(parsed[0] as Record<string, string>);
      } catch (rowErr) {
        badCount++;
        if (badCount <= 3) {
          logWarn(`Skipping bad row ${i + 1}`, { snippet: line.slice(0, 120), error: String(rowErr) });
        }
      }
    }
    logWarn("readCsv recovery summary", { filePath, good: goodRows.length, bad: badCount, total: lines.length - 1 });
    return goodRows;
  }
}
// supabase/functions/filters/index.ts
// Edge Function: returns all discovery filter reference tables as JSON
// Route: /filters (GET)
// Query params: none
// Response shape:
// {
//   jobZones: [...], brightOutlook: [...], stem: [...], clusters: [...], industries: [...]
// }

import { serve } from "https://deno.land/std@0.203.0/http/server.ts";
import { z } from "https://esm.sh/zod@3.22.4";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.3";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

export async function handler(req: Request) {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }
  if (req.method !== "GET" && req.method !== "POST") {
    return new Response("Method not allowed", { status: 405, headers: corsHeaders });
  }
  const supabaseUrl = Deno.env.get("SUPABASE_URL");
  const serviceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");
  if (!supabaseUrl || !serviceKey)
    return new Response("Server misconfiguration", { status: 500, headers: corsHeaders });

  const sb = createClient(supabaseUrl, serviceKey, {
    auth: { persistSession: false },
  });

  const [jobZones, bright, stem, clusters, industries] = await Promise.all([
    sb.from("job_zones").select("*").order("id"),
    sb.from("bright_outlook_flags").select("*").order("id"),
    sb.from("stem_categories").select("*").order("id"),
    sb.from("career_clusters").select("*").order("id"),
    sb.from("industries").select("*").order("id"),
  ]);

  const error =
    jobZones.error || bright.error || stem.error || clusters.error || industries.error;
  if (error) return new Response(error.message, { status: 500, headers: corsHeaders });

  const body = {
    jobZones: jobZones.data,
    brightOutlook: bright.data,
    stem: stem.data,
    clusters: clusters.data,
    industries: industries.data,
  };
  return new Response(JSON.stringify(body), {
    headers: { ...corsHeaders, "Content-Type": "application/json" },
  });
}

if (import.meta.main) {
  serve(handler);
}
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { z } from "https://esm.sh/zod@3.22.4";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { GeminiClient } from "../../lib/GeminiClient.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
};

const requestSchema = z.object({
  occupationCode: z.string(),
  occupationTitle: z.string(),
  gapSkills: z.array(z.string().min(2)).min(1).max(20),
  userId: z.string().uuid(),
});

// Instantiate GeminiClient inside handler to ensure env is available at runtime

export async function handler(req: Request) {
  console.log("[DEBUG] handling personalized-skill-recommendations request");
  const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
  const supabaseServiceRoleKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";

  if (req.method === "OPTIONS") return new Response(null, { headers: corsHeaders });
  try {
    const { occupationCode, occupationTitle, gapSkills, userId } = requestSchema.parse(
      await req.json(),
    );
    const prompt = `You are a career coach. For the occupation ${occupationTitle} (${occupationCode}), the user lacks the following skills: ${gapSkills.join(", ")}. For each missing skill, recommend a concrete learning action (e.g., online course, project) with an estimated effort level (hours). Return JSON array [{skill, recommendation, effortHours}].`;
    const gemini = new GeminiClient();
    const { text } = await gemini.generateContent(prompt);
    let recommendations: any[] = [];
    try {
      recommendations = JSON.parse(text);
    } catch {
      recommendations = gapSkills.map((s) => ({ skill: s, recommendation: `Self-study ${s}`, effortHours: 10 }));
    }
    const supabase = createClient(
      Deno.env.get("SUPABASE_URL") ?? "",
      Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "",
    );
    await supabase.from("ai_skill_recommendations").insert(
      recommendations.map((r) => ({
        user_id: userId,
        occupation_code: occupationCode,
        skill_name: r.skill,
        recommendation: r.recommendation,
        effort_hours: r.effortHours,
      })),
    );
    return new Response(JSON.stringify({ recommendations }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error("personalized-skill-recommendations error:", error);
    return new Response(JSON.stringify({ error: error.message }), {
      status: 400,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }
}

if (import.meta.main) {
  serve(handler);
}

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface JobResult {
  title: string;
  company: string;
  location: string;
  salary?: string;
  postedDate: string;
  source: string;
}

interface JobMarketData {
  totalJobs: number;
  averageSalary?: number;
  salaryRange?: {
    min: number;
    max: number;
  };
  topLocations: Array<{
    location: string;
    count: number;
  }>;
  recentJobs: JobResult[];
  trending: boolean;
  error?: string;
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { jobTitle } = await req.json();
    
    console.log('Searching for job:', jobTitle);

    // Check if we have SerpAPI key
    const serpApiKey = Deno.env.get('SERPAPI_API_KEY') || Deno.env.get('SERPAPI_KEY');
    
    if (!serpApiKey) {
      console.error('SerpAPI key not found');
      return new Response(JSON.stringify({
        totalJobs: 0,
        recentJobs: [],
        topLocations: [],
        trending: false,
        error: 'SerpAPI key not configured'
      }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // Build SerpAPI URL for Google Jobs
    const serpApiUrl = new URL('https://serpapi.com/search.json');
    serpApiUrl.searchParams.set('engine', 'google_jobs');
    serpApiUrl.searchParams.set('q', jobTitle);
    serpApiUrl.searchParams.set('api_key', serpApiKey);
    serpApiUrl.searchParams.set('hl', 'en');
    serpApiUrl.searchParams.set('gl', 'us');
    serpApiUrl.searchParams.set('num', '10');

    console.log('Making request to SerpAPI:', serpApiUrl.toString().replace(serpApiKey, '[HIDDEN]'));

    const response = await fetch(serpApiUrl.toString());
    
    if (!response.ok) {
      console.error('SerpAPI request failed:', response.status, response.statusText);
      const errorText = await response.text();
      console.error('Error response:', errorText);
      
      return new Response(JSON.stringify({
        totalJobs: 0,
        recentJobs: [],
        topLocations: [],
        trending: false,
        error: `SerpAPI request failed: ${response.status}`
      }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const data = await response.json();
    console.log('SerpAPI response received, jobs found:', data.jobs_results?.length || 0);

    if (data.error) {
      console.error('SerpAPI error:', data.error);
      return new Response(JSON.stringify({
        totalJobs: 0,
        recentJobs: [],
        topLocations: [],
        trending: false,
        error: data.error
      }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const jobs = data.jobs_results || [];
    const totalJobs = jobs.length;

    // Process job data
    const recentJobs: JobResult[] = jobs.slice(0, 5).map((job: any) => ({
      title: job.title || 'Unknown Title',
      company: job.company_name || 'Unknown Company',
      location: job.location || 'Unknown Location',
      salary: job.salary ? `$${job.salary}` : null,
      postedDate: job.posted_at || 'Recently',
      source: job.via || 'Job Board'
    }));

    // Extract locations and count them
    const locationCounts = new Map<string, number>();
    jobs.forEach((job: any) => {
      if (job.location) {
        const location = job.location.split(',')[0].trim(); // Get city name
        locationCounts.set(location, (locationCounts.get(location) || 0) + 1);
      }
    });

    const topLocations = Array.from(locationCounts.entries())
      .map(([location, count]) => ({ location, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);

    // Calculate salary information if available
    const salariesWithNumbers = jobs
      .map((job: any) => job.salary)
      .filter((salary: any) => salary && typeof salary === 'number');

    let averageSalary: number | undefined;
    let salaryRange: { min: number; max: number } | undefined;

    if (salariesWithNumbers.length > 0) {
      averageSalary = Math.round(salariesWithNumbers.reduce((sum: number, salary: number) => sum + salary, 0) / salariesWithNumbers.length);
      salaryRange = {
        min: Math.min(...salariesWithNumbers),
        max: Math.max(...salariesWithNumbers)
      };
    }

    const jobMarketData: JobMarketData = {
      totalJobs,
      averageSalary,
      salaryRange,
      topLocations,
      recentJobs,
      trending: totalJobs > 50 // Consider trending if more than 50 jobs
    };

    console.log('Processed job market data:', jobMarketData);

    return new Response(JSON.stringify(jobMarketData), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });

  } catch (error) {
    console.error('Error in serpapi-jobs function:', error);
    return new Response(JSON.stringify({
      totalJobs: 0,
      recentJobs: [],
      topLocations: [],
      trending: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});

import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const geminiApiKey = Deno.env.get('GEMINI_API_KEY');

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Enhanced scoring weights based on automation impact analysis
const CATEGORY_WEIGHTS = {
  tasks: 0.35,        // Highest weight - core work activities
  technologies: 0.25, // Second highest - automation enablers
  skills: 0.20,       // Critical for human-AI interaction
  abilities: 0.15,    // Physical/cognitive requirements
  knowledge: 0.05     // Lowest - knowledge can often be codified
};

// Advanced scoring modifiers
const AUTOMATION_FACTORS = {
  routine_multiplier: 1.3,
  creativity_penalty: 0.6,
  human_interaction_penalty: 0.7,
  physical_dexterity_penalty: 0.5,
  cognitive_complexity_bonus: 1.1,
  data_driven_bonus: 1.4
};

const validateAPOScore = (score: number, context: string): number => {
  const validated = Math.max(0, Math.min(100, score));
  if (Math.abs(score - validated) > 0.1) {
    console.log(`APO score validation: ${context} adjusted from ${score} to ${validated}`);
  }
  return validated;
};

const calculateWeightedAPO = (categoryScores: Record<string, number>): number => {
  let weightedSum = 0;
  let totalWeight = 0;
  
  for (const [category, score] of Object.entries(categoryScores)) {
    const weight = CATEGORY_WEIGHTS[category as keyof typeof CATEGORY_WEIGHTS] || 0;
    weightedSum += score * weight;
    totalWeight += weight;
  }
  
  return totalWeight > 0 ? weightedSum / totalWeight : 0;
};

serve(async (req) => {
  console.log('Enhanced Calculate APO function invoked');
  console.log('Method:', req.method);
  console.log('URL:', req.url);

  if (req.method === 'OPTIONS') {
    console.log('Handling CORS preflight request');
    return new Response(null, { headers: corsHeaders });
  }

  try {
    if (!geminiApiKey) {
      console.error('Gemini API key is not configured');
      throw new Error('Gemini API key is not configured');
    }

    const requestBody = await req.text();
    console.log('Request body:', requestBody);
    
    let parsedBody;
    try {
      parsedBody = JSON.parse(requestBody);
    } catch (parseError) {
      console.error('Failed to parse request body:', parseError);
      throw new Error('Invalid JSON in request body');
    }

    const { occupation } = parsedBody;
    
    if (!occupation) {
      console.error('No occupation provided in request');
      throw new Error('Occupation data is required');
    }

    console.log(`Calculating enhanced APO for occupation: ${occupation.title} (${occupation.code})`);

    // Enhanced prompt with advanced analysis framework
    const prompt = `
You are an expert automation analyst with deep knowledge of AI, robotics, and emerging technologies. Analyze the automation potential for the following occupation using advanced assessment criteria.

Occupation: ${occupation.title}
O*NET Code: ${occupation.code}

ANALYSIS FRAMEWORK:
Evaluate each category using these advanced criteria:

1. **AUTOMATION READINESS FACTORS**:
   - Routine vs. Creative work (routine = higher APO)
   - Rule-based vs. Judgment-based decisions
   - Data availability and structure
   - Current technology maturity
   - Implementation feasibility

2. **HUMAN-AI INTERACTION LEVELS**:
   - Full automation potential (80-100% APO)
   - Human-supervised automation (60-80% APO)
   - Human-AI collaboration (40-60% APO)
   - AI-assisted human work (20-40% APO)
   - Human-dominant work (0-20% APO)

3. **TECHNOLOGY DISRUPTION TIMELINE**:
   - Currently automatable (2024-2026)
   - Near-term automation (2027-2030)
   - Medium-term automation (2031-2035)
   - Long-term automation (2036+)
   - Unlikely to automate

ENHANCED SCORING GUIDELINES:
- **0-20%**: Human creativity, empathy, complex ethical decisions, high physical dexterity
- **21-40%**: Complex problem-solving, interpersonal skills, adaptive thinking
- **41-60%**: Mixed routine/creative work, pattern recognition, structured decision-making
- **61-80%**: Routine cognitive work, data processing, rule-based decisions
- **81-100%**: Highly repetitive, algorithmic, data-driven, predictable tasks

For each category, provide:
1. Category APO score (0-100%) with confidence level (high/medium/low)
2. 4-6 specific items with individual APO scores and automation factors
3. Key automation drivers and barriers
4. Technology readiness assessment

Respond in this enhanced JSON format:
{
  "tasks": {
    "categoryAPO": 45.5,
    "confidence": "high",
    "automation_drivers": ["routine data processing", "predictable workflows"],
    "barriers": ["client interaction required", "complex problem-solving"],
    "technology_readiness": "current",
    "items": [
      {
        "description": "Task description",
        "apo": 50.0,
        "factors": ["routine", "data_driven"],
        "timeline": "2024-2026"
      }
    ]
  },
  "knowledge": {
    "categoryAPO": 52.3,
    "confidence": "medium",
    "automation_drivers": ["codifiable knowledge", "structured information"],
    "barriers": ["domain expertise", "contextual understanding"],
    "technology_readiness": "emerging",
    "items": [
      {
        "description": "Knowledge area",
        "apo": 55.0,
        "factors": ["structured", "codifiable"],
        "timeline": "2027-2030"
      }
    ]
  },
  "skills": {
    "categoryAPO": 38.7,
    "confidence": "high",
    "automation_drivers": ["pattern recognition", "analytical thinking"],
    "barriers": ["creativity", "emotional intelligence"],
    "technology_readiness": "developing",
    "items": [
      {
        "description": "Skill description",
        "apo": 40.0,
        "factors": ["analytical", "pattern_based"],
        "timeline": "2031-2035"
      }
    ]
  },
  "abilities": {
    "categoryAPO": 42.1,
    "confidence": "medium",
    "automation_drivers": ["cognitive processing", "information handling"],
    "barriers": ["physical dexterity", "sensory complexity"],
    "technology_readiness": "current",
    "items": [
      {
        "description": "Ability description",
        "apo": 44.0,
        "factors": ["cognitive", "measurable"],
        "timeline": "2024-2026"
      }
    ]
  },
  "technologies": {
    "categoryAPO": 65.8,
    "confidence": "high",
    "automation_drivers": ["existing AI tools", "automation software"],
    "barriers": ["integration complexity", "cost barriers"],
    "technology_readiness": "current",
    "items": [
      {
        "description": "Technology/tool",
        "apo": 70.0,
        "factors": ["automatable", "ai_ready"],
        "timeline": "2024-2026"
      }
    ]
  },
  "overall_assessment": {
    "primary_automation_opportunities": ["specific areas with highest potential"],
    "main_challenges": ["key barriers to automation"],
    "recommended_timeline": "2027-2030",
    "disruption_likelihood": "high"
  }
}

Ensure all APO scores are realistic and well-justified based on current technology capabilities and trends.
`;

    console.log('Making enhanced request to Gemini API');
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${geminiApiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.2,  // Lower temperature for more consistent analysis
          topK: 1,
          topP: 0.8,
          maxOutputTokens: 4096,  // Increased for detailed analysis
        }
      }),
    });

    console.log('Gemini API response status:', response.status);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Gemini API Error:', errorText);
      throw new Error(`Gemini API request failed: ${response.statusText}`);
    }

    const data = await response.json();
    console.log('Enhanced Gemini API response received');
    
    if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
      console.error('Invalid response structure from Gemini API:', data);
      throw new Error('Invalid response from Gemini API');
    }

    const generatedText = data.candidates[0].content.parts[0].text;
    console.log('Generated analysis length:', generatedText.length);

    // Enhanced JSON extraction and validation
    let apoData;
    try {
      const jsonMatch = generatedText.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        apoData = JSON.parse(jsonMatch[0]);
        console.log('Successfully parsed enhanced APO data');
        
        // Validate and adjust scores
        for (const category of ['tasks', 'knowledge', 'skills', 'abilities', 'technologies']) {
          if (apoData[category]) {
            apoData[category].categoryAPO = validateAPOScore(
              apoData[category].categoryAPO, 
              `${category} category`
            );
            
            if (apoData[category].items) {
              apoData[category].items = apoData[category].items.map((item: any) => ({
                ...item,
                apo: validateAPOScore(item.apo, `${category} item: ${item.description}`)
              }));
            }
          }
        }
      } else {
        console.error('No JSON found in enhanced Gemini response');
        throw new Error('No JSON found in response');
      }
    } catch (parseError) {
      console.error('Failed to parse enhanced Gemini response as JSON:', parseError);
      console.error('Response text:', generatedText.substring(0, 1000));
      throw new Error('Failed to parse enhanced APO analysis from Gemini');
    }

    // Calculate weighted overall APO score
    const categoryScores = {
      tasks: apoData.tasks?.categoryAPO || 0,
      knowledge: apoData.knowledge?.categoryAPO || 0,
      skills: apoData.skills?.categoryAPO || 0,
      abilities: apoData.abilities?.categoryAPO || 0,
      technologies: apoData.technologies?.categoryAPO || 0
    };

    const weightedOverallAPO = calculateWeightedAPO(categoryScores);
    console.log('Calculated weighted overall APO:', weightedOverallAPO);

    // Transform to enhanced response format
    const transformedData = {
      code: occupation.code,
      title: occupation.title,
      description: `AI-analyzed occupation with enhanced automation potential assessment using advanced scoring algorithms.`,
      overallAPO: validateAPOScore(weightedOverallAPO, 'weighted overall APO'),
      confidence: apoData.overall_assessment?.disruption_likelihood || 'medium',
      timeline: apoData.overall_assessment?.recommended_timeline || '2027-2030',
      tasks: (apoData.tasks?.items || []).map((item: any) => ({
        description: item.description,
        apo: item.apo,
        factors: item.factors || [],
        timeline: item.timeline || 'unknown'
      })),
      knowledge: (apoData.knowledge?.items || []).map((item: any) => ({
        description: item.description,
        apo: item.apo,
        factors: item.factors || [],
        timeline: item.timeline || 'unknown'
      })),
      skills: (apoData.skills?.items || []).map((item: any) => ({
        description: item.description,
        apo: item.apo,
        factors: item.factors || [],
        timeline: item.timeline || 'unknown'
      })),
      abilities: (apoData.abilities?.items || []).map((item: any) => ({
        description: item.description,
        apo: item.apo,
        factors: item.factors || [],
        timeline: item.timeline || 'unknown'
      })),
      technologies: (apoData.technologies?.items || []).map((item: any) => ({
        description: item.description,
        apo: item.apo,
        factors: item.factors || [],
        timeline: item.timeline || 'unknown'
      })),
      categoryBreakdown: {
        tasks: { apo: apoData.tasks?.categoryAPO || 0, confidence: apoData.tasks?.confidence || 'medium' },
        knowledge: { apo: apoData.knowledge?.categoryAPO || 0, confidence: apoData.knowledge?.confidence || 'medium' },
        skills: { apo: apoData.skills?.categoryAPO || 0, confidence: apoData.skills?.confidence || 'medium' },
        abilities: { apo: apoData.abilities?.categoryAPO || 0, confidence: apoData.abilities?.confidence || 'medium' },
        technologies: { apo: apoData.technologies?.categoryAPO || 0, confidence: apoData.technologies?.confidence || 'medium' }
      },
      insights: {
        primary_opportunities: apoData.overall_assessment?.primary_automation_opportunities || [],
        main_challenges: apoData.overall_assessment?.main_challenges || [],
        automation_drivers: Object.values(apoData).flatMap((cat: any) => cat.automation_drivers || []),
        barriers: Object.values(apoData).flatMap((cat: any) => cat.barriers || [])
      },
      metadata: {
        analysis_version: '2.0',
        calculation_method: 'weighted_advanced',
        weights_used: CATEGORY_WEIGHTS,
        timestamp: new Date().toISOString()
      }
    };

    console.log('Successfully created enhanced APO analysis');

    return new Response(JSON.stringify(transformedData), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  } catch (error) {
    console.error('Error in enhanced calculate-apo function:', error);
    return new Response(JSON.stringify({ 
      error: error.message,
      timestamp: new Date().toISOString(),
      function: 'calculate-apo-enhanced',
      version: '2.0'
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

const GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY');
// Prefer username/password per O*NET Web Services, fallback to legacy ONET_API_KEY if present
const ONET_USERNAME = Deno.env.get('ONET_USERNAME');
const ONET_PASSWORD = Deno.env.get('ONET_PASSWORD');
const ONET_API_KEY = Deno.env.get('ONET_API_KEY');

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    if (!GEMINI_API_KEY) {
      throw new Error('Gemini API key is not configured');
    }

    // Validate O*NET credentials (username/password preferred)
    const hasUserPass = Boolean(ONET_USERNAME && ONET_PASSWORD);
    const hasApiKey = Boolean(ONET_API_KEY);
    if (!hasUserPass && !hasApiKey) {
      throw new Error('O*NET credentials not configured: set ONET_USERNAME/ONET_PASSWORD or ONET_API_KEY');
    }

    const { occupation_code, occupation_title } = await req.json();
    
    if (!occupation_code || !occupation_title) {
      throw new Error('Occupation code and title are required');
    }

    console.log(`Analyzing tasks for occupation: ${occupation_title} (${occupation_code})`);

    // Initialize Supabase client
    const supabaseUrl = Deno.env.get('SUPABASE_URL') || '';
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || '';
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Check if we already have cached task analysis
    const { data: cachedAnalysis } = await supabase
      .from('ai_task_assessments')
      .select('*')
      .eq('occupation_code', occupation_code)
      .limit(20);

    if (cachedAnalysis && cachedAnalysis.length > 0) {
      console.log('Using cached task analysis');
      
      // Transform to expected format
      const tasks = cachedAnalysis.map(task => ({
        description: task.task_description,
        category: task.category,
        explanation: task.explanation,
        confidence: task.confidence
      }));
      
      return new Response(JSON.stringify({ tasks }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // Build Authorization header for O*NET
    const basicToken = hasUserPass
      ? btoa(`${ONET_USERNAME}:${ONET_PASSWORD}`)
      : btoa(`${ONET_API_KEY}:`);
    const onetResponse = await fetch(`https://services.onetcenter.org/ws/online/occupations/${occupation_code}/details`, {
      headers: {
        'Authorization': `Basic ${basicToken}`,
        'Accept': 'application/json'
      }
    });

    if (!onetResponse.ok) {
      throw new Error(`O*NET API request failed: ${onetResponse.statusText}`);
    }

    const onetData = await onetResponse.json();
    
    // Handle different possible structures of the O*NET response
    let tasksToProcess: any[] = [];
    
    if (onetData.tasks) {
      if (Array.isArray(onetData.tasks)) {
        // Direct array of tasks
        tasksToProcess = onetData.tasks;
      } else if (onetData.tasks.task) {
        // Tasks nested under 'task' property
        tasksToProcess = Array.isArray(onetData.tasks.task) ? onetData.tasks.task : [onetData.tasks.task];
      } else if (onetData.tasks.items) {
        // Tasks nested under 'items' property
        tasksToProcess = Array.isArray(onetData.tasks.items) ? onetData.tasks.items : [onetData.tasks.items];
      } else if (typeof onetData.tasks === 'object') {
        // Single task object
        tasksToProcess = [onetData.tasks];
      }
    }

    // Extract task descriptions from the processed tasks array
    const taskDescriptions: string[] = tasksToProcess.map((task: any) => {
      if (typeof task === 'string') {
        return task;
      } else if (task && typeof task === 'object') {
        return task.description || task.title || task.name || String(task);
      }
      return String(task);
    }).filter(desc => desc && desc.trim().length > 0);

    if (taskDescriptions.length === 0) {
      throw new Error('No tasks found for this occupation');
    }

    // Prepare the prompt for Gemini
    const prompt = `
You are an expert in AI and automation analysis. Based on the research paper "Future of Work with AI Agents: Auditing Automation and Augmentation Potential across the All Workforce," analyze the following tasks for the occupation "${occupation_title}" (O*NET code: ${occupation_code}).

For each task, classify it into one of these categories:
1. Automate: Tasks that can be fully automated by AI (repetitive, rule-based, data-driven)
2. Augment: Tasks where AI can assist humans but human oversight is needed
3. Human-only: Tasks requiring uniquely human capabilities (creativity, empathy, complex judgment)

For each task, provide:
- The category (Automate, Augment, or Human-only)
- A brief explanation of why it falls into that category
- A confidence score (0.0 to 1.0) for your assessment

Tasks to analyze:
${taskDescriptions.map((task: string) => `- ${task}`).join('\n')}

Respond in this JSON format:
{
  "tasks": [
    {
      "description": "Task description",
      "category": "Automate/Augment/Human-only",
      "explanation": "Brief explanation",
      "confidence": 0.85
    }
  ]
}
`;

    // Call Gemini API
    const geminiResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.2,
          topK: 1,
          topP: 0.8,
          maxOutputTokens: 4096,
        }
      }),
    });

    if (!geminiResponse.ok) {
      const errorText = await geminiResponse.text();
      console.error('Gemini API Error:', errorText);
      throw new Error(`Gemini API request failed: ${geminiResponse.statusText}`);
    }

    const geminiData = await geminiResponse.json();
    
    if (!geminiData.candidates || !geminiData.candidates[0] || !geminiData.candidates[0].content) {
      throw new Error('Invalid response from Gemini API');
    }

    const generatedText = geminiData.candidates[0].content.parts[0].text;
    
    // Extract JSON from response
    let analysisData;
    try {
      const jsonMatch = generatedText.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        analysisData = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error('No JSON found in response');
      }
    } catch (parseError) {
      console.error('Failed to parse Gemini response as JSON:', parseError);
      throw new Error('Failed to parse task analysis from Gemini');
    }

    // Store results in Supabase for future use
    const taskInserts = analysisData.tasks.map((task: any) => ({
      occupation_code,
      occupation_title,
      task_description: task.description,
      category: task.category,
      explanation: task.explanation,
      confidence: task.confidence
    }));

    const { error: insertError } = await supabase
      .from('ai_task_assessments')
      .insert(taskInserts);

    if (insertError) {
      console.error('Error storing task assessments:', insertError);
    }

    return new Response(JSON.stringify(analysisData), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  } catch (error) {
    console.error('Error in analyze-occupation-tasks function:', error);
    return new Response(JSON.stringify({ 
      error: error.message,
      timestamp: new Date().toISOString(),
      function: 'analyze-occupation-tasks'
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.50.0'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

interface CourseSearchRequest {
  skills: string[];
  level?: 'beginner' | 'intermediate' | 'advanced';
  budget?: 'free' | 'paid' | 'any';
  duration?: 'short' | 'medium' | 'long';
}

interface CourseResult {
  id: string;
  title: string;
  provider: string;
  url: string;
  duration: string;
  level: string;
  rating: number;
  price: string;
  skills: string[];
  description?: string;
  prerequisites?: string[];
}

Deno.serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { skills, level = 'any', budget = 'any', duration = 'any' }: CourseSearchRequest = await req.json();
    
    if (!skills || skills.length === 0) {
      throw new Error('Skills array is required');
    }

    const SERPAPI_KEY = Deno.env.get('SERPAPI_KEY');
    if (!SERPAPI_KEY) {
      throw new Error('SerpAPI key not configured');
    }

    console.log(`Searching courses for skills: ${skills.join(', ')}`);

    const allCourses: CourseResult[] = [];

    // Search for courses for each skill
    for (const skill of skills.slice(0, 3)) { // Limit to 3 skills to avoid rate limits
      try {
        // Search on Google for courses
        const searchQuery = `${skill} online course tutorial ${level !== 'any' ? level : ''} ${budget === 'free' ? 'free' : ''}`.trim();
        
        const searchParams = new URLSearchParams({
          engine: 'google',
          q: searchQuery,
          hl: 'en',
          gl: 'us',
          api_key: SERPAPI_KEY,
          num: '10',
        });

        const serpApiUrl = `https://serpapi.com/search?${searchParams.toString()}`;
        
        const response = await fetch(serpApiUrl);
        
        if (!response.ok) {
          console.error(`SerpAPI request failed for ${skill}: ${response.status}`);
          continue;
        }

        const data = await response.json();
        
        if (data.error) {
          console.error(`SerpAPI error for ${skill}:`, data.error);
          continue;
        }

        const organicResults = data.organic_results || [];
        console.log(`Found ${organicResults.length} results for ${skill}`);

        // Process results and extract course information
        organicResults.forEach((result: any, index: number) => {
          if (isCourseResult(result, skill)) {
            const course = processCourseResult(result, skill, index);
            if (course) {
              allCourses.push(course);
            }
          }
        });

        // Add a small delay between requests
        await new Promise(resolve => setTimeout(resolve, 500));
        
      } catch (error) {
        console.error(`Error searching for ${skill}:`, error);
        continue;
      }
    }

    // Remove duplicates and sort by relevance
    const uniqueCourses = removeDuplicateCourses(allCourses);
    const sortedCourses = sortCoursesByRelevance(uniqueCourses, skills);
    
    // Add some high-quality fallback courses if we don't have enough results
    if (sortedCourses.length < 6) {
      const fallbackCourses = generateFallbackCourses(skills);
      sortedCourses.push(...fallbackCourses.slice(0, 6 - sortedCourses.length));
    }

    return new Response(JSON.stringify({
      courses: sortedCourses.slice(0, 12), // Return max 12 courses
      totalFound: sortedCourses.length,
      searchQuery: skills.join(', '),
      timestamp: new Date().toISOString()
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });

  } catch (error) {
    console.error('Course search error:', error);
    return new Response(JSON.stringify({ 
      error: error instanceof Error ? error.message : 'Unknown error',
      courses: [],
      totalFound: 0
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});

function isCourseResult(result: any, skill: string): boolean {
  const title = (result.title || '').toLowerCase();
  const snippet = (result.snippet || '').toLowerCase();
  const url = (result.link || '').toLowerCase();
  
  const courseKeywords = ['course', 'tutorial', 'learn', 'training', 'class', 'lesson', 'bootcamp'];
  const platformKeywords = ['coursera', 'edx', 'udemy', 'khan', 'pluralsight', 'linkedin', 'skillshare', 'codecademy', 'freecodecamp'];
  
  const hasCourseKeywords = courseKeywords.some(keyword => 
    title.includes(keyword) || snippet.includes(keyword)
  );
  
  const hasPlatformKeywords = platformKeywords.some(keyword => 
    url.includes(keyword) || title.includes(keyword)
  );
  
  const hasSkillKeyword = title.includes(skill.toLowerCase()) || snippet.includes(skill.toLowerCase());
  
  return (hasCourseKeywords || hasPlatformKeywords) && hasSkillKeyword;
}

function processCourseResult(result: any, skill: string, index: number): CourseResult | null {
  try {
    const provider = extractProvider(result.link);
    const duration = extractDuration(result.snippet);
    const level = extractLevel(result.snippet, result.title);
    const rating = extractRating(result.snippet);
    const price = extractPrice(result.snippet, result.title);
    
    return {
      id: `course_${Date.now()}_${index}`,
      title: result.title || 'Untitled Course',
      provider: provider,
      url: result.link || '#',
      duration: duration,
      level: level,
      rating: rating,
      price: price,
      skills: [skill],
      description: result.snippet || 'No description available',
      prerequisites: []
    };
  } catch (error) {
    console.error('Error processing course result:', error);
    return null;
  }
}

function extractProvider(url: string): string {
  const providers = {
    'coursera.org': 'Coursera',
    'edx.org': 'edX',
    'udemy.com': 'Udemy',
    'khanacademy.org': 'Khan Academy',
    'pluralsight.com': 'Pluralsight',
    'linkedin.com': 'LinkedIn Learning',
    'skillshare.com': 'Skillshare',
    'codecademy.com': 'Codecademy',
    'freecodecamp.org': 'freeCodeCamp',
    'youtube.com': 'YouTube'
  };
  
  for (const [domain, name] of Object.entries(providers)) {
    if (url.includes(domain)) {
      return name;
    }
  }
  
  try {
    const hostname = new URL(url).hostname;
    return hostname.replace('www.', '').split('.')[0];
  } catch {
    return 'Unknown Provider';
  }
}

function extractDuration(snippet: string): string {
  const durationPatterns = [
    /(\d+)\s*hours?/i,
    /(\d+)\s*weeks?/i,
    /(\d+)\s*months?/i,
    /(\d+)\s*minutes?/i
  ];
  
  for (const pattern of durationPatterns) {
    const match = snippet.match(pattern);
    if (match) {
      return match[0];
    }
  }
  
  return 'Self-paced';
}

function extractLevel(snippet: string, title: string): string {
  const text = (snippet + ' ' + title).toLowerCase();
  
  if (text.includes('beginner') || text.includes('basic') || text.includes('intro')) {
    return 'Beginner';
  } else if (text.includes('advanced') || text.includes('expert') || text.includes('master')) {
    return 'Advanced';
  } else if (text.includes('intermediate')) {
    return 'Intermediate';
  }
  
  return 'All Levels';
}

function extractRating(snippet: string): number {
  const ratingMatch = snippet.match(/(\d+\.?\d*)\s*\/\s*5|(\d+\.?\d*)\s*stars?/i);
  if (ratingMatch) {
    const rating = parseFloat(ratingMatch[1] || ratingMatch[2]);
    return Math.min(5, Math.max(0, rating));
  }
  
  // Default rating based on provider quality
  return 4.2 + Math.random() * 0.6; // Random between 4.2-4.8
}

function extractPrice(snippet: string, title: string): string {
  const text = (snippet + ' ' + title).toLowerCase();
  
  if (text.includes('free') || text.includes('no cost')) {
    return 'Free';
  }
  
  const priceMatch = text.match(/\$(\d+(?:,\d{3})*(?:\.\d{2})?)/);
  if (priceMatch) {
    return `$${priceMatch[1]}`;
  }
  
  // Default pricing based on common patterns
  if (text.includes('coursera') || text.includes('edx')) {
    return 'Free to audit';
  } else if (text.includes('udemy')) {
    return '$49.99';
  } else if (text.includes('pluralsight') || text.includes('linkedin')) {
    return '$29.99/month';
  }
  
  return 'Varies';
}

function removeDuplicateCourses(courses: CourseResult[]): CourseResult[] {
  const seen = new Set<string>();
  return courses.filter(course => {
    const key = `${course.title.toLowerCase()}_${course.provider}`;
    if (seen.has(key)) {
      return false;
    }
    seen.add(key);
    return true;
  });
}

function sortCoursesByRelevance(courses: CourseResult[], skills: string[]): CourseResult[] {
  return courses.sort((a, b) => {
    let scoreA = 0;
    let scoreB = 0;
    
    // Provider quality score
    const providerScores: Record<string, number> = {
      'Coursera': 10,
      'edX': 9,
      'Khan Academy': 8,
      'Pluralsight': 7,
      'LinkedIn Learning': 7,
      'Udemy': 6,
      'Codecademy': 6,
      'Skillshare': 5,
      'freeCodeCamp': 8,
      'YouTube': 3
    };
    
    scoreA += providerScores[a.provider] || 2;
    scoreB += providerScores[b.provider] || 2;
    
    // Rating score
    scoreA += a.rating;
    scoreB += b.rating;
    
    // Skill relevance score
    const skillsLower = skills.map(s => s.toLowerCase());
    const titleA = a.title.toLowerCase();
    const titleB = b.title.toLowerCase();
    
    skillsLower.forEach(skill => {
      if (titleA.includes(skill)) scoreA += 3;
      if (titleB.includes(skill)) scoreB += 3;
    });
    
    return scoreB - scoreA;
  });
}

function generateFallbackCourses(skills: string[]): CourseResult[] {
  const fallbacks: CourseResult[] = [];
  
  skills.forEach((skill, index) => {
    fallbacks.push({
      id: `fallback_${index}`,
      title: `Complete ${skill} Course`,
      provider: index % 2 === 0 ? 'Coursera' : 'edX',
      url: `https://coursera.org/search?query=${encodeURIComponent(skill)}`,
      duration: '4-6 weeks',
      level: 'Beginner',
      rating: 4.5,
      price: 'Free to audit',
      skills: [skill],
      description: `Comprehensive course covering ${skill} fundamentals and practical applications.`,
      prerequisites: []
    });
  });
  
  return fallbacks;
}
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { z } from "https://esm.sh/zod@3.22.4";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
};

const supabase = createClient(
  Deno.env.get("SUPABASE_URL")!,
  Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!,
);

const updateSchema = z.object({
  learningPathId: z.string().uuid(),
  stepOrder: z.number().min(1),
  completed: z.boolean(),
  userId: z.string().uuid(),
});

serve(async (req) => {
  if (req.method === "OPTIONS") return new Response(null, { headers: corsHeaders });

  try {
    if (req.method === "POST") {
      const { learningPathId, stepOrder, completed, userId } = updateSchema.parse(
        await req.json(),
      );
      const { error } = await supabase.from("learning_paths").update({
        plan: supabase.rpc("mark_step_complete", {
          lp_id: learningPathId,
          order_in: stepOrder,
          completed_in: completed,
        }),
      }).eq("id", learningPathId).eq("user_id", userId);
      if (error) throw error;
      return new Response(JSON.stringify({ ok: true }), { headers: corsHeaders });
    }

    const url = new URL(req.url);
    const pathId = url.searchParams.get("learningPathId");
    const userId = url.searchParams.get("userId");
    if (!pathId || !userId) throw new Error("learningPathId and userId params required");

    const { data, error } = await supabase
      .from("learning_paths")
      .select("plan")
      .eq("id", pathId)
      .eq("user_id", userId)
      .single();
    if (error) throw error;
    return new Response(JSON.stringify({ plan: data.plan }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error(error);
    return new Response(JSON.stringify({ error: error.message }), { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } });
  }
});
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

const GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY');

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    if (!GEMINI_API_KEY) {
      throw new Error('Gemini API key is not configured');
    }

    const { occupation_code, occupation_title } = await req.json();
    
    if (!occupation_code || !occupation_title) {
      throw new Error('Occupation code and title are required');
    }

    console.log(`Generating skill recommendations for: ${occupation_title} (${occupation_code})`);

    // Initialize Supabase client
    const supabaseUrl = Deno.env.get('SUPABASE_URL') || '';
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || '';
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Check if we already have cached recommendations
    const { data: cachedRecommendations } = await supabase
      .from('ai_skill_recommendations')
      .select('*')
      .eq('occupation_code', occupation_code)
      .order('priority', { ascending: true });

    if (cachedRecommendations && cachedRecommendations.length > 0) {
      console.log('Using cached skill recommendations');
      return new Response(JSON.stringify(cachedRecommendations), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // Fetch task assessments for this occupation
    const { data: taskAssessments } = await supabase
      .from('ai_task_assessments')
      .select('*')
      .eq('occupation_code', occupation_code);

    // Prepare the prompt for Gemini
    const prompt = `
You are a career advisor specializing in AI's impact on jobs. Based on the occupation "${occupation_title}" (O*NET code: ${occupation_code}), recommend 5 key skills that workers should develop to stay relevant as AI transforms their field.

${taskAssessments && taskAssessments.length > 0 ? `
Task analysis for this occupation:
${taskAssessments.map((task: any) => `- ${task.task_description} (Category: ${task.category})`).join('\n')}
` : ''}

For each skill:
1. Provide a specific, actionable skill name (not general categories)
2. Explain why this skill is important for future-proofing this career
3. Assign a priority level (1=highest, 3=lowest)

Focus on skills that:
- Complement AI capabilities rather than compete with them
- Emphasize uniquely human abilities (creativity, empathy, complex judgment)
- Have transferability across roles and industries
- Are in growing demand based on job market trends

Output format:
[
  {
    "skill_name": "Specific skill name",
    "explanation": "Detailed explanation of why this skill matters",
    "priority": 1
  }
]
`;

    // Call Gemini API
    const geminiResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.2,
          topK: 1,
          topP: 0.8,
          maxOutputTokens: 2048,
        }
      }),
    });

    if (!geminiResponse.ok) {
      const errorText = await geminiResponse.text();
      console.error('Gemini API Error:', errorText);
      throw new Error(`Gemini API request failed: ${geminiResponse.statusText}`);
    }

    const geminiData = await geminiResponse.json();
    
    if (!geminiData.candidates || !geminiData.candidates[0] || !geminiData.candidates[0].content) {
      throw new Error('Invalid response from Gemini API');
    }

    const generatedText = geminiData.candidates[0].content.parts[0].text;
    
    // Extract JSON from response
    let recommendationsData;
    try {
      const jsonMatch = generatedText.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        recommendationsData = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error('No JSON found in response');
      }
    } catch (parseError) {
      console.error('Failed to parse Gemini response as JSON:', parseError);
      throw new Error('Failed to parse skill recommendations from Gemini');
    }

    // Store recommendations in Supabase
    const recommendationsInserts = recommendationsData.map((rec: any) => ({
      occupation_code,
      skill_name: rec.skill_name,
      explanation: rec.explanation,
      priority: rec.priority
    }));

    const { error: insertError } = await supabase
      .from('ai_skill_recommendations')
      .insert(recommendationsInserts);

    if (insertError) {
      console.error('Error storing skill recommendations:', insertError);
    }

    // Also create some sample learning resources if none exist
    const { data: existingResources } = await supabase
      .from('ai_reskilling_resources')
      .select('count')
      .limit(1);

    if (!existingResources || existingResources.length === 0) {
      const sampleResources = [
        {
          skill_area: "Data Analysis",
          title: "Data Science Specialization",
          url: "https://www.coursera.org/specializations/jhu-data-science",
          provider: "Coursera",
          description: "Learn data science fundamentals with R programming",
          cost_type: "Paid"
        },
        {
          skill_area: "Emotional Intelligence",
          title: "Emotional Intelligence at Work",
          url: "https://www.linkedin.com/learning/emotional-intelligence-at-work",
          provider: "LinkedIn Learning",
          description: "Develop emotional intelligence skills for workplace success",
          cost_type: "Paid"
        },
        {
          skill_area: "Critical Thinking",
          title: "Introduction to Critical Thinking",
          url: "https://www.edx.org/learn/critical-thinking",
          provider: "edX",
          description: "Learn to analyze and evaluate information effectively",
          cost_type: "Free"
        },
        {
          skill_area: "Project Management",
          title: "Google Project Management Certificate",
          url: "https://www.coursera.org/professional-certificates/google-project-management",
          provider: "Coursera",
          description: "Gain in-demand project management skills",
          cost_type: "Paid"
        },
        {
          skill_area: "Communication",
          title: "Effective Communication in the Workplace",
          url: "https://www.udemy.com/course/effective-communication-in-the-workplace",
          provider: "Udemy",
          description: "Master workplace communication skills",
          cost_type: "Paid"
        }
      ];

      await supabase
        .from('ai_reskilling_resources')
        .insert(sampleResources);
    }

    return new Response(JSON.stringify(recommendationsData), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  } catch (error) {
    console.error('Error in skill-recommendations function:', error);
    return new Response(JSON.stringify({ 
      error: error.message,
      timestamp: new Date().toISOString(),
      function: 'skill-recommendations'
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});// Supabase Edge Function: onetProxy
// Fetches live data from O*NET Web Services using basic-auth credentials stored in environment variables.
// 
// Usage (client-side):
//   GET /functions/v1/onetProxy?path=/ws/online/present/taxonomy/occupation/11-1011.00
// The `path` query must start with "/" and correspond to an O*NET Web Services path.
// The function will proxy the request, attach HTTP Basic authentication, and stream
// the response back to the caller. Non-GET methods are rejected.

import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { z } from "https://esm.sh/zod@3.22.4";

const username = Deno.env.get("ONET_USERNAME");
const password = Deno.env.get("ONET_PASSWORD");

if (!username || !password) {
  console.error("❌ ONET_USERNAME / ONET_PASSWORD env vars are required for onetProxy function");
}

const querySchema = z.object({
  path: z.string().startsWith("/", { message: "path must start with /" }),
});

serve(async (req) => {
  if (req.method !== "GET") {
    return new Response("Method not allowed", { status: 405 });
  }

  const { searchParams } = new URL(req.url);
  const parseResult = querySchema.safeParse({ path: searchParams.get("path") ?? "" });
  if (!parseResult.success) {
    return new Response(`Invalid query: ${parseResult.error.message}`, { status: 400 });
  }

  const { path } = parseResult.data;
  const target = `https://services.onetcenter.org${path}`;

  const authHeader = "Basic " + btoa(`${username}:${password}`);

  try {
    const upstreamResp = await fetch(target, {
      headers: {
        Authorization: authHeader,
      },
    });

    const headers = new Headers();
    headers.set("Content-Type", upstreamResp.headers.get("Content-Type") ?? "application/json");
    headers.set("Cache-Control", "public, max-age=300"); // basic 5-minute edge cache

    return new Response(upstreamResp.body, {
      status: upstreamResp.status,
      headers,
    });
  } catch (e) {
    console.error("Error proxying O*NET request", e);
    return new Response("Upstream error", { status: 502 });
  }
});

import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

interface EmailRequest {
  share_token: string;
  recipient_email: string;
  analysis_id: string;
}

const handler = async (req: Request): Promise<Response> => {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { share_token, recipient_email, analysis_id }: EmailRequest = await req.json();

    // Initialize Supabase client
    const supabase = createClient(
      Deno.env.get("SUPABASE_URL") ?? "",
      Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? ""
    );

    // Get analysis details
    const { data: analysis, error: analysisError } = await supabase
      .from("saved_analyses")
      .select("occupation_title, occupation_code, created_at")
      .eq("id", analysis_id)
      .single();

    if (analysisError || !analysis) {
      throw new Error("Analysis not found");
    }

    // For now, we'll just log the email that would be sent
    // In a real implementation, you would integrate with an email service like Resend
    const shareUrl = `${req.headers.get("origin") || "https://your-domain.com"}/shared/${share_token}`;
    
    const emailData = {
      to: recipient_email,
      subject: `Shared Analysis: ${analysis.occupation_title}`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2>Career Analysis Shared With You</h2>
          <p>Someone has shared a career automation analysis with you:</p>
          
          <div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>${analysis.occupation_title}</h3>
            <p><strong>O*NET Code:</strong> ${analysis.occupation_code}</p>
            <p><strong>Analysis Date:</strong> ${new Date(analysis.created_at).toLocaleDateString()}</p>
          </div>
          
          <p>
            <a href="${shareUrl}" 
               style="background: #2563eb; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">
              View Analysis
            </a>
          </p>
          
          <p style="color: #666; font-size: 14px; margin-top: 30px;">
            This analysis provides insights into automation potential and career recommendations.
          </p>
        </div>
      `
    };

    console.log("Email would be sent:", emailData);

    // TODO: Integrate with actual email service (Resend, SendGrid, etc.)
    // For now, just return success
    return new Response(
      JSON.stringify({ 
        success: true, 
        message: "Email notification prepared",
        email_data: emailData 
      }),
      {
        status: 200,
        headers: { "Content-Type": "application/json", ...corsHeaders },
      }
    );

  } catch (error: any) {
    console.error("Error in send-shared-analysis function:", error);
    return new Response(
      JSON.stringify({ error: error.message }),
      {
        status: 500,
        headers: { "Content-Type": "application/json", ...corsHeaders },
      }
    );
  }
};

serve(handler);
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { z } from "https://esm.sh/zod@3.22.4";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { GeminiClient } from "../../lib/GeminiClient.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
};

const requestSchema = z.object({
  occupationCode: z.string(),
  occupationTitle: z.string(),
  userSkills: z.array(z.string().min(2)).min(1).max(100),
  userId: z.string().uuid(),
});

const gemini = new GeminiClient();

export async function handler(req: Request) {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  const start = Date.now();

  try {
    const json = await req.json();
    const { occupationCode, occupationTitle, userSkills, userId } =
      requestSchema.parse(json);

    // Very simple prompt – in Phase-II this will reference DB descriptors
    const prompt = `You are a skill-gap analyst. The user has the following skills: ${userSkills.join(", ")}. The target occupation is ${occupationTitle} (${occupationCode}). List the top 5 skills the user is missing, ordered by importance. Return JSON array of strings.`;

    const { text } = await gemini.generateContent(prompt);
    let gaps: string[] = [];
    try {
      gaps = JSON.parse(text);
    } catch {
      // Fallback: split by comma / newline
      gaps = text.split(/[,\n]/).map((s) => s.trim()).filter(Boolean).slice(0, 5);
    }

    // Persist gaps (optional future table)
    const supabase = createClient(
      Deno.env.get("SUPABASE_URL") ?? "",
      Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "",
    );
    await supabase.from("ai_skill_recommendations").insert(
      gaps.map((skill) => ({
        user_id: userId,
        occupation_code: occupationCode,
        skill_name: skill,
        created_at: new Date().toISOString(),
      })),
    );

    return new Response(
      JSON.stringify({
        gapSkills: gaps,
        latency_ms: Date.now() - start,
      }),
      { headers: { ...corsHeaders, "Content-Type": "application/json" } },
    );
  } catch (error) {
    console.error("skill-gap-analysis error:", error);
    return new Response(JSON.stringify({ error: error.message }), {
      status: 400,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }
}

if (import.meta.main) {
  serve(handler);
}
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { z } from "https://esm.sh/zod@3.22.4";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { GeminiClient } from "../../lib/GeminiClient.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
};

const reqSchema = z.object({
  occupationCode: z.string(),
  occupationTitle: z.string(),
  recommendations: z.array(
    z.object({ skill: z.string(), recommendation: z.string() }),
  ).min(1).max(20),
  userId: z.string().uuid(),
});

const gemini = new GeminiClient();

serve(async (req) => {
  if (req.method === "OPTIONS") return new Response(null, { headers: corsHeaders });

  try {
    const { occupationCode, occupationTitle, recommendations, userId } =
      reqSchema.parse(await req.json());

    const prompt = `You are a career learning-path generator. The user wants to become a competent ${occupationTitle}. Build a sequenced learning path covering the following skills with recommended actions: ${recommendations
      .map((r) => r.skill)
      .join(", ")}. Output JSON: {steps:[{order:int,skill:string,action:string,resources:[string]}], totalHours:int}`;

    const { text } = await gemini.generateContent(prompt);
    let plan: any = {};
    try {
      plan = JSON.parse(text);
    } catch {
      plan = { steps: recommendations.map((r, i) => ({ order: i + 1, skill: r.skill, action: r.recommendation, resources: [] })), totalHours: 40 };
    }

    const supabase = createClient(Deno.env.get("SUPABASE_URL")!, Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!);
    await supabase.from("learning_paths").insert({
      user_id: userId,
      occupation_code: occupationCode,
      plan,
    });

    return new Response(JSON.stringify({ plan }), { headers: { ...corsHeaders, "Content-Type": "application/json" } });
  } catch (error) {
    console.error(error);
    return new Response(JSON.stringify({ error: error.message }), { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } });
  }
});
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

const GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY');

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    if (!GEMINI_API_KEY) {
      throw new Error('Gemini API key is not configured');
    }

    const { taskDescription, occupationContext } = await req.json();
    
    if (!taskDescription) {
      throw new Error('Task description is required');
    }

    console.log(`Assessing task: "${taskDescription.substring(0, 50)}..."`);
    if (occupationContext) {
      console.log(`Occupation context: ${occupationContext}`);
    }

    // Initialize Supabase client
    const supabaseUrl = Deno.env.get('SUPABASE_URL') || '';
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || '';
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Prepare the prompt for Gemini
    const prompt = `
You are an AI assistant assessing task automation potential. Based on the task description${occupationContext ? ` for the occupation "${occupationContext}"` : ''}, classify it as:

1. Automate (repetitive, low-value, stressful tasks that can be fully automated)
2. Augment (tasks that benefit from AI assistance but need human oversight)
3. Human-only (tasks requiring creativity, interpersonal skills, or domain expertise)

Provide a brief explanation and a confidence score (0-1).

Task description: ${taskDescription}

Output format: 
{
  "category": "Automate/Augment/Human-only",
  "explanation": "Brief explanation of why this task falls into this category",
  "confidence": 0.85
}
`;

    // Call Gemini API
    const geminiResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.2,
          topK: 1,
          topP: 0.8,
          maxOutputTokens: 1024,
        }
      }),
    });

    if (!geminiResponse.ok) {
      const errorText = await geminiResponse.text();
      console.error('Gemini API Error:', errorText);
      throw new Error(`Gemini API request failed: ${geminiResponse.statusText}`);
    }

    const geminiData = await geminiResponse.json();
    
    if (!geminiData.candidates || !geminiData.candidates[0] || !geminiData.candidates[0].content) {
      throw new Error('Invalid response from Gemini API');
    }

    const generatedText = geminiData.candidates[0].content.parts[0].text;
    
    // Extract JSON from response
    let assessmentData;
    try {
      const jsonMatch = generatedText.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        assessmentData = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error('No JSON found in response');
      }
    } catch (parseError) {
      console.error('Failed to parse Gemini response as JSON:', parseError);
      throw new Error('Failed to parse task assessment from Gemini');
    }

    // Get user ID from auth if available
    let userId = null;
    try {
      const authHeader = req.headers.get('Authorization');
      if (authHeader && authHeader.startsWith('Bearer ')) {
        const token = authHeader.substring(7);
        const { data: { user } } = await supabase.auth.getUser(token);
        userId = user?.id;
      }
    } catch (authError) {
      console.error('Auth error:', authError);
    }

    // Store assessment in Supabase if user is authenticated
    if (userId) {
      const { error: insertError } = await supabase
        .from('ai_task_assessments')
        .insert({
          user_id: userId,
          occupation_code: 'custom',
          occupation_title: occupationContext || 'Custom Task',
          task_description: taskDescription,
          category: assessmentData.category,
          explanation: assessmentData.explanation,
          confidence: assessmentData.confidence
        });

      if (insertError) {
        console.error('Error storing task assessment:', insertError);
      }
    }

    return new Response(JSON.stringify(assessmentData), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  } catch (error) {
    console.error('Error in assess-task function:', error);
    return new Response(JSON.stringify({ 
      error: error.message,
      timestamp: new Date().toISOString(),
      function: 'assess-task'
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

const GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY');

serve(async (req) => {
  // Pre-flight
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    if (!GEMINI_API_KEY) {
      throw new Error('Gemini API key not configured');
    }

    const { prompt, generationConfig } = await req.json();
    if (!prompt) throw new Error('Prompt is required');

    const started = Date.now();

    // Call Gemini 2.5 Flash
    const geminiResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{ parts: [{ text: prompt }] }],
        generationConfig: generationConfig ?? {
          temperature: 0.2,
          topK: 1,
          topP: 0.8,
          maxOutputTokens: 4096,
        },
      }),
    });

    if (!geminiResponse.ok) {
      const errorText = await geminiResponse.text();
      throw new Error(`Gemini error: ${geminiResponse.statusText}. ${errorText}`);
    }

    const { candidates, usageMetadata } = await geminiResponse.json();
    if (!candidates?.length) throw new Error('Empty Gemini response');

    const text = candidates[0]?.content?.parts?.[0]?.text ?? '';

    const latency = Date.now() - started;

    // Log to Supabase
    const supabaseUrl = Deno.env.get('SUPABASE_URL') || '';
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || '';
    const supabase = createClient(supabaseUrl, supabaseKey);

    await supabase.from('llm_logs').insert({
      prompt,
      response: text,
      tokens_used: usageMetadata?.totalTokens ?? null,
      latency_ms: latency,
    });

    return new Response(JSON.stringify({ text, usageMetadata, latency_ms: latency }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  } catch (error) {
    console.error('gemini-generate error:', error);
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { z } from "https://esm.sh/zod@3.22.4";
import { searchCourses } from "../../lib/SerpApiClient.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

const requestSchema = z.object({
  skill: z.string().min(2),
  limit: z.number().min(1).max(10).optional().default(5),
});

export async function handler(req: Request) {
  if (req.method === "OPTIONS") return new Response(null, { headers: corsHeaders });
  try {
    const { skill, limit } = requestSchema.parse(await req.json());
    const results = await searchCourses(`${skill} free course`, limit);
    return new Response(JSON.stringify({ results }), { headers: { ...corsHeaders, "Content-Type": "application/json" } });
  } catch (error) {
    console.error(error);
    return new Response(JSON.stringify({ error: error.message }), { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } });
  }
}

if (import.meta.main) {
  serve(handler);
}
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { z } from "https://esm.sh/zod@3.22.4";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { GeminiClient } from "../../lib/GeminiClient.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
};

// ---------- Schema Definitions ----------
const messageSchema = z.object({
  role: z.enum(["user", "assistant"]).default("user"),
  content: z.string().min(1).max(2000),
});

const requestSchema = z.object({
  message: z.string().min(1).max(2000),
  conversationHistory: z.array(messageSchema).max(20).optional().default([]),
  userProfile: z
    .object({
      id: z.string().uuid(),
      occupationCode: z.string().optional(),
      careerGoals: z.string().optional(),
    })
    .optional(),
});



export async function handler(req: Request) {
  const gemini = new GeminiClient();
  // Handle CORS pre-flight
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  const started = Date.now();

  try {
    const json = await req.json();
    const { message, conversationHistory, userProfile } = requestSchema.parse(
      json
    )

    // Construct prompt
    const promptParts = [
      "You are an AI Career Coach specialising in automation potential and future-of-work analysis.",
      userProfile
        ? `User occupation: ${userProfile.occupationCode}\nGoals: ${userProfile.careerGoals}`
        : "",
      "Conversation history:\n" +
        conversationHistory
          .map((m) => `${m.role === "user" ? "User" : "Coach"}: ${m.content}`)
          .join("\n"),
      `User: ${message}`,
      "Coach:",
    ].join("\n\n");

    const { text, usageMetadata } = await gemini.generateContent(promptParts);

    // Persist log
    const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";
    const supabase = createClient(supabaseUrl, supabaseKey);
    const userId = userProfile?.id ?? null;

    await supabase.from("llm_logs").insert({
      user_id: userId,
      prompt: promptParts,
      response: text,
      tokens_used: usageMetadata?.totalTokens ?? null,
      latency_ms: Date.now() - started,
    });

    const responseBody = {
      response: text,
      followUpQuestions: [], // future enhancement
      actionItems: [], // future enhancement
      usage: usageMetadata,
    };

    return new Response(JSON.stringify(responseBody), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error("ai-career-coach error:", error);
    return new Response(JSON.stringify({ error: error.message }), {
      status: 400,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }
}

if (import.meta.main) {
  serve(handler);
}

import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface LearningPathRequest {
  userSkills: Array<{
    name: string;
    currentLevel: number;
    targetLevel: number;
    category: string;
  }>;
  targetRole: string;
  currentRole: string;
  timeCommitment: string; // hours per week
  learningStyle: string;
  budget: string;
}

interface Milestone {
  id: string;
  title: string;
  description: string;
  targetDate: string;
  completed: boolean;
  skills: string[];
}

interface LearningPath {
  id: string;
  name: string;
  description: string;
  skills: string[];
  estimatedDuration: string;
  milestones: Milestone[];
  difficulty: string;
  prerequisites: string[];
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { userSkills, targetRole, currentRole, timeCommitment, learningStyle, budget }: LearningPathRequest = await req.json();
    
    console.log('Received request:', { userSkills, targetRole, currentRole, timeCommitment, learningStyle, budget });

    // Check if we have the required API key
    const openAIApiKey = Deno.env.get('OPENAI_API_KEY');
    if (!openAIApiKey) {
      console.error('OpenAI API key not found - generating fallback learning path');
      
      // Generate fallback learning path without API call
      const fallbackPath = createFallbackLearningPath(
        userSkills.filter(skill => skill.targetLevel > skill.currentLevel), 
        targetRole, 
        timeCommitment
      );
      
      return new Response(JSON.stringify({
        learningPath: fallbackPath,
        generatedAt: new Date().toISOString(),
        metadata: {
          skillGapsAddressed: userSkills.filter(skill => skill.targetLevel > skill.currentLevel).length,
          estimatedWeeksToComplete: calculateWeeksToComplete(fallbackPath.estimatedDuration, timeCommitment),
          note: 'Generated using fallback method due to API configuration'
        }
      }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const skillGaps = userSkills.filter(skill => skill.targetLevel > skill.currentLevel);
    
    console.log('Skill gaps identified:', skillGaps);
    
    const prompt = `
As an AI career development expert, create a personalized learning path for the following scenario:

Current Role: ${currentRole}
Target Role: ${targetRole}
Time Commitment: ${timeCommitment} hours per week
Learning Style: ${learningStyle}
Budget: ${budget}

Skill Gaps to Address:
${skillGaps.map(skill => `- ${skill.name}: Current Level ${skill.currentLevel} → Target Level ${skill.targetLevel} (Category: ${skill.category})`).join('\n')}

Please create a comprehensive learning path that includes:
1. A clear path name and description
2. Logical skill progression order
3. Realistic milestones with target dates (considering the time commitment)
4. Estimated total duration
5. Prerequisites for each phase

Format your response as a JSON object with this structure:
{
  "name": "Path name",
  "description": "Detailed description",
  "skills": ["skill1", "skill2"],
  "estimatedDuration": "X months",
  "difficulty": "Beginner/Intermediate/Advanced",
  "prerequisites": ["prerequisite1"],
  "milestones": [
    {
      "title": "Milestone title",
      "description": "What to achieve",
      "targetDate": "YYYY-MM-DD",
      "skills": ["related skills"],
      "completed": false
    }
  ]
}

Make the path practical, achievable, and tailored to their specific needs. Consider industry standards and typical career progression patterns.
`;

    console.log('Sending request to OpenAI...');

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${openAIApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [
          { 
            role: 'system', 
            content: 'You are an expert career development AI that creates personalized learning paths. Always respond with valid JSON only.' 
          },
          { role: 'user', content: prompt }
        ],
        temperature: 0.7,
        max_tokens: 2000,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('OpenAI API error:', response.status, errorText);
      throw new Error(`OpenAI API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    console.log('OpenAI response received');
    
    const generatedContent = data.choices[0].message.content;
    console.log('Generated content:', generatedContent);

    // Parse the JSON response
    let learningPath: LearningPath;
    try {
      const parsedPath = JSON.parse(generatedContent);
      
      // Add missing fields and ensure proper structure
      learningPath = {
        id: `path_${Date.now()}`,
        name: parsedPath.name || `${targetRole} Learning Path`,
        description: parsedPath.description || 'Personalized learning path generated by AI',
        skills: parsedPath.skills || skillGaps.map(s => s.name),
        estimatedDuration: parsedPath.estimatedDuration || '6 months',
        difficulty: parsedPath.difficulty || 'Intermediate',
        prerequisites: parsedPath.prerequisites || [],
        milestones: (parsedPath.milestones || []).map((milestone: any, index: number) => ({
          id: `milestone_${Date.now()}_${index}`,
          title: milestone.title || `Milestone ${index + 1}`,
          description: milestone.description || 'Complete learning objectives',
          targetDate: milestone.targetDate || getTargetDate(index + 1, timeCommitment),
          completed: false,
          skills: milestone.skills || []
        }))
      };
    } catch (parseError) {
      console.error('Failed to parse AI response:', parseError);
      console.error('Raw response:', generatedContent);
      
      // Fallback learning path
      learningPath = createFallbackLearningPath(skillGaps, targetRole, timeCommitment);
    }

    console.log('Final learning path:', learningPath);

    return new Response(JSON.stringify({
      learningPath,
      generatedAt: new Date().toISOString(),
      metadata: {
        skillGapsAddressed: skillGaps.length,
        estimatedWeeksToComplete: calculateWeeksToComplete(learningPath.estimatedDuration, timeCommitment)
      }
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });

  } catch (error) {
    console.error('Error generating learning path:', error);
    return new Response(JSON.stringify({ 
      error: error instanceof Error ? error.message : 'Unknown error',
      learningPath: null
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});

function getTargetDate(milestoneNumber: number, timeCommitment: string): string {
  const weeksPerMilestone = getWeeksPerMilestone(timeCommitment);
  const targetDate = new Date();
  targetDate.setDate(targetDate.getDate() + (milestoneNumber * weeksPerMilestone * 7));
  return targetDate.toISOString().split('T')[0];
}

function getWeeksPerMilestone(timeCommitment: string): number {
  const hours = parseInt(timeCommitment) || 5;
  if (hours >= 20) return 2; // Full-time learning
  if (hours >= 10) return 3; // Part-time intensive
  if (hours >= 5) return 4;  // Regular part-time
  return 6; // Casual learning
}

function calculateWeeksToComplete(duration: string, timeCommitment: string): number {
  const months = parseInt(duration) || 6;
  const hours = parseInt(timeCommitment) || 5;
  
  // Rough calculation based on time commitment
  const baseWeeks = months * 4;
  if (hours >= 20) return Math.floor(baseWeeks * 0.5);
  if (hours >= 10) return Math.floor(baseWeeks * 0.75);
  return baseWeeks;
}

function createFallbackLearningPath(skillGaps: any[], targetRole: string, timeCommitment: string): LearningPath {
  const milestones: Milestone[] = skillGaps.map((skill, index) => ({
    id: `milestone_${Date.now()}_${index}`,
    title: `Master ${skill.name}`,
    description: `Develop ${skill.name} skills from level ${skill.currentLevel} to ${skill.targetLevel}`,
    targetDate: getTargetDate(index + 1, timeCommitment),
    completed: false,
    skills: [skill.name]
  }));

  return {
    id: `path_${Date.now()}`,
    name: `${targetRole} Career Development Path`,
    description: `A structured learning path to transition from your current role to ${targetRole}, focusing on closing key skill gaps.`,
    skills: skillGaps.map(s => s.name),
    estimatedDuration: `${Math.max(3, skillGaps.length * 2)} months`,
    difficulty: 'Intermediate',
    prerequisites: ['Basic understanding of relevant domain'],
    milestones
  };
}
// Supabase Edge Function: /crosswalk
// Fetches crosswalk mappings (MOC, CIP, RAPIDS, ESCO, DOT, SOC) from O*NET Web Services.
// Usage: GET /functions/v1/crosswalk?from=moc&code=11B
// Optional: ?to=soc (to filter target codes, otherwise returns the full mapping response)
//
// Environment: expects ONET_USERNAME / ONET_PASSWORD (or ONET_API_KEY) to be stored
//              as Supabase secrets. This function simply forwards the request to the
//              public O*NET Web-Services endpoint using basic auth and caches the
//              response for 5 minutes.

import { serve } from "https://deno.land/std@0.192.0/http/server.ts";

const USERNAME = Deno.env.get("ONET_USERNAME");
const PASSWORD = Deno.env.get("ONET_PASSWORD");
const API_KEY = Deno.env.get("ONET_API_KEY");

if (!((USERNAME && PASSWORD) || API_KEY)) {
  console.error("O*NET credentials not found in environment variables");
}

function buildAuthHeaders(): HeadersInit {
  if (API_KEY) {
    return { Authorization: `Token ${API_KEY}` };
  }
  if (USERNAME && PASSWORD) {
    const b64 = btoa(`${USERNAME}:${PASSWORD}`);
    return { Authorization: `Basic ${b64}` };
  }
  return {};
}

serve(async (req: Request): Promise<Response> => {
  try {
    if (req.method !== "GET") {
      return new Response("Method Not Allowed", { status: 405 });
    }

    const url = new URL(req.url);
    const from = url.searchParams.get("from");
    const code = url.searchParams.get("code");
    const to = url.searchParams.get("to");

    if (!from || !code) {
      return new Response("Missing required parameters: from, code", {
        status: 400,
      });
    }

    // Construct O*NET Web-Services path.
    // Docs: https://services.onetcenter.org/reference/
    // Example: /online/crosswalk?identifier=11B&codes=MOC&to=SOC
    const qs = new URLSearchParams({ identifier: code, codes: from.toUpperCase() });
    if (to) qs.set("to", to.toUpperCase());
    const onetUrl = `https://services.onetcenter.org/online/crosswalk?${qs.toString()}`;

    const res = await fetch(onetUrl, {
      headers: {
        ...buildAuthHeaders(),
        Accept: "application/json",
      },
    });

    return new Response(res.body, {
      status: res.status,
      headers: {
        "Content-Type": res.headers.get("Content-Type") || "application/json",
        "Cache-Control": "public, max-age=300", // 5-minute cache
      },
    });
  } catch (err) {
    console.error("/crosswalk error", err);
    return new Response("Internal Error", { status: 500 });
  }
});
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { z } from "https://esm.sh/zod@3.22.4";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { GeminiClient } from "../../lib/GeminiClient.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
};

// --------- Schema ---------
const requestSchema = z.object({
  occupationCode: z.string(),
  occupationTitle: z.string(),
  tasks: z.array(z.string().min(3)).min(1).max(50),
  userId: z.string().uuid(),
});

const gemini = new GeminiClient();

interface AssessmentResult {
  task: string;
  category: "Automate" | "Augment" | "Human-only";
  explanation: string;
  confidence: number;
}

export async function handler(req: Request) {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  const started = Date.now();

  try {
    const body = await req.json();
    const { occupationCode, occupationTitle, tasks, userId } = requestSchema.parse(
      body,
    );

    const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";
    const supabase = createClient(supabaseUrl, supabaseKey);

    const assessments: AssessmentResult[] = [];

    // Prompt template
    const template = (
      t: string,
    ) => `You are an AI work-task assessor. Categorise the task below for automation potential using exactly one of the categories: Automate, Augment, Human-only. Provide a short justification and a confidence score (0-1). Return JSON with keys: category, explanation, confidence.\n\nTask: ${t}`;

    for (const task of tasks) {
      const { text } = await gemini.generateContent(template(task));
      // naive JSON parse fallback
      let parsed: AssessmentResult | null = null;
      try {
        parsed = JSON.parse(text);
      } catch {
        // attempt regex extraction
        const match = text.match(/\{[\s\S]*\}/);
        if (match) {
          parsed = JSON.parse(match[0]);
        }
      }
      if (!parsed) {
        parsed = {
          task,
          category: "Human-only",
          explanation: "Unable to parse model response",
          confidence: 0.3,
        };
      } else {
        parsed.task = task;
      }
      assessments.push(parsed);
    }

    // Insert into DB
    const rows = assessments.map((a) => ({
      user_id: userId,
      occupation_code: occupationCode,
      occupation_title: occupationTitle,
      task_description: a.task,
      category: a.category,
      explanation: a.explanation,
      confidence: a.confidence,
    }));

    await supabase.from("ai_task_assessments").insert(rows);

    const latency = Date.now() - started;

    return new Response(
      JSON.stringify({ assessments, latency_ms: latency }),
      { headers: { ...corsHeaders, "Content-Type": "application/json" } },
    );
  } catch (error) {
    console.error("intelligent-task-assessment error:", error);
    return new Response(JSON.stringify({ error: error.message }), {
      status: 400,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }
}

if (import.meta.main) {
  serve(handler);
}
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

// Base URL for O*NET Web Services
const ONET_BASE_URL = "https://services.onetcenter.org/ws/online";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

function getAuthHeader() {
  const user = Deno.env.get("ONET_USERNAME");
  const pass = Deno.env.get("ONET_PASSWORD");
  if (!user || !pass) {
    throw new Error("Missing ONET_USERNAME/ONET_PASSWORD in environment");
  }
  const basic = btoa(`${user}:${pass}`);
  return `Basic ${basic}`;
}

export async function handler(req: Request): Promise<Response> {
  // CORS preflight
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    // Accept both GET (?path=...) and POST ({ onetPath | path })
    let onetPath = "";
    const url = new URL(req.url);
    const qp = url.searchParams.get("path");
    if (qp) {
      onetPath = qp;
    } else if (req.method === "POST") {
      const body = await req.json().catch(() => ({}));
      onetPath = body.onetPath || body.path || "";
    }

    if (!onetPath || typeof onetPath !== "string") {
      return new Response(JSON.stringify({ error: "Missing O*NET path" }), {
        status: 400,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    // Normalize: remove any leading slash
    if (onetPath.startsWith("/")) onetPath = onetPath.slice(1);

    const authHeader = getAuthHeader();
    const target = `${ONET_BASE_URL}/${onetPath}`;
    console.log(`[onet-proxy] -> ${target}`);

    const response = await fetch(target, {
      headers: {
        Authorization: authHeader,
        Accept: "application/json",
      },
    });

    const ct = response.headers.get("content-type") || "";
    const ok = response.ok;
    if (!ok) {
      const errText = await response.text();
      console.error("O*NET API Error", response.status, errText);
      return new Response(JSON.stringify({ error: errText || response.statusText }), {
        status: 502,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    if (ct.includes("application/json")) {
      const json = await response.json();
      return new Response(JSON.stringify(json), {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }
    const text = await response.text();
    return new Response(text, { headers: { ...corsHeaders, "Content-Type": ct || "text/plain" } });
  } catch (error) {
    console.error("Error in onet-proxy function:", error);
    return new Response(JSON.stringify({ error: error.message || String(error) }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }
}

if (import.meta.main) {
  serve(handler);
}
import type { Config } from "tailwindcss";

export default {
	darkMode: ["class"],
	content: [
		"./pages/**/*.{ts,tsx}",
		"./components/**/*.{ts,tsx}",
		"./app/**/*.{ts,tsx}",
		"./src/**/*.{ts,tsx}",
	],
	prefix: "",
	theme: {
		container: {
			center: true,
			padding: '2rem',
			screens: {
				'2xl': '1400px'
			}
		},
		extend: {
			colors: {
				border: 'hsl(var(--border))',
				input: 'hsl(var(--input))',
				ring: 'hsl(var(--ring))',
				background: 'hsl(var(--background))',
				foreground: 'hsl(var(--foreground))',
				primary: {
					DEFAULT: 'hsl(var(--primary))',
					foreground: 'hsl(var(--primary-foreground))'
				},
				secondary: {
					DEFAULT: 'hsl(var(--secondary))',
					foreground: 'hsl(var(--secondary-foreground))'
				},
				destructive: {
					DEFAULT: 'hsl(var(--destructive))',
					foreground: 'hsl(var(--destructive-foreground))'
				},
				muted: {
					DEFAULT: 'hsl(var(--muted))',
					foreground: 'hsl(var(--muted-foreground))'
				},
				accent: {
					DEFAULT: 'hsl(var(--accent))',
					foreground: 'hsl(var(--accent-foreground))'
				},
				popover: {
					DEFAULT: 'hsl(var(--popover))',
					foreground: 'hsl(var(--popover-foreground))'
				},
				card: {
					DEFAULT: 'hsl(var(--card))',
					foreground: 'hsl(var(--card-foreground))'
				},
				sidebar: {
					DEFAULT: 'hsl(var(--sidebar-background))',
					foreground: 'hsl(var(--sidebar-foreground))',
					primary: 'hsl(var(--sidebar-primary))',
					'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
					accent: 'hsl(var(--sidebar-accent))',
					'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
					border: 'hsl(var(--sidebar-border))',
					ring: 'hsl(var(--sidebar-ring))'
				}
			},
			borderRadius: {
				lg: 'var(--radius)',
				md: 'calc(var(--radius) - 2px)',
				sm: 'calc(var(--radius) - 4px)'
			},
			keyframes: {
				'accordion-down': {
					from: {
						height: '0'
					},
					to: {
						height: 'var(--radix-accordion-content-height)'
					}
				},
				'accordion-up': {
					from: {
						height: 'var(--radix-accordion-content-height)'
					},
					to: {
						height: '0'
					}
				}
			},
			animation: {
				'accordion-down': 'accordion-down 0.2s ease-out',
				'accordion-up': 'accordion-up 0.2s ease-out'
			}
		}
	},
	plugins: [require("tailwindcss-animate")],
} satisfies Config;
// Netlify Function: onet-proxy
// Load local .env when running via Netlify Dev
import 'dotenv/config';
// Proxies O*NET Web Services with Basic Auth using Netlify environment variables
// GET:  /.netlify/functions/onet-proxy?path=search?keyword=developer&end=10
// POST: /.netlify/functions/onet-proxy  { path: "search?keyword=..." }

const ONET_BASE_URL = "https://services.onetcenter.org/ws/online";

const corsHeaders: Record<string, string> = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
};

function getAuthHeader() {
  const user = process.env.ONET_USERNAME;
  const pass = process.env.ONET_PASSWORD;
  if (!user || !pass) throw new Error("Missing ONET_USERNAME/ONET_PASSWORD env vars");
  const basic = Buffer.from(`${user}:${pass}`).toString("base64");
  return `Basic ${basic}`;
}

export const handler = async (event: any) => {
  const start = Date.now();
  const method = event.httpMethod;
  try {
    console.log("[onet-proxy] incoming", {
      method,
      hasUser: !!process.env.ONET_USERNAME,
      hasPass: !!process.env.ONET_PASSWORD,
    });
  } catch {}
  if (event.httpMethod === "OPTIONS") {
    return { statusCode: 204, headers: corsHeaders, body: "" };
  }

  try {
    let onetPath = "";
    const qp = event.queryStringParameters?.path;
    if (qp) onetPath = qp;
    else if (event.httpMethod === "POST" && event.body) {
      const body = JSON.parse(event.body || "{}");
      onetPath = body.onetPath || body.path || "";
    }

    if (!onetPath || typeof onetPath !== "string") {
      return {
        statusCode: 400,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        body: JSON.stringify({ error: "Missing O*NET path" }),
      };
    }

    // Decode if URL-encoded
    const beforeDecode = onetPath;
    try {
      onetPath = decodeURIComponent(onetPath);
    } catch {}
    if (onetPath.startsWith("/")) onetPath = onetPath.slice(1);
    try {
      console.log("[onet-proxy] path", { beforeDecode, afterDecode: onetPath });
    } catch {}

    // Ensure JSON response from O*NET when possible
    if (!/[?&]fmt=/.test(onetPath)) {
      onetPath += (onetPath.includes("?") ? "&" : "?") + "fmt=json";
    }

    const target = `${ONET_BASE_URL}/${onetPath}`;
    const authHeader = getAuthHeader();

    try {
      console.log("[onet-proxy] outbound", { target, node: process.version });
    } catch {}

    const resp = await fetch(target, {
      headers: {
        Authorization: authHeader,
        Accept: "application/json",
      },
    });

    const ct = resp.headers.get("content-type") || "";
    const text = await resp.text();

    try {
      console.log("[onet-proxy] upstream", {
        status: resp.status,
        contentType: ct,
        bytes: text.length,
        ms: Date.now() - start,
      });
    } catch {}

    if (!resp.ok) {
      return {
        statusCode: 502,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        body: JSON.stringify({ error: text || resp.statusText }),
      };
    }

    // Normalize any vendor JSON to application/json for the client
    if (ct.toLowerCase().includes("json")) {
      return {
        statusCode: 200,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        body: text,
      };
    }

    return {
      statusCode: 200,
      headers: { ...corsHeaders, "Content-Type": ct || "text/plain" },
      body: text,
    };
  } catch (err: any) {
    return {
      statusCode: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
      body: JSON.stringify({ error: err?.message || String(err) }),
    };
  }
};
{
  "name": "vite_react_shadcn_ts",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:dev": "vite build --mode development",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.9.0",
    "@radix-ui/react-accordion": "^1.2.0",
    "@radix-ui/react-alert-dialog": "^1.1.1",
    "@radix-ui/react-aspect-ratio": "^1.1.0",
    "@radix-ui/react-avatar": "^1.1.0",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-collapsible": "^1.1.0",
    "@radix-ui/react-context-menu": "^2.2.1",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-hover-card": "^1.1.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-menubar": "^1.1.1",
    "@radix-ui/react-navigation-menu": "^1.2.0",
    "@radix-ui/react-popover": "^1.1.1",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-radio-group": "^1.2.0",
    "@radix-ui/react-scroll-area": "^1.1.0",
    "@radix-ui/react-select": "^2.1.1",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slider": "^1.2.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.0",
    "@radix-ui/react-tabs": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.1",
    "@radix-ui/react-toggle": "^1.1.0",
    "@radix-ui/react-toggle-group": "^1.1.0",
    "@radix-ui/react-tooltip": "^1.1.4",
    "@supabase/supabase-js": "^2.50.0",
    "@tanstack/react-query": "^5.56.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.0",
    "date-fns": "^3.6.0",
    "embla-carousel-react": "^8.3.0",
    "framer-motion": "^12.18.1",
    "input-otp": "^1.2.4",
    "lucide-react": "^0.462.0",
    "netlify-cli": "^22.2.1",
    "next-themes": "^0.3.0",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.53.0",
    "react-resizable-panels": "^2.1.3",
    "react-router-dom": "^6.26.2",
    "recharts": "^2.15.3",
    "sonner": "^1.5.0",
    "tailwind-merge": "^2.5.2",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^0.9.3",
    "web-vitals": "^5.0.3",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.0",
    "@tailwindcss/typography": "^0.5.15",
    "@types/node": "^22.5.5",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react-swc": "^3.5.0",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.9.0",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.9",
    "globals": "^15.9.0",
    "lovable-tagger": "^1.1.7",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.11",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.0.1",
    "vite": "^5.4.1"
  }
}
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/index.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "noImplicitAny": false,
    "noUnusedParameters": false,
    "skipLibCheck": true,
    "allowJs": true,
    "noUnusedLocals": false,
    "strictNullChecks": false
  }
}
import js from "@eslint/js";
import globals from "globals";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import tseslint from "typescript-eslint";

export default tseslint.config(
  { ignores: ["dist"] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ["**/*.{ts,tsx}"],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      "react-hooks": reactHooks,
      "react-refresh": reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      "react-refresh/only-export-components": [
        "warn",
        { allowConstantExport: true },
      ],
      "@typescript-eslint/no-unused-vars": "off",
    },
  }
);
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";
import path from "path";
import { componentTagger } from "lovable-tagger";

// https://vitejs.dev/config/
export default defineConfig(({ mode }) => ({
  server: {
    host: "::",
    port: 8080,
  },
  plugins: [
    react(),
    mode === 'development' &&
    componentTagger(),
  ].filter(Boolean),
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
}));
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
// Utility to report web-vitals to analytics or logging endpoint
import { ReportHandler } from 'web-vitals';
import { supabase } from '@/integrations/supabase/client';

export function reportWebVitals(onPerfEntry?: ReportHandler) {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then((mod) => {
      const getCLS = mod.getCLS || (mod.default && mod.default.getCLS);
      const getFID = mod.getFID || (mod.default && mod.default.getFID);
      const getFCP = mod.getFCP || (mod.default && mod.default.getFCP);
      const getLCP = mod.getLCP || (mod.default && mod.default.getLCP);
      const getTTFB = mod.getTTFB || (mod.default && mod.default.getTTFB);
      if (getCLS && getFID && getFCP && getLCP && getTTFB) {
        getCLS(onPerfEntry);
        getFID(onPerfEntry);
        getFCP(onPerfEntry);
        getLCP(onPerfEntry);
        getTTFB(onPerfEntry);
      } else {
        console.warn('web-vitals functions not found. Please check your web-vitals package version.');
      }
    }).catch((err) => {
      console.error('Failed to load web-vitals:', err);
    });
  }
}

// Send metrics to Supabase web_vitals table
export const persistWebVitals: ReportHandler = async (metric) => {
  try {
    const session = await supabase.auth.getSession();
    const userId = session.data.session?.user?.id ?? null;
    const navigationType = (performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming | undefined)?.type;
    const { error } = await supabase.from('web_vitals').insert({
      user_id: userId,
      name: metric.name,
      value: Number(metric.value.toFixed(3)),
      delta: Number(metric.delta?.toFixed(3) ?? 0),
      idempotency_key: metric.id,
      navigation_type: navigationType,
      url: window.location.href,
      user_agent: navigator.userAgent,
    });
    if (error) {
      // Non-fatal; log to console only
      console.warn('[WebVitals] insert error', error.message);
    }
  } catch (e) {
    console.warn('[WebVitals] persist error', e);
  }
};

/**
 * Input sanitization utilities to prevent XSS and injection attacks
 */

export const sanitizeSearchInput = (input: string): string => {
  if (!input || typeof input !== 'string') return '';
  
  // Remove HTML tags and scripts
  const htmlStripped = input.replace(/<[^>]*>/g, '');
  
  // Remove potentially dangerous characters
  const sanitized = htmlStripped
    .replace(/[<>'"&]/g, (char) => {
      const entities: { [key: string]: string } = {
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '&': '&amp;'
      };
      return entities[char] || char;
    })
    .trim();
  
  // Limit length to prevent DoS
  return sanitized.substring(0, 500);
};

export const sanitizeOccupationCode = (code: string): string => {
  if (!code || typeof code !== 'string') return '';
  
  // O*NET codes should follow pattern: XX-XXXX.XX
  const codePattern = /^[\d\-\.]+$/;
  const cleanCode = code.trim().replace(/[^0-9\-\.]/g, '');
  
  if (!codePattern.test(cleanCode)) {
    throw new Error('Invalid occupation code format');
  }
  
  return cleanCode.substring(0, 20); // Reasonable limit
};

export const validateEmail = (email: string): boolean => {
  const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailPattern.test(email) && email.length <= 254;
};

export const sanitizeUserInput = (input: string): string => {
  if (!input || typeof input !== 'string') return '';
  
  return input
    .trim()
    .replace(/[<>'"&]/g, (char) => {
      const entities: { [key: string]: string } = {
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '&': '&amp;'
      };
      return entities[char] || char;
    })
    .substring(0, 1000);
};

import { SelectedOccupation } from "@/components/APODashboard";

export const exportToCSV = (occupations: SelectedOccupation[]) => {
  if (!occupations.length) return;
  const fields = [
    "Code", "Title", "Overall APO (%)", "Confidence", "Timeline",
    "Tasks APO", "Knowledge APO", "Skills APO", "Abilities APO", "Technologies APO"
  ];
  let csv = fields.join(",") + "\n";
  for (const occ of occupations) {
    csv += [
      `"${occ.code}"`,
      `"${occ.title.replace(/"/g, '""')}"`,
      `${occ.overallAPO?.toFixed(1) ?? ""}`,
      `"${occ.confidence}"`,
      `"${occ.timeline}"`,
      `${occ.categoryBreakdown?.tasks?.apo?.toFixed(1) ?? ""}`,
      `${occ.categoryBreakdown?.knowledge?.apo?.toFixed(1) ?? ""}`,
      `${occ.categoryBreakdown?.skills?.apo?.toFixed(1) ?? ""}`,
      `${occ.categoryBreakdown?.abilities?.apo?.toFixed(1) ?? ""}`,
      `${occ.categoryBreakdown?.technologies?.apo?.toFixed(1) ?? ""}`,
    ].join(",") + "\n";
  }
  const blob = new Blob([csv], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "APO_Career_Export.csv";
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    URL.revokeObjectURL(url);
    document.body.removeChild(a);
  }, 100);
};

export interface APIError {
  code: string;
  message: string;
  details?: any;
  timestamp: string;
}

export class APIErrorHandler {
  static handle(error: any): APIError {
    const timestamp = new Date().toISOString();
    
    // Supabase errors
    if (error?.error?.message) {
      return {
        code: error.error.code || 'SUPABASE_ERROR',
        message: error.error.message,
        details: error.error,
        timestamp
      };
    }

    // Network errors
    if (!navigator.onLine) {
      return {
        code: 'NETWORK_ERROR',
        message: 'No internet connection. Please check your network and try again.',
        timestamp
      };
    }

    // Rate limit errors
    if (error?.status === 429) {
      return {
        code: 'RATE_LIMIT_EXCEEDED',
        message: 'Too many requests. Please wait a moment before trying again.',
        timestamp
      };
    }

    // Authentication errors
    if (error?.status === 401) {
      return {
        code: 'UNAUTHORIZED',
        message: 'Please sign in to continue.',
        timestamp
      };
    }

    // Server errors
    if (error?.status >= 500) {
      return {
        code: 'SERVER_ERROR',
        message: 'Server temporarily unavailable. Please try again later.',
        timestamp
      };
    }

    // Generic error
    return {
      code: 'UNKNOWN_ERROR',
      message: error?.message || 'An unexpected error occurred. Please try again.',
      details: error,
      timestamp
    };
  }

  static getRetryDelay(attempt: number): number {
    // Exponential backoff: 1s, 2s, 4s, 8s, 16s
    return Math.min(1000 * Math.pow(2, attempt), 16000);
  }

  static shouldRetry(error: APIError, attempt: number): boolean {
    if (attempt >= 3) return false;
    
    // Don't retry client errors (4xx)
    if (['UNAUTHORIZED', 'RATE_LIMIT_EXCEEDED'].includes(error.code)) {
      return false;
    }

    // Retry server errors and network errors
    return ['SERVER_ERROR', 'NETWORK_ERROR', 'UNKNOWN_ERROR'].includes(error.code);
  }

  static logError(error: APIError, context?: string): void {
    console.error(`[API Error${context ? ` - ${context}` : ''}]:`, {
      code: error.code,
      message: error.message,
      timestamp: error.timestamp,
      details: error.details
    });

    // In production, send to error tracking service
    if (process.env.NODE_ENV === 'production') {
      // Example: Sentry.captureException(error);
    }
  }
}

export async function withRetry<T>(
  operation: () => Promise<T>,
  context?: string,
  maxAttempts: number = 3
): Promise<T> {
  let lastError: APIError;
  
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = APIErrorHandler.handle(error);
      APIErrorHandler.logError(lastError, context);
      
      if (!APIErrorHandler.shouldRetry(lastError, attempt)) {
        throw lastError;
      }
      
      if (attempt < maxAttempts - 1) {
        const delay = APIErrorHandler.getRetryDelay(attempt);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  throw lastError!;
}

import { z } from 'zod';

// Enhanced input validation schemas
export const occupationSearchSchema = z.object({
  searchTerm: z.string()
    .min(1, 'Search term is required')
    .max(100, 'Search term too long')
    .regex(/^[a-zA-Z0-9\s\-\.\/]+$/, 'Invalid characters in search term')
    .transform(str => str.trim()),
  
  filters: z.object({
    categories: z.array(z.string()).optional(),
    experienceLevel: z.enum(['entry', 'mid', 'senior', 'executive']).optional(),
    location: z.string().max(50).optional(),
    salaryRange: z.object({
      min: z.number().min(0).optional(),
      max: z.number().min(0).optional()
    }).optional()
  }).optional()
});

export const occupationCodeSchema = z.string()
  .regex(/^\d{2}-\d{4}\.\d{2}$/, 'Invalid O*NET occupation code format')
  .max(10);

export const userProfileSchema = z.object({
  fullName: z.string()
    .min(1, 'Name is required')
    .max(100, 'Name too long')
    .regex(/^[a-zA-Z\s\-\'\.]+$/, 'Name contains invalid characters'),
  
  email: z.string()
    .email('Invalid email format')
    .max(254, 'Email too long'),
  
  preferences: z.object({
    theme: z.enum(['light', 'dark', 'system']).optional(),
    emailNotifications: z.boolean().optional(),
    autoSaveAnalyses: z.boolean().optional(),
    defaultExportFormat: z.enum(['csv', 'pdf', 'json']).optional()
  }).optional()
});

export const analysisNotesSchema = z.object({
  notes: z.string()
    .max(1000, 'Notes too long')
    .optional(),
  
  tags: z.array(z.string()
    .min(1, 'Tag cannot be empty')
    .max(20, 'Tag too long')
    .regex(/^[a-zA-Z0-9\-_]+$/, 'Tag contains invalid characters')
  ).max(10, 'Too many tags').optional()
});

// Security validation functions
export function validateAndSanitizeInput<T>(
  input: unknown,
  schema: z.ZodSchema<T>
): { success: true; data: T } | { success: false; errors: string[] } {
  try {
    const result = schema.parse(input);
    return { success: true, data: result };
  } catch (error) {
    if (error instanceof z.ZodError) {
      return {
        success: false,
        errors: error.errors.map(err => `${err.path.join('.')}: ${err.message}`)
      };
    }
    return {
      success: false,
      errors: ['Invalid input format']
    };
  }
}

// XSS prevention
export function sanitizeHtml(input: string): string {
  const div = document.createElement('div');
  div.textContent = input;
  return div.innerHTML;
}

// SQL injection prevention for dynamic queries
export function escapeSqlString(input: string): string {
  return input.replace(/'/g, "''");
}

// Rate limiting token bucket
export class TokenBucket {
  private tokens: number;
  private lastRefill: number;
  private readonly capacity: number;
  private readonly refillRate: number;

  constructor(capacity: number, refillRate: number) {
    this.capacity = capacity;
    this.refillRate = refillRate;
    this.tokens = capacity;
    this.lastRefill = Date.now();
  }

  consume(tokens = 1): boolean {
    this.refill();
    
    if (this.tokens >= tokens) {
      this.tokens -= tokens;
      return true;
    }
    
    return false;
  }

  private refill(): void {
    const now = Date.now();
    const timePassed = (now - this.lastRefill) / 1000;
    const tokensToAdd = timePassed * this.refillRate;
    
    this.tokens = Math.min(this.capacity, this.tokens + tokensToAdd);
    this.lastRefill = now;
  }

  getRemainingTokens(): number {
    this.refill();
    return Math.floor(this.tokens);
  }
}

// Input validation middleware
export function createValidationMiddleware<T>(schema: z.ZodSchema<T>) {
  return (input: unknown) => {
    const validation = validateAndSanitizeInput(input, schema);
    
    if (!validation.success) {
      // Fix: only access errors if validation.success is false
      const errorList = "errors" in validation ? validation.errors : ["Unknown validation error"];
      throw new Error(`Validation failed: ${errorList.join(', ')}`);
    }
    
    return validation.data;
  };
}

// File upload validation
export const fileUploadSchema = z.object({
  file: z.instanceof(File)
    .refine((file) => file.size <= 10 * 1024 * 1024, 'File size must be less than 10MB')
    .refine(
      (file) => ['image/jpeg', 'image/png', 'image/webp', 'application/pdf'].includes(file.type),
      'Invalid file type'
    ),
  
  description: z.string()
    .max(200, 'Description too long')
    .optional()
});

// URL validation
export function validateUrl(url: string): boolean {
  try {
    const urlObj = new URL(url);
    return ['http:', 'https:'].includes(urlObj.protocol);
  } catch {
    return false;
  }
}

// Phone number validation
export function validatePhoneNumber(phone: string): boolean {
  const phoneRegex = /^\+?[\d\s\-\(\)]+$/;
  const cleanPhone = phone.replace(/[\s\-\(\)]/g, '');
  return phoneRegex.test(phone) && cleanPhone.length >= 7 && cleanPhone.length <= 15;
}

// Credit card validation (Luhn algorithm)
export function validateCreditCard(cardNumber: string): boolean {
  const cleanNumber = cardNumber.replace(/\s+/g, '');
  
  if (!/^\d+$/.test(cleanNumber)) return false;
  
  let sum = 0;
  let isEven = false;
  
  for (let i = cleanNumber.length - 1; i >= 0; i--) {
    let digit = parseInt(cleanNumber[i]);
    
    if (isEven) {
      digit *= 2;
      if (digit > 9) digit -= 9;
    }
    
    sum += digit;
    isEven = !isEven;
  }
  
  return sum % 10 === 0;
}

/**
 * PDF export functionality for career analyses
 */

export interface CareerAnalysisData {
  title: string;
  code: string;
  overallAPO: number;
  confidence: string;
  timeline: string;
  categoryBreakdown: {
    tasks: { apo: number; confidence: string };
    knowledge: { apo: number; confidence: string };
    skills: { apo: number; confidence: string };
    abilities: { apo: number; confidence: string };
    technologies: { apo: number; confidence: string };
  };
  insights: {
    primary_opportunities: string[];
    main_challenges: string[];
    automation_drivers: string[];
    barriers: string[];
  };
}

export const exportAnalysisToPDF = async (analyses: CareerAnalysisData[], filename?: string) => {
  try {
    // Create HTML content for PDF generation
    const htmlContent = generatePDFHTML(analyses);
    
    // Use browser's print functionality for PDF generation
    const printWindow = window.open('', '_blank');
    if (!printWindow) {
      throw new Error('Unable to open print window. Please allow pop-ups.');
    }

    printWindow.document.write(htmlContent);
    printWindow.document.close();
    
    // Auto-print after content loads
    printWindow.onload = () => {
      printWindow.print();
      // Close window after printing (user can cancel)
      setTimeout(() => {
        printWindow.close();
      }, 1000);
    };

  } catch (error) {
    console.error('PDF export failed:', error);
    throw new Error('Failed to export PDF. Please try again.');
  }
};

const generatePDFHTML = (analyses: CareerAnalysisData[]): string => {
  const currentDate = new Date().toLocaleDateString();
  
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>APO Career Analysis Report</title>
      <style>
        body {
          font-family: Arial, sans-serif;
          line-height: 1.6;
          color: #333;
          max-width: 800px;
          margin: 0 auto;
          padding: 20px;
        }
        .header {
          text-align: center;
          border-bottom: 3px solid #2563eb;
          padding-bottom: 20px;
          margin-bottom: 30px;
        }
        .analysis {
          margin-bottom: 40px;
          break-inside: avoid;
        }
        .title {
          color: #2563eb;
          font-size: 24px;
          margin-bottom: 10px;
        }
        .apo-score {
          background: #f3f4f6;
          padding: 15px;
          border-radius: 8px;
          margin: 20px 0;
        }
        .category-grid {
          display: grid;
          grid-template-columns: repeat(2, 1fr);
          gap: 15px;
          margin: 20px 0;
        }
        .category-item {
          background: #f9fafb;
          padding: 10px;
          border-radius: 6px;
          border-left: 4px solid #2563eb;
        }
        .insights {
          margin-top: 20px;
        }
        .insight-section {
          margin-bottom: 15px;
        }
        .insight-title {
          font-weight: bold;
          color: #1f2937;
          margin-bottom: 8px;
        }
        .insight-list {
          list-style-type: disc;
          margin-left: 20px;
        }
        .footer {
          text-align: center;
          margin-top: 40px;
          padding-top: 20px;
          border-top: 1px solid #e5e7eb;
          color: #6b7280;
        }
        @media print {
          body { margin: 0; }
          .analysis { page-break-inside: avoid; }
        }
      </style>
    </head>
    <body>
      <div class="header">
        <h1>APO Career Analysis Report</h1>
        <p>Generated on ${currentDate}</p>
        <p>Automation Potential Overview for ${analyses.length} Career${analyses.length > 1 ? 's' : ''}</p>
      </div>
      
      ${analyses.map(analysis => `
        <div class="analysis">
          <h2 class="title">${analysis.title}</h2>
          <p><strong>O*NET Code:</strong> ${analysis.code}</p>
          
          <div class="apo-score">
            <h3>Overall Automation Potential: ${(analysis.overallAPO * 100).toFixed(1)}%</h3>
            <p><strong>Confidence:</strong> ${analysis.confidence}</p>
            <p><strong>Timeline:</strong> ${analysis.timeline}</p>
          </div>
          
          <h3>Category Breakdown</h3>
          <div class="category-grid">
            <div class="category-item">
              <strong>Tasks:</strong> ${(analysis.categoryBreakdown.tasks.apo * 100).toFixed(1)}%
              <br><small>Confidence: ${analysis.categoryBreakdown.tasks.confidence}</small>
            </div>
            <div class="category-item">
              <strong>Knowledge:</strong> ${(analysis.categoryBreakdown.knowledge.apo * 100).toFixed(1)}%
              <br><small>Confidence: ${analysis.categoryBreakdown.knowledge.confidence}</small>
            </div>
            <div class="category-item">
              <strong>Skills:</strong> ${(analysis.categoryBreakdown.skills.apo * 100).toFixed(1)}%
              <br><small>Confidence: ${analysis.categoryBreakdown.skills.confidence}</small>
            </div>
            <div class="category-item">
              <strong>Abilities:</strong> ${(analysis.categoryBreakdown.abilities.apo * 100).toFixed(1)}%
              <br><small>Confidence: ${analysis.categoryBreakdown.abilities.confidence}</small>
            </div>
            <div class="category-item">
              <strong>Technologies:</strong> ${(analysis.categoryBreakdown.technologies.apo * 100).toFixed(1)}%
              <br><small>Confidence: ${analysis.categoryBreakdown.technologies.confidence}</small>
            </div>
          </div>
          
          <div class="insights">
            <h3>Key Insights</h3>
            
            <div class="insight-section">
              <div class="insight-title">Primary Opportunities:</div>
              <ul class="insight-list">
                ${analysis.insights.primary_opportunities.map(item => `<li>${item}</li>`).join('')}
              </ul>
            </div>
            
            <div class="insight-section">
              <div class="insight-title">Main Challenges:</div>
              <ul class="insight-list">
                ${analysis.insights.main_challenges.map(item => `<li>${item}</li>`).join('')}
              </ul>
            </div>
            
            <div class="insight-section">
              <div class="insight-title">Automation Drivers:</div>
              <ul class="insight-list">
                ${analysis.insights.automation_drivers.map(item => `<li>${item}</li>`).join('')}
              </ul>
            </div>
            
            <div class="insight-section">
              <div class="insight-title">Barriers to Automation:</div>
              <ul class="insight-list">
                ${analysis.insights.barriers.map(item => `<li>${item}</li>`).join('')}
              </ul>
            </div>
          </div>
        </div>
      `).join('')}
      
      <div class="footer">
        <p>This report was generated by the APO Dashboard</p>
        <p>Data sourced from O*NET and analyzed using advanced AI algorithms</p>
      </div>
    </body>
    </html>
  `;
};
/**
 * chatCache.ts
 * A lightweight localStorage helper for persisting conversation history between
 * the user and the AI Career Coach. Each user gets a separate cache key.
 */
export interface ChatMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
}

const CACHE_PREFIX = 'career-coach-chat-';

export function loadChatHistory(userId: string): ChatMessage[] {
  try {
    const raw = localStorage.getItem(CACHE_PREFIX + userId);
    if (!raw) return [];
    return JSON.parse(raw) as ChatMessage[];
  } catch {
    return [];
  }
}

export function saveChatHistory(userId: string, history: ChatMessage[]) {
  try {
    localStorage.setItem(CACHE_PREFIX + userId, JSON.stringify(history));
  } catch {
    /* storage quota exceeded or unavailable */
  }
}

interface RateLimitEntry {
  count: number;
  resetTime: number;
}

class RateLimiter {
  private limits: Map<string, RateLimitEntry> = new Map();
  private readonly maxRequests: number;
  private readonly windowMs: number;

  constructor(maxRequests: number = 10, windowMs: number = 60000) {
    this.maxRequests = maxRequests;
    this.windowMs = windowMs;
  }

  isAllowed(key: string): boolean {
    const now = Date.now();
    const entry = this.limits.get(key);

    if (!entry || now > entry.resetTime) {
      // Reset or create new entry
      this.limits.set(key, {
        count: 1,
        resetTime: now + this.windowMs
      });
      return true;
    }

    if (entry.count >= this.maxRequests) {
      return false;
    }

    entry.count++;
    return true;
  }

  getRemainingRequests(key: string): number {
    const entry = this.limits.get(key);
    if (!entry || Date.now() > entry.resetTime) {
      return this.maxRequests;
    }
    return Math.max(0, this.maxRequests - entry.count);
  }

  getResetTime(key: string): number {
    const entry = this.limits.get(key);
    return entry?.resetTime || Date.now();
  }

  getTimeUntilReset(key: string): number {
    const resetTime = this.getResetTime(key);
    return Math.max(0, resetTime - Date.now());
  }

  cleanup(): void {
    const now = Date.now();
    for (const [key, entry] of this.limits.entries()) {
      if (now > entry.resetTime) {
        this.limits.delete(key);
      }
    }
  }
}

// Global rate limiters for different operations
export const searchRateLimiter = new RateLimiter(20, 60000); // 20 searches per minute
export const apoRateLimiter = new RateLimiter(5, 60000); // 5 APO calculations per minute
export const exportRateLimiter = new RateLimiter(10, 300000); // 10 exports per 5 minutes

// Cleanup function to run periodically
setInterval(() => {
  searchRateLimiter.cleanup();
  apoRateLimiter.cleanup();
  exportRateLimiter.cleanup();
}, 300000); // Cleanup every 5 minutes

export function checkRateLimit(limiter: RateLimiter, userId: string): {
  allowed: boolean;
  remaining: number;
  resetTime: number;
  timeUntilReset: number;
} {
  const allowed = limiter.isAllowed(userId);
  const remaining = limiter.getRemainingRequests(userId);
  const resetTime = limiter.getResetTime(userId);
  const timeUntilReset = limiter.getTimeUntilReset(userId);

  return { allowed, remaining, resetTime, timeUntilReset };
}

export function formatTimeUntilReset(milliseconds: number): string {
  const seconds = Math.ceil(milliseconds / 1000);
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  
  if (minutes > 0) {
    return `${minutes}m ${remainingSeconds}s`;
  }
  return `${remainingSeconds}s`;
}
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Definition of the design system. All colors, gradients, fonts, etc should be defined here. */

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;

    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;

    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;

    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;

    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;

    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;

    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;

    --radius: 0.5rem;

    --sidebar-background: 0 0% 98%;

    --sidebar-foreground: 240 5.3% 26.1%;

    --sidebar-primary: 240 5.9% 10%;

    --sidebar-primary-foreground: 0 0% 98%;

    --sidebar-accent: 240 4.8% 95.9%;

    --sidebar-accent-foreground: 240 5.9% 10%;

    --sidebar-border: 220 13% 91%;

    --sidebar-ring: 217.2 91.2% 59.8%;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;

    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;

    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;

    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;

    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;

    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;

    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;

    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 224.3 76.3% 48%;
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-background text-foreground;
  }
}export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  public: {
    Tables: {
      agents: {
        Row: {
          avatar_url: string | null
          created_at: string
          id: string
          is_active: boolean
          name: string
          project_id: string
          role: string
          system_prompt: string
          updated_at: string
        }
        Insert: {
          avatar_url?: string | null
          created_at?: string
          id?: string
          is_active?: boolean
          name: string
          project_id: string
          role: string
          system_prompt: string
          updated_at?: string
        }
        Update: {
          avatar_url?: string | null
          created_at?: string
          id?: string
          is_active?: boolean
          name?: string
          project_id?: string
          role?: string
          system_prompt?: string
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "agents_project_id_fkey"
            columns: ["project_id"]
            isOneToOne: false
            referencedRelation: "projects"
            referencedColumns: ["id"]
          },
        ]
      }
      agreements: {
        Row: {
          agreement_text: string
          created_at: string
          id: string
          user_id: string
        }
        Insert: {
          agreement_text: string
          created_at?: string
          id?: string
          user_id: string
        }
        Update: {
          agreement_text?: string
          created_at?: string
          id?: string
          user_id?: string
        }
        Relationships: []
      }
      agricultural_profiles: {
        Row: {
          created_at: string | null
          farming_experience: number | null
          farming_method: string | null
          id: string
          irrigation_access: boolean | null
          land_ownership: string | null
          land_size: number | null
          last_season_yield: Json | null
          primary_crops: string[]
          soil_type: string | null
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          farming_experience?: number | null
          farming_method?: string | null
          id?: string
          irrigation_access?: boolean | null
          land_ownership?: string | null
          land_size?: number | null
          last_season_yield?: Json | null
          primary_crops?: string[]
          soil_type?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          farming_experience?: number | null
          farming_method?: string | null
          id?: string
          irrigation_access?: boolean | null
          land_ownership?: string | null
          land_size?: number | null
          last_season_yield?: Json | null
          primary_crops?: string[]
          soil_type?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "agricultural_profiles_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "unified_users"
            referencedColumns: ["id"]
          },
        ]
      }
      ai_analysis: {
        Row: {
          analysis_data: Json
          analysis_type: string
          confidence_score: number | null
          created_at: string
          id: string
          image_id: string | null
          updated_at: string
          user_id: string | null
        }
        Insert: {
          analysis_data?: Json
          analysis_type?: string
          confidence_score?: number | null
          created_at?: string
          id?: string
          image_id?: string | null
          updated_at?: string
          user_id?: string | null
        }
        Update: {
          analysis_data?: Json
          analysis_type?: string
          confidence_score?: number | null
          created_at?: string
          id?: string
          image_id?: string | null
          updated_at?: string
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ai_analysis_image_id_fkey"
            columns: ["image_id"]
            isOneToOne: false
            referencedRelation: "medical_images"
            referencedColumns: ["id"]
          },
        ]
      }
      ai_employee_tasks: {
        Row: {
          created_at: string | null
          employee_id: string
          id: string
          input_prompt: string
          llm_response: string
          task_type: string
          user_id: string
        }
        Insert: {
          created_at?: string | null
          employee_id: string
          id?: string
          input_prompt: string
          llm_response: string
          task_type: string
          user_id: string
        }
        Update: {
          created_at?: string | null
          employee_id?: string
          id?: string
          input_prompt?: string
          llm_response?: string
          task_type?: string
          user_id?: string
        }
        Relationships: []
      }
      ai_employees: {
        Row: {
          avatar: string
          cost: number
          created_at: string
          id: string
          name: string
          status: string
          success_rate: number
          tasks_completed: number
          type: string
          updated_at: string
          user_id: string
        }
        Insert: {
          avatar: string
          cost?: number
          created_at?: string
          id?: string
          name: string
          status?: string
          success_rate?: number
          tasks_completed?: number
          type: string
          updated_at?: string
          user_id: string
        }
        Update: {
          avatar?: string
          cost?: number
          created_at?: string
          id?: string
          name?: string
          status?: string
          success_rate?: number
          tasks_completed?: number
          type?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      ai_modules: {
        Row: {
          category: Database["public"]["Enums"]["module_category"]
          configuration_schema: Json
          created_at: string | null
          description: string
          icon_name: string
          id: string
          name: string
          price_per_use: number
          status: Database["public"]["Enums"]["module_status"]
          supported_platforms: Database["public"]["Enums"]["platform_type"][]
          updated_at: string | null
        }
        Insert: {
          category: Database["public"]["Enums"]["module_category"]
          configuration_schema?: Json
          created_at?: string | null
          description: string
          icon_name: string
          id?: string
          name: string
          price_per_use?: number
          status?: Database["public"]["Enums"]["module_status"]
          supported_platforms: Database["public"]["Enums"]["platform_type"][]
          updated_at?: string | null
        }
        Update: {
          category?: Database["public"]["Enums"]["module_category"]
          configuration_schema?: Json
          created_at?: string | null
          description?: string
          icon_name?: string
          id?: string
          name?: string
          price_per_use?: number
          status?: Database["public"]["Enums"]["module_status"]
          supported_platforms?: Database["public"]["Enums"]["platform_type"][]
          updated_at?: string | null
        }
        Relationships: []
      }
      ai_projects: {
        Row: {
          compliance_flags: string[] | null
          config: Json
          created_at: string
          domain: string
          id: string
          llm_provider: string | null
          name: string
          status: string
          subdomain: string | null
          tenant_id: string
          token_budget: number | null
          updated_at: string
          user_id: string
        }
        Insert: {
          compliance_flags?: string[] | null
          config?: Json
          created_at?: string
          domain: string
          id?: string
          llm_provider?: string | null
          name: string
          status?: string
          subdomain?: string | null
          tenant_id: string
          token_budget?: number | null
          updated_at?: string
          user_id: string
        }
        Update: {
          compliance_flags?: string[] | null
          config?: Json
          created_at?: string
          domain?: string
          id?: string
          llm_provider?: string | null
          name?: string
          status?: string
          subdomain?: string | null
          tenant_id?: string
          token_budget?: number | null
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      ai_reskilling_resources: {
        Row: {
          cost_type: string | null
          created_at: string
          description: string | null
          id: string
          provider: string
          skill_area: string
          title: string
          url: string
        }
        Insert: {
          cost_type?: string | null
          created_at?: string
          description?: string | null
          id?: string
          provider: string
          skill_area: string
          title: string
          url: string
        }
        Update: {
          cost_type?: string | null
          created_at?: string
          description?: string | null
          id?: string
          provider?: string
          skill_area?: string
          title?: string
          url?: string
        }
        Relationships: []
      }
      ai_skill_recommendations: {
        Row: {
          created_at: string
          explanation: string
          id: string
          occupation_code: string
          priority: number
          skill_name: string
        }
        Insert: {
          created_at?: string
          explanation: string
          id?: string
          occupation_code: string
          priority?: number
          skill_name: string
        }
        Update: {
          created_at?: string
          explanation?: string
          id?: string
          occupation_code?: string
          priority?: number
          skill_name?: string
        }
        Relationships: []
      }
      ai_task_assessments: {
        Row: {
          category: string
          confidence: number | null
          created_at: string
          explanation: string | null
          id: string
          occupation_code: string
          occupation_title: string
          task_description: string
          user_id: string | null
        }
        Insert: {
          category: string
          confidence?: number | null
          created_at?: string
          explanation?: string | null
          id?: string
          occupation_code: string
          occupation_title: string
          task_description: string
          user_id?: string | null
        }
        Update: {
          category?: string
          confidence?: number | null
          created_at?: string
          explanation?: string | null
          id?: string
          occupation_code?: string
          occupation_title?: string
          task_description?: string
          user_id?: string | null
        }
        Relationships: []
      }
      ai_usage: {
        Row: {
          cost: number | null
          created_at: string | null
          error_message: string | null
          id: string
          input_data: Json | null
          module_id: string
          output_data: Json | null
          processing_time_ms: number | null
          status: Database["public"]["Enums"]["usage_status"]
          tokens_used: number | null
          user_id: string
          workflow_id: string | null
        }
        Insert: {
          cost?: number | null
          created_at?: string | null
          error_message?: string | null
          id?: string
          input_data?: Json | null
          module_id: string
          output_data?: Json | null
          processing_time_ms?: number | null
          status: Database["public"]["Enums"]["usage_status"]
          tokens_used?: number | null
          user_id: string
          workflow_id?: string | null
        }
        Update: {
          cost?: number | null
          created_at?: string | null
          error_message?: string | null
          id?: string
          input_data?: Json | null
          module_id?: string
          output_data?: Json | null
          processing_time_ms?: number | null
          status?: Database["public"]["Enums"]["usage_status"]
          tokens_used?: number | null
          user_id?: string
          workflow_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ai_usage_module_id_fkey"
            columns: ["module_id"]
            isOneToOne: false
            referencedRelation: "ai_modules"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ai_usage_workflow_id_fkey"
            columns: ["workflow_id"]
            isOneToOne: false
            referencedRelation: "ai_workflows"
            referencedColumns: ["id"]
          },
        ]
      }
      ai_workflows: {
        Row: {
          configuration: Json
          created_at: string | null
          description: string | null
          id: string
          is_active: boolean | null
          is_public: boolean | null
          module_id: string
          name: string
          platform: Database["public"]["Enums"]["platform_type"]
          updated_at: string | null
          user_id: string
          webhook_url: string | null
        }
        Insert: {
          configuration?: Json
          created_at?: string | null
          description?: string | null
          id?: string
          is_active?: boolean | null
          is_public?: boolean | null
          module_id: string
          name: string
          platform: Database["public"]["Enums"]["platform_type"]
          updated_at?: string | null
          user_id: string
          webhook_url?: string | null
        }
        Update: {
          configuration?: Json
          created_at?: string | null
          description?: string | null
          id?: string
          is_active?: boolean | null
          is_public?: boolean | null
          module_id?: string
          name?: string
          platform?: Database["public"]["Enums"]["platform_type"]
          updated_at?: string | null
          user_id?: string
          webhook_url?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ai_workflows_module_id_fkey"
            columns: ["module_id"]
            isOneToOne: false
            referencedRelation: "ai_modules"
            referencedColumns: ["id"]
          },
        ]
      }
      alert_configurations: {
        Row: {
          alert_type: string
          criteria: Json
          id: string
          is_active: boolean | null
          notification_settings: Json
          user_id: string | null
        }
        Insert: {
          alert_type: string
          criteria: Json
          id?: string
          is_active?: boolean | null
          notification_settings: Json
          user_id?: string | null
        }
        Update: {
          alert_type?: string
          criteria?: Json
          id?: string
          is_active?: boolean | null
          notification_settings?: Json
          user_id?: string | null
        }
        Relationships: []
      }
      alert_thresholds: {
        Row: {
          condition: string | null
          created_at: string | null
          emotion: string
          enabled: boolean | null
          id: string
          threshold: number | null
          user_id: string | null
        }
        Insert: {
          condition?: string | null
          created_at?: string | null
          emotion: string
          enabled?: boolean | null
          id?: string
          threshold?: number | null
          user_id?: string | null
        }
        Update: {
          condition?: string | null
          created_at?: string | null
          emotion?: string
          enabled?: boolean | null
          id?: string
          threshold?: number | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "alert_thresholds_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      alerts: {
        Row: {
          created_at: string | null
          description: string | null
          id: string
          is_active: boolean | null
          last_triggered: string | null
          name: string
          notification_channels: string[]
          thresholds: Json
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          description?: string | null
          id?: string
          is_active?: boolean | null
          last_triggered?: string | null
          name: string
          notification_channels?: string[]
          thresholds?: Json
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          description?: string | null
          id?: string
          is_active?: boolean | null
          last_triggered?: string | null
          name?: string
          notification_channels?: string[]
          thresholds?: Json
          user_id?: string | null
        }
        Relationships: []
      }
      analysis_results: {
        Row: {
          created_at: string | null
          id: string
          results: Json
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          results: Json
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          results?: Json
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "analysis_results_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      analytics_events: {
        Row: {
          created_at: string
          event_category: string
          event_data: Json | null
          event_name: string
          id: string
          ip_address: unknown | null
          page_url: string | null
          session_id: string | null
          user_agent: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string
          event_category: string
          event_data?: Json | null
          event_name: string
          id?: string
          ip_address?: unknown | null
          page_url?: string | null
          session_id?: string | null
          user_agent?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string
          event_category?: string
          event_data?: Json | null
          event_name?: string
          id?: string
          ip_address?: unknown | null
          page_url?: string | null
          session_id?: string | null
          user_agent?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      apo_analysis_cache: {
        Row: {
          analysis_data: Json
          created_at: string
          id: string
          occupation_code: string
          occupation_title: string
          updated_at: string
        }
        Insert: {
          analysis_data: Json
          created_at?: string
          id?: string
          occupation_code: string
          occupation_title: string
          updated_at?: string
        }
        Update: {
          analysis_data?: Json
          created_at?: string
          id?: string
          occupation_code?: string
          occupation_title?: string
          updated_at?: string
        }
        Relationships: []
      }
      audio_files: {
        Row: {
          created_at: string
          description: string | null
          duration_seconds: number | null
          file_size: number
          filename: string
          id: string
          language: string | null
          location: string | null
          mime_type: string
          original_filename: string
          recording_date: string | null
          speaker_name: string | null
          storage_path: string | null
          updated_at: string
          upload_status: string | null
          user_id: string
        }
        Insert: {
          created_at?: string
          description?: string | null
          duration_seconds?: number | null
          file_size: number
          filename: string
          id?: string
          language?: string | null
          location?: string | null
          mime_type: string
          original_filename: string
          recording_date?: string | null
          speaker_name?: string | null
          storage_path?: string | null
          updated_at?: string
          upload_status?: string | null
          user_id: string
        }
        Update: {
          created_at?: string
          description?: string | null
          duration_seconds?: number | null
          file_size?: number
          filename?: string
          id?: string
          language?: string | null
          location?: string | null
          mime_type?: string
          original_filename?: string
          recording_date?: string | null
          speaker_name?: string | null
          storage_path?: string | null
          updated_at?: string
          upload_status?: string | null
          user_id?: string
        }
        Relationships: []
      }
      audit_alerts: {
        Row: {
          alert_type: Database["public"]["Enums"]["alert_type"]
          audit_id: string | null
          created_at: string
          id: string
          message: string
          metadata: Json | null
          status: Database["public"]["Enums"]["alert_status"]
          title: string
          user_id: string
        }
        Insert: {
          alert_type: Database["public"]["Enums"]["alert_type"]
          audit_id?: string | null
          created_at?: string
          id?: string
          message: string
          metadata?: Json | null
          status?: Database["public"]["Enums"]["alert_status"]
          title: string
          user_id: string
        }
        Update: {
          alert_type?: Database["public"]["Enums"]["alert_type"]
          audit_id?: string | null
          created_at?: string
          id?: string
          message?: string
          metadata?: Json | null
          status?: Database["public"]["Enums"]["alert_status"]
          title?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "audit_alerts_audit_id_fkey"
            columns: ["audit_id"]
            isOneToOne: false
            referencedRelation: "audits"
            referencedColumns: ["id"]
          },
        ]
      }
      audit_comparisons: {
        Row: {
          baseline_audit_id: string
          comparison_audit_id: string
          comparison_data: Json | null
          created_at: string
          id: string
          issues_added: number | null
          issues_resolved: number | null
          revenue_impact_change: number | null
          score_change: number | null
          url: string
          user_id: string
        }
        Insert: {
          baseline_audit_id: string
          comparison_audit_id: string
          comparison_data?: Json | null
          created_at?: string
          id?: string
          issues_added?: number | null
          issues_resolved?: number | null
          revenue_impact_change?: number | null
          score_change?: number | null
          url: string
          user_id: string
        }
        Update: {
          baseline_audit_id?: string
          comparison_audit_id?: string
          comparison_data?: Json | null
          created_at?: string
          id?: string
          issues_added?: number | null
          issues_resolved?: number | null
          revenue_impact_change?: number | null
          score_change?: number | null
          url?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "audit_comparisons_baseline_audit_id_fkey"
            columns: ["baseline_audit_id"]
            isOneToOne: false
            referencedRelation: "audits"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "audit_comparisons_comparison_audit_id_fkey"
            columns: ["comparison_audit_id"]
            isOneToOne: false
            referencedRelation: "audits"
            referencedColumns: ["id"]
          },
        ]
      }
      audit_issues: {
        Row: {
          audit_id: string
          category: Database["public"]["Enums"]["issue_category"]
          created_at: string
          description: string
          fix_code: string | null
          fix_description: string | null
          id: string
          impact: Database["public"]["Enums"]["issue_impact"]
          priority_score: number | null
          revenue_potential: number | null
          title: string
        }
        Insert: {
          audit_id: string
          category: Database["public"]["Enums"]["issue_category"]
          created_at?: string
          description: string
          fix_code?: string | null
          fix_description?: string | null
          id?: string
          impact: Database["public"]["Enums"]["issue_impact"]
          priority_score?: number | null
          revenue_potential?: number | null
          title: string
        }
        Update: {
          audit_id?: string
          category?: Database["public"]["Enums"]["issue_category"]
          created_at?: string
          description?: string
          fix_code?: string | null
          fix_description?: string | null
          id?: string
          impact?: Database["public"]["Enums"]["issue_impact"]
          priority_score?: number | null
          revenue_potential?: number | null
          title?: string
        }
        Relationships: [
          {
            foreignKeyName: "audit_issues_audit_id_fkey"
            columns: ["audit_id"]
            isOneToOne: false
            referencedRelation: "audits"
            referencedColumns: ["id"]
          },
        ]
      }
      audit_logs: {
        Row: {
          category: string | null
          created_at: string | null
          event_details: Json | null
          event_type: string | null
          id: string
          ip_address: unknown | null
          session_id: string | null
          severity: string | null
          user_agent: string | null
          user_id: string | null
        }
        Insert: {
          category?: string | null
          created_at?: string | null
          event_details?: Json | null
          event_type?: string | null
          id?: string
          ip_address?: unknown | null
          session_id?: string | null
          severity?: string | null
          user_agent?: string | null
          user_id?: string | null
        }
        Update: {
          category?: string | null
          created_at?: string | null
          event_details?: Json | null
          event_type?: string | null
          id?: string
          ip_address?: unknown | null
          session_id?: string | null
          severity?: string | null
          user_agent?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      audit_reports: {
        Row: {
          audit_id: string
          file_path: string | null
          file_size: number | null
          generated_at: string
          id: string
          is_public: boolean | null
          report_type: string | null
          share_token: string | null
          user_id: string
        }
        Insert: {
          audit_id: string
          file_path?: string | null
          file_size?: number | null
          generated_at?: string
          id?: string
          is_public?: boolean | null
          report_type?: string | null
          share_token?: string | null
          user_id: string
        }
        Update: {
          audit_id?: string
          file_path?: string | null
          file_size?: number | null
          generated_at?: string
          id?: string
          is_public?: boolean | null
          report_type?: string | null
          share_token?: string | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "audit_reports_audit_id_fkey"
            columns: ["audit_id"]
            isOneToOne: false
            referencedRelation: "audits"
            referencedColumns: ["id"]
          },
        ]
      }
      audits: {
        Row: {
          completed_at: string | null
          created_at: string
          grade: string | null
          id: string
          overall_score: number | null
          scan_metadata: Json | null
          status: Database["public"]["Enums"]["audit_status"]
          total_revenue_potential: number | null
          updated_at: string
          url: string
          user_id: string | null
        }
        Insert: {
          completed_at?: string | null
          created_at?: string
          grade?: string | null
          id?: string
          overall_score?: number | null
          scan_metadata?: Json | null
          status?: Database["public"]["Enums"]["audit_status"]
          total_revenue_potential?: number | null
          updated_at?: string
          url: string
          user_id?: string | null
        }
        Update: {
          completed_at?: string | null
          created_at?: string
          grade?: string | null
          id?: string
          overall_score?: number | null
          scan_metadata?: Json | null
          status?: Database["public"]["Enums"]["audit_status"]
          total_revenue_potential?: number | null
          updated_at?: string
          url?: string
          user_id?: string | null
        }
        Relationships: []
      }
      backtest_strategies: {
        Row: {
          created_at: string | null
          date_range_end: string
          date_range_start: string
          id: string
          results: Json | null
          status: string | null
          strategy_name: string
          symbols: string[]
          user_id: string | null
          wave_rules: Json
        }
        Insert: {
          created_at?: string | null
          date_range_end: string
          date_range_start: string
          id?: string
          results?: Json | null
          status?: string | null
          strategy_name: string
          symbols: string[]
          user_id?: string | null
          wave_rules: Json
        }
        Update: {
          created_at?: string | null
          date_range_end?: string
          date_range_start?: string
          id?: string
          results?: Json | null
          status?: string | null
          strategy_name?: string
          symbols?: string[]
          user_id?: string | null
          wave_rules?: Json
        }
        Relationships: []
      }
      business_photos: {
        Row: {
          alt_text: string | null
          business_id: string
          display_order: number | null
          file_name: string
          file_path: string
          file_size: number | null
          id: string
          mime_type: string | null
          uploaded_at: string
        }
        Insert: {
          alt_text?: string | null
          business_id: string
          display_order?: number | null
          file_name: string
          file_path: string
          file_size?: number | null
          id?: string
          mime_type?: string | null
          uploaded_at?: string
        }
        Update: {
          alt_text?: string | null
          business_id?: string
          display_order?: number | null
          file_name?: string
          file_path?: string
          file_size?: number | null
          id?: string
          mime_type?: string | null
          uploaded_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "business_photos_business_id_fkey"
            columns: ["business_id"]
            isOneToOne: false
            referencedRelation: "businesses"
            referencedColumns: ["id"]
          },
        ]
      }
      business_profiles: {
        Row: {
          business_name: string
          business_type: string
          categories: string[]
          created_at: string | null
          description: string | null
          employee_count: number | null
          growth_stage: string | null
          id: string
          monthly_revenue: number | null
          start_date: string | null
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          business_name: string
          business_type: string
          categories?: string[]
          created_at?: string | null
          description?: string | null
          employee_count?: number | null
          growth_stage?: string | null
          id?: string
          monthly_revenue?: number | null
          start_date?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          business_name?: string
          business_type?: string
          categories?: string[]
          created_at?: string | null
          description?: string | null
          employee_count?: number | null
          growth_stage?: string | null
          id?: string
          monthly_revenue?: number | null
          start_date?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "business_profiles_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "unified_users"
            referencedColumns: ["id"]
          },
        ]
      }
      businesses: {
        Row: {
          address: string
          business_name: string
          business_type: string
          created_at: string
          description: string
          email: string
          id: string
          phone: string
          services: string | null
          social_media: string | null
          target_keywords: string | null
          updated_at: string
          user_id: string
          website: string | null
        }
        Insert: {
          address: string
          business_name: string
          business_type: string
          created_at?: string
          description: string
          email: string
          id?: string
          phone: string
          services?: string | null
          social_media?: string | null
          target_keywords?: string | null
          updated_at?: string
          user_id: string
          website?: string | null
        }
        Update: {
          address?: string
          business_name?: string
          business_type?: string
          created_at?: string
          description?: string
          email?: string
          id?: string
          phone?: string
          services?: string | null
          social_media?: string | null
          target_keywords?: string | null
          updated_at?: string
          user_id?: string
          website?: string | null
        }
        Relationships: []
      }
      cache_entries: {
        Row: {
          created_at: string | null
          data: Json
          expires_at: string
          key: string
        }
        Insert: {
          created_at?: string | null
          data: Json
          expires_at: string
          key: string
        }
        Update: {
          created_at?: string | null
          data?: Json
          expires_at?: string
          key?: string
        }
        Relationships: []
      }
      care_profiles: {
        Row: {
          birth_date: string | null
          created_at: string | null
          emergency_contact_name: string | null
          emergency_contact_phone: string | null
          full_name: string
          id: string
          medical_conditions: string[] | null
          medications: string[] | null
          preferences: Json | null
          preferred_name: string | null
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          birth_date?: string | null
          created_at?: string | null
          emergency_contact_name?: string | null
          emergency_contact_phone?: string | null
          full_name: string
          id?: string
          medical_conditions?: string[] | null
          medications?: string[] | null
          preferences?: Json | null
          preferred_name?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          birth_date?: string | null
          created_at?: string | null
          emergency_contact_name?: string | null
          emergency_contact_phone?: string | null
          full_name?: string
          id?: string
          medical_conditions?: string[] | null
          medications?: string[] | null
          preferences?: Json | null
          preferred_name?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      career_assessments: {
        Row: {
          assessment_data: Json | null
          assessment_type: string
          created_at: string
          current_role: string
          experience_match_score: number
          id: string
          overall_fit_score: number
          recommendations: Json | null
          skill_gaps: Json | null
          skills_match_score: number
          target_role: string
          user_id: string
        }
        Insert: {
          assessment_data?: Json | null
          assessment_type?: string
          created_at?: string
          current_role: string
          experience_match_score: number
          id?: string
          overall_fit_score: number
          recommendations?: Json | null
          skill_gaps?: Json | null
          skills_match_score: number
          target_role: string
          user_id: string
        }
        Update: {
          assessment_data?: Json | null
          assessment_type?: string
          created_at?: string
          current_role?: string
          experience_match_score?: number
          id?: string
          overall_fit_score?: number
          recommendations?: Json | null
          skill_gaps?: Json | null
          skills_match_score?: number
          target_role?: string
          user_id?: string
        }
        Relationships: []
      }
      career_learning_modules: {
        Row: {
          content_data: Json
          created_at: string
          description: string | null
          difficulty_level: number | null
          estimated_minutes: number | null
          id: string
          is_active: boolean | null
          learning_objectives: string[] | null
          module_type: string
          prerequisites: string[] | null
          target_roles: string[] | null
          title: string
          updated_at: string
        }
        Insert: {
          content_data?: Json
          created_at?: string
          description?: string | null
          difficulty_level?: number | null
          estimated_minutes?: number | null
          id?: string
          is_active?: boolean | null
          learning_objectives?: string[] | null
          module_type?: string
          prerequisites?: string[] | null
          target_roles?: string[] | null
          title: string
          updated_at?: string
        }
        Update: {
          content_data?: Json
          created_at?: string
          description?: string | null
          difficulty_level?: number | null
          estimated_minutes?: number | null
          id?: string
          is_active?: boolean | null
          learning_objectives?: string[] | null
          module_type?: string
          prerequisites?: string[] | null
          target_roles?: string[] | null
          title?: string
          updated_at?: string
        }
        Relationships: []
      }
      career_recommendations: {
        Row: {
          action_items: Json | null
          created_at: string
          description: string
          expires_at: string | null
          id: string
          metadata: Json | null
          priority_score: number | null
          recommendation_type: string
          status: string | null
          title: string
          user_id: string
        }
        Insert: {
          action_items?: Json | null
          created_at?: string
          description: string
          expires_at?: string | null
          id?: string
          metadata?: Json | null
          priority_score?: number | null
          recommendation_type: string
          status?: string | null
          title: string
          user_id: string
        }
        Update: {
          action_items?: Json | null
          created_at?: string
          description?: string
          expires_at?: string | null
          id?: string
          metadata?: Json | null
          priority_score?: number | null
          recommendation_type?: string
          status?: string | null
          title?: string
          user_id?: string
        }
        Relationships: []
      }
      career_transitions: {
        Row: {
          confidence_score: number | null
          created_at: string
          current_industry: string | null
          current_role: string
          estimated_timeline_months: number | null
          id: string
          target_industry: string | null
          target_role: string
          transition_stage: string
          updated_at: string
          user_id: string
        }
        Insert: {
          confidence_score?: number | null
          created_at?: string
          current_industry?: string | null
          current_role: string
          estimated_timeline_months?: number | null
          id?: string
          target_industry?: string | null
          target_role: string
          transition_stage?: string
          updated_at?: string
          user_id: string
        }
        Update: {
          confidence_score?: number | null
          created_at?: string
          current_industry?: string | null
          current_role?: string
          estimated_timeline_months?: number | null
          id?: string
          target_industry?: string | null
          target_role?: string
          transition_stage?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      cascade_predictions: {
        Row: {
          created_at: string
          id: string
          parameters: Json
          results: Json | null
          user_id: string | null
        }
        Insert: {
          created_at?: string
          id?: string
          parameters?: Json
          results?: Json | null
          user_id?: string | null
        }
        Update: {
          created_at?: string
          id?: string
          parameters?: Json
          results?: Json | null
          user_id?: string | null
        }
        Relationships: []
      }
      certifications: {
        Row: {
          badge_url: string | null
          certification_url: string | null
          created_at: string | null
          description: string | null
          id: string
          is_active: boolean | null
          issuing_organization: string
          name: string
          requirements: Json | null
          skill_ids: string[] | null
          updated_at: string | null
          validity_period_months: number | null
        }
        Insert: {
          badge_url?: string | null
          certification_url?: string | null
          created_at?: string | null
          description?: string | null
          id?: string
          is_active?: boolean | null
          issuing_organization: string
          name: string
          requirements?: Json | null
          skill_ids?: string[] | null
          updated_at?: string | null
          validity_period_months?: number | null
        }
        Update: {
          badge_url?: string | null
          certification_url?: string | null
          created_at?: string | null
          description?: string | null
          id?: string
          is_active?: boolean | null
          issuing_organization?: string
          name?: string
          requirements?: Json | null
          skill_ids?: string[] | null
          updated_at?: string | null
          validity_period_months?: number | null
        }
        Relationships: []
      }
      chat_conversations: {
        Row: {
          created_at: string | null
          id: string
          title: string | null
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          title?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          title?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      chat_messages: {
        Row: {
          content: string
          conversation_id: string | null
          created_at: string | null
          id: string
          role: string
        }
        Insert: {
          content: string
          conversation_id?: string | null
          created_at?: string | null
          id?: string
          role: string
        }
        Update: {
          content?: string
          conversation_id?: string | null
          created_at?: string | null
          id?: string
          role?: string
        }
        Relationships: [
          {
            foreignKeyName: "chat_messages_conversation_id_fkey"
            columns: ["conversation_id"]
            isOneToOne: false
            referencedRelation: "chat_conversations"
            referencedColumns: ["id"]
          },
        ]
      }
      cities: {
        Row: {
          area_size: string | null
          climate_zone: string | null
          created_at: string | null
          id: string
          location: Json
          name: string
          planning_score: number | null
          population_target: number
          status: string | null
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          area_size?: string | null
          climate_zone?: string | null
          created_at?: string | null
          id?: string
          location: Json
          name: string
          planning_score?: number | null
          population_target: number
          status?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          area_size?: string | null
          climate_zone?: string | null
          created_at?: string | null
          id?: string
          location?: Json
          name?: string
          planning_score?: number | null
          population_target?: number
          status?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      community_comments: {
        Row: {
          content: string
          created_at: string | null
          id: string
          parent_id: string | null
          post_id: string | null
          user_id: string | null
        }
        Insert: {
          content: string
          created_at?: string | null
          id?: string
          parent_id?: string | null
          post_id?: string | null
          user_id?: string | null
        }
        Update: {
          content?: string
          created_at?: string | null
          id?: string
          parent_id?: string | null
          post_id?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "community_comments_parent_id_fkey"
            columns: ["parent_id"]
            isOneToOne: false
            referencedRelation: "community_comments"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "community_comments_post_id_fkey"
            columns: ["post_id"]
            isOneToOne: false
            referencedRelation: "community_wave_posts"
            referencedColumns: ["id"]
          },
        ]
      }
      community_events: {
        Row: {
          accessibility_features: string[] | null
          comfort_level: string
          created_at: string
          current_participants: number | null
          description: string | null
          event_datetime: string
          event_status: string
          event_type: string
          id: string
          location_data: Json
          max_participants: number | null
          organizer_id: string
          safety_guidelines: string | null
          target_demographics: string[] | null
          title: string
          updated_at: string
        }
        Insert: {
          accessibility_features?: string[] | null
          comfort_level?: string
          created_at?: string
          current_participants?: number | null
          description?: string | null
          event_datetime: string
          event_status?: string
          event_type: string
          id?: string
          location_data: Json
          max_participants?: number | null
          organizer_id: string
          safety_guidelines?: string | null
          target_demographics?: string[] | null
          title: string
          updated_at?: string
        }
        Update: {
          accessibility_features?: string[] | null
          comfort_level?: string
          created_at?: string
          current_participants?: number | null
          description?: string | null
          event_datetime?: string
          event_status?: string
          event_type?: string
          id?: string
          location_data?: Json
          max_participants?: number | null
          organizer_id?: string
          safety_guidelines?: string | null
          target_demographics?: string[] | null
          title?: string
          updated_at?: string
        }
        Relationships: []
      }
      community_likes: {
        Row: {
          created_at: string | null
          post_id: string
          user_id: string
        }
        Insert: {
          created_at?: string | null
          post_id: string
          user_id: string
        }
        Update: {
          created_at?: string | null
          post_id?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "community_likes_post_id_fkey"
            columns: ["post_id"]
            isOneToOne: false
            referencedRelation: "community_wave_posts"
            referencedColumns: ["id"]
          },
        ]
      }
      community_wave_posts: {
        Row: {
          chart_image_url: string | null
          comments_count: number | null
          created_at: string | null
          description: string | null
          id: string
          is_public: boolean | null
          likes_count: number | null
          symbol: string
          timeframe: string
          title: string
          user_id: string | null
          wave_analysis: Json
        }
        Insert: {
          chart_image_url?: string | null
          comments_count?: number | null
          created_at?: string | null
          description?: string | null
          id?: string
          is_public?: boolean | null
          likes_count?: number | null
          symbol: string
          timeframe: string
          title: string
          user_id?: string | null
          wave_analysis: Json
        }
        Update: {
          chart_image_url?: string | null
          comments_count?: number | null
          created_at?: string | null
          description?: string | null
          id?: string
          is_public?: boolean | null
          likes_count?: number | null
          symbol?: string
          timeframe?: string
          title?: string
          user_id?: string | null
          wave_analysis?: Json
        }
        Relationships: []
      }
      connection_interactions: {
        Row: {
          connection_match_id: string
          created_at: string
          id: string
          interaction_data: Json | null
          interaction_type: string
          notes: string | null
          satisfaction_rating: number | null
        }
        Insert: {
          connection_match_id: string
          created_at?: string
          id?: string
          interaction_data?: Json | null
          interaction_type: string
          notes?: string | null
          satisfaction_rating?: number | null
        }
        Update: {
          connection_match_id?: string
          created_at?: string
          id?: string
          interaction_data?: Json | null
          interaction_type?: string
          notes?: string | null
          satisfaction_rating?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "connection_interactions_connection_match_id_fkey"
            columns: ["connection_match_id"]
            isOneToOne: false
            referencedRelation: "connection_matches"
            referencedColumns: ["id"]
          },
        ]
      }
      connection_matches: {
        Row: {
          compatibility_score: number
          conversation_starters: Json | null
          created_at: string
          id: string
          match_reasoning: Json | null
          match_type: string
          matched_user_id: string
          safety_notes: string | null
          status: string
          suggested_activities: Json | null
          updated_at: string
          user_id: string
        }
        Insert: {
          compatibility_score: number
          conversation_starters?: Json | null
          created_at?: string
          id?: string
          match_reasoning?: Json | null
          match_type?: string
          matched_user_id: string
          safety_notes?: string | null
          status?: string
          suggested_activities?: Json | null
          updated_at?: string
          user_id: string
        }
        Update: {
          compatibility_score?: number
          conversation_starters?: Json | null
          created_at?: string
          id?: string
          match_reasoning?: Json | null
          match_type?: string
          matched_user_id?: string
          safety_notes?: string | null
          status?: string
          suggested_activities?: Json | null
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      contact_requests: {
        Row: {
          contact_email: string | null
          created_at: string
          id: string
          message: string
          response: string | null
          status: string
          subject: string
          updated_at: string
          user_id: string
        }
        Insert: {
          contact_email?: string | null
          created_at?: string
          id?: string
          message: string
          response?: string | null
          status?: string
          subject: string
          updated_at?: string
          user_id: string
        }
        Update: {
          contact_email?: string | null
          created_at?: string
          id?: string
          message?: string
          response?: string | null
          status?: string
          subject?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      contagion_risks: {
        Row: {
          assessment_data: Json | null
          created_at: string | null
          expires_at: string | null
          id: string
          protection_strategies: string[] | null
          risk_level: string | null
          score: number | null
          sources: string[] | null
          user_id: string | null
        }
        Insert: {
          assessment_data?: Json | null
          created_at?: string | null
          expires_at?: string | null
          id?: string
          protection_strategies?: string[] | null
          risk_level?: string | null
          score?: number | null
          sources?: string[] | null
          user_id?: string | null
        }
        Update: {
          assessment_data?: Json | null
          created_at?: string | null
          expires_at?: string | null
          id?: string
          protection_strategies?: string[] | null
          risk_level?: string | null
          score?: number | null
          sources?: string[] | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "contagion_risks_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      conversation_analytics: {
        Row: {
          agent_id: string
          created_at: string
          id: string
          message_count: number | null
          project_id: string
          response_time_avg: number | null
          satisfaction_score: number | null
          sentiment_score: number | null
          session_id: string
          topics: Json | null
          user_id: string
        }
        Insert: {
          agent_id: string
          created_at?: string
          id?: string
          message_count?: number | null
          project_id: string
          response_time_avg?: number | null
          satisfaction_score?: number | null
          sentiment_score?: number | null
          session_id: string
          topics?: Json | null
          user_id: string
        }
        Update: {
          agent_id?: string
          created_at?: string
          id?: string
          message_count?: number | null
          project_id?: string
          response_time_avg?: number | null
          satisfaction_score?: number | null
          sentiment_score?: number | null
          session_id?: string
          topics?: Json | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "conversation_analytics_agent_id_fkey"
            columns: ["agent_id"]
            isOneToOne: false
            referencedRelation: "agents"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "conversation_analytics_project_id_fkey"
            columns: ["project_id"]
            isOneToOne: false
            referencedRelation: "projects"
            referencedColumns: ["id"]
          },
        ]
      }
      cost_estimates: {
        Row: {
          created_at: string | null
          estimate: Json
          id: string
          tenant_id: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          estimate: Json
          id?: string
          tenant_id?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          estimate?: Json
          id?: string
          tenant_id?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "cost_estimates_tenant_id_fkey"
            columns: ["tenant_id"]
            isOneToOne: false
            referencedRelation: "tenants"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "cost_estimates_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      courses: {
        Row: {
          branding_color: string | null
          cover_image_url: string | null
          created_at: string
          description: string | null
          id: string
          is_published: boolean
          owner_id: string
          price_cents: number
          title: string
          updated_at: string
        }
        Insert: {
          branding_color?: string | null
          cover_image_url?: string | null
          created_at?: string
          description?: string | null
          id?: string
          is_published?: boolean
          owner_id: string
          price_cents: number
          title: string
          updated_at?: string
        }
        Update: {
          branding_color?: string | null
          cover_image_url?: string | null
          created_at?: string
          description?: string | null
          id?: string
          is_published?: boolean
          owner_id?: string
          price_cents?: number
          title?: string
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "courses_owner_id_fkey"
            columns: ["owner_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      crisis_alerts: {
        Row: {
          alert_level: string
          alert_message: string
          assessment_id: string | null
          created_at: string
          id: string
          notified_contacts: Json | null
          professional_response: string | null
          resolution_notes: string | null
          resolved_at: string | null
          response_time_minutes: number | null
          status: string
          user_id: string
        }
        Insert: {
          alert_level: string
          alert_message: string
          assessment_id?: string | null
          created_at?: string
          id?: string
          notified_contacts?: Json | null
          professional_response?: string | null
          resolution_notes?: string | null
          resolved_at?: string | null
          response_time_minutes?: number | null
          status?: string
          user_id: string
        }
        Update: {
          alert_level?: string
          alert_message?: string
          assessment_id?: string | null
          created_at?: string
          id?: string
          notified_contacts?: Json | null
          professional_response?: string | null
          resolution_notes?: string | null
          resolved_at?: string | null
          response_time_minutes?: number | null
          status?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "crisis_alerts_assessment_id_fkey"
            columns: ["assessment_id"]
            isOneToOne: false
            referencedRelation: "mental_health_assessments"
            referencedColumns: ["id"]
          },
        ]
      }
      crisis_events: {
        Row: {
          category: string
          confidence: number
          created_at: string | null
          description: string
          escalation_probability: number
          id: string
          region: string
          severity: string
          sources: number
          title: string
        }
        Insert: {
          category: string
          confidence: number
          created_at?: string | null
          description: string
          escalation_probability: number
          id?: string
          region: string
          severity: string
          sources: number
          title: string
        }
        Update: {
          category?: string
          confidence?: number
          created_at?: string | null
          description?: string
          escalation_probability?: number
          id?: string
          region?: string
          severity?: string
          sources?: number
          title?: string
        }
        Relationships: []
      }
      crisis_predictions: {
        Row: {
          confidence: number | null
          created_at: string | null
          expires_at: string | null
          id: string
          indicators: string[] | null
          likelihood: string | null
          prediction_data: Json | null
          recommendations: string[] | null
          region: string
          timeframe: string | null
        }
        Insert: {
          confidence?: number | null
          created_at?: string | null
          expires_at?: string | null
          id?: string
          indicators?: string[] | null
          likelihood?: string | null
          prediction_data?: Json | null
          recommendations?: string[] | null
          region: string
          timeframe?: string | null
        }
        Update: {
          confidence?: number | null
          created_at?: string | null
          expires_at?: string | null
          id?: string
          indicators?: string[] | null
          likelihood?: string | null
          prediction_data?: Json | null
          recommendations?: string[] | null
          region?: string
          timeframe?: string | null
        }
        Relationships: []
      }
      curated_contents: {
        Row: {
          content_json: Json
          curated_at: string | null
          id: string
          source: string | null
          status: string | null
          topic: string | null
          user_id: string
        }
        Insert: {
          content_json: Json
          curated_at?: string | null
          id?: string
          source?: string | null
          status?: string | null
          topic?: string | null
          user_id: string
        }
        Update: {
          content_json?: Json
          curated_at?: string | null
          id?: string
          source?: string | null
          status?: string | null
          topic?: string | null
          user_id?: string
        }
        Relationships: []
      }
      decisions: {
        Row: {
          created_at: string | null
          criteria: Json | null
          description: string | null
          id: string
          options: Json | null
          status: string | null
          title: string
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          criteria?: Json | null
          description?: string | null
          id?: string
          options?: Json | null
          status?: string | null
          title: string
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          criteria?: Json | null
          description?: string | null
          id?: string
          options?: Json | null
          status?: string | null
          title?: string
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      document_chunks: {
        Row: {
          chunk_index: number
          content: string
          created_at: string | null
          document_id: string | null
          embedding: string | null
          id: string
        }
        Insert: {
          chunk_index: number
          content: string
          created_at?: string | null
          document_id?: string | null
          embedding?: string | null
          id?: string
        }
        Update: {
          chunk_index?: number
          content?: string
          created_at?: string | null
          document_id?: string | null
          embedding?: string | null
          id?: string
        }
        Relationships: [
          {
            foreignKeyName: "document_chunks_document_id_fkey"
            columns: ["document_id"]
            isOneToOne: false
            referencedRelation: "documents"
            referencedColumns: ["id"]
          },
        ]
      }
      document_collections: {
        Row: {
          created_at: string
          document_count: number | null
          id: string
          last_ingested_at: string | null
          name: string
          namespace: string
          project_id: string
          updated_at: string
        }
        Insert: {
          created_at?: string
          document_count?: number | null
          id?: string
          last_ingested_at?: string | null
          name: string
          namespace: string
          project_id: string
          updated_at?: string
        }
        Update: {
          created_at?: string
          document_count?: number | null
          id?: string
          last_ingested_at?: string | null
          name?: string
          namespace?: string
          project_id?: string
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "document_collections_project_id_fkey"
            columns: ["project_id"]
            isOneToOne: false
            referencedRelation: "ai_projects"
            referencedColumns: ["id"]
          },
        ]
      }
      documents: {
        Row: {
          created_at: string | null
          filename: string
          id: string
          owner_id: string | null
          tenant_id: string | null
          url: string | null
        }
        Insert: {
          created_at?: string | null
          filename: string
          id?: string
          owner_id?: string | null
          tenant_id?: string | null
          url?: string | null
        }
        Update: {
          created_at?: string | null
          filename?: string
          id?: string
          owner_id?: string | null
          tenant_id?: string | null
          url?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "documents_owner_id_fkey"
            columns: ["owner_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "documents_tenant_id_fkey"
            columns: ["tenant_id"]
            isOneToOne: false
            referencedRelation: "tenants"
            referencedColumns: ["id"]
          },
        ]
      }
      economic_models: {
        Row: {
          created_at: string | null
          id: string
          model_type: string
          parameters: Json
          results: Json | null
          scenario_id: string
        }
        Insert: {
          created_at?: string | null
          id?: string
          model_type: string
          parameters: Json
          results?: Json | null
          scenario_id: string
        }
        Update: {
          created_at?: string | null
          id?: string
          model_type?: string
          parameters?: Json
          results?: Json | null
          scenario_id?: string
        }
        Relationships: []
      }
      ecosystem_insights: {
        Row: {
          created_at: string | null
          expires_at: string | null
          id: string
          insight_data: Json
          insight_type: string
          modules_involved: string[]
          priority_level: number | null
          status: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          expires_at?: string | null
          id?: string
          insight_data: Json
          insight_type: string
          modules_involved: string[]
          priority_level?: number | null
          status?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          expires_at?: string | null
          id?: string
          insight_data?: Json
          insight_type?: string
          modules_involved?: string[]
          priority_level?: number | null
          status?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ecosystem_insights_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "unified_users"
            referencedColumns: ["id"]
          },
        ]
      }
      ecosystem_metrics: {
        Row: {
          agricultural_income: number | null
          business_revenue: number | null
          created_at: string | null
          financial_health_score: number | null
          id: string
          metric_date: string
          overall_ecosystem_score: number | null
          skills_progress_score: number | null
          supply_chain_efficiency_score: number | null
          user_id: string | null
        }
        Insert: {
          agricultural_income?: number | null
          business_revenue?: number | null
          created_at?: string | null
          financial_health_score?: number | null
          id?: string
          metric_date: string
          overall_ecosystem_score?: number | null
          skills_progress_score?: number | null
          supply_chain_efficiency_score?: number | null
          user_id?: string | null
        }
        Update: {
          agricultural_income?: number | null
          business_revenue?: number | null
          created_at?: string | null
          financial_health_score?: number | null
          id?: string
          metric_date?: string
          overall_ecosystem_score?: number | null
          skills_progress_score?: number | null
          supply_chain_efficiency_score?: number | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ecosystem_metrics_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "unified_users"
            referencedColumns: ["id"]
          },
        ]
      }
      email_notification_preferences: {
        Row: {
          created_at: string
          id: string
          receive_collaboration_emails: boolean
          receive_community_emails: boolean
          receive_marketing_emails: boolean
          receive_system_emails: boolean
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          receive_collaboration_emails?: boolean
          receive_community_emails?: boolean
          receive_marketing_emails?: boolean
          receive_system_emails?: boolean
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          receive_collaboration_emails?: boolean
          receive_community_emails?: boolean
          receive_marketing_emails?: boolean
          receive_system_emails?: boolean
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      emergency_contacts: {
        Row: {
          created_at: string | null
          email: string | null
          id: string
          is_primary: boolean | null
          name: string
          phone: string
          relationship: string
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          email?: string | null
          id?: string
          is_primary?: boolean | null
          name: string
          phone: string
          relationship: string
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          email?: string | null
          id?: string
          is_primary?: boolean | null
          name?: string
          phone?: string
          relationship?: string
          user_id?: string | null
        }
        Relationships: []
      }
      emotional_data: {
        Row: {
          cognitive_appraisals: string[] | null
          context: string | null
          created_at: string | null
          emotion: string
          id: string
          intensity: number | null
          llm_analysis: Json | null
          location: string | null
          physical_sensations: string[] | null
          processed_by_llm: boolean | null
          secondary_emotions: string[] | null
          user_id: string | null
        }
        Insert: {
          cognitive_appraisals?: string[] | null
          context?: string | null
          created_at?: string | null
          emotion: string
          id?: string
          intensity?: number | null
          llm_analysis?: Json | null
          location?: string | null
          physical_sensations?: string[] | null
          processed_by_llm?: boolean | null
          secondary_emotions?: string[] | null
          user_id?: string | null
        }
        Update: {
          cognitive_appraisals?: string[] | null
          context?: string | null
          created_at?: string | null
          emotion?: string
          id?: string
          intensity?: number | null
          llm_analysis?: Json | null
          location?: string | null
          physical_sensations?: string[] | null
          processed_by_llm?: boolean | null
          secondary_emotions?: string[] | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "emotional_data_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      emotional_networks: {
        Row: {
          contact_id: string | null
          created_at: string | null
          emotional_influence: string[] | null
          id: string
          impact: string | null
          last_interaction: string | null
          strength: number | null
          user_id: string | null
        }
        Insert: {
          contact_id?: string | null
          created_at?: string | null
          emotional_influence?: string[] | null
          id?: string
          impact?: string | null
          last_interaction?: string | null
          strength?: number | null
          user_id?: string | null
        }
        Update: {
          contact_id?: string | null
          created_at?: string | null
          emotional_influence?: string[] | null
          id?: string
          impact?: string | null
          last_interaction?: string | null
          strength?: number | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "emotional_networks_contact_id_fkey"
            columns: ["contact_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "emotional_networks_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      entanglement_nodes: {
        Row: {
          created_at: string | null
          data: Json | null
          decision_id: string | null
          id: string
          name: string
          position: Json | null
          type: string
        }
        Insert: {
          created_at?: string | null
          data?: Json | null
          decision_id?: string | null
          id?: string
          name: string
          position?: Json | null
          type: string
        }
        Update: {
          created_at?: string | null
          data?: Json | null
          decision_id?: string | null
          id?: string
          name?: string
          position?: Json | null
          type?: string
        }
        Relationships: [
          {
            foreignKeyName: "entanglement_nodes_decision_id_fkey"
            columns: ["decision_id"]
            isOneToOne: false
            referencedRelation: "decisions"
            referencedColumns: ["id"]
          },
        ]
      }
      environmental_assessments: {
        Row: {
          assessment_data: Json
          created_at: string | null
          id: string
          mitigation_steps: Json | null
          risk_level: string | null
          toxins: Json
          user_id: string | null
        }
        Insert: {
          assessment_data: Json
          created_at?: string | null
          id?: string
          mitigation_steps?: Json | null
          risk_level?: string | null
          toxins: Json
          user_id?: string | null
        }
        Update: {
          assessment_data?: Json
          created_at?: string | null
          id?: string
          mitigation_steps?: Json | null
          risk_level?: string | null
          toxins?: Json
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "environmental_assessments_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      event_participants: {
        Row: {
          created_at: string
          emergency_contact: Json | null
          event_id: string
          id: string
          registration_status: string
          special_accommodations: string | null
          user_id: string
        }
        Insert: {
          created_at?: string
          emergency_contact?: Json | null
          event_id: string
          id?: string
          registration_status?: string
          special_accommodations?: string | null
          user_id: string
        }
        Update: {
          created_at?: string
          emergency_contact?: Json | null
          event_id?: string
          id?: string
          registration_status?: string
          special_accommodations?: string | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "event_participants_event_id_fkey"
            columns: ["event_id"]
            isOneToOne: false
            referencedRelation: "community_events"
            referencedColumns: ["id"]
          },
        ]
      }
      family_access: {
        Row: {
          access_level: string | null
          created_at: string | null
          family_member_email: string
          id: string
          is_active: boolean | null
          senior_user_id: string | null
        }
        Insert: {
          access_level?: string | null
          created_at?: string | null
          family_member_email: string
          id?: string
          is_active?: boolean | null
          senior_user_id?: string | null
        }
        Update: {
          access_level?: string | null
          created_at?: string | null
          family_member_email?: string
          id?: string
          is_active?: boolean | null
          senior_user_id?: string | null
        }
        Relationships: []
      }
      financial_profiles: {
        Row: {
          created_at: string | null
          credit_score: number | null
          financial_goals: Json | null
          id: string
          income_sources: Json | null
          insurance_coverage: Json | null
          loan_history: Json | null
          monthly_expenses: number | null
          monthly_income: number | null
          savings_balance: number | null
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          credit_score?: number | null
          financial_goals?: Json | null
          id?: string
          income_sources?: Json | null
          insurance_coverage?: Json | null
          loan_history?: Json | null
          monthly_expenses?: number | null
          monthly_income?: number | null
          savings_balance?: number | null
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          credit_score?: number | null
          financial_goals?: Json | null
          id?: string
          income_sources?: Json | null
          insurance_coverage?: Json | null
          loan_history?: Json | null
          monthly_expenses?: number | null
          monthly_income?: number | null
          savings_balance?: number | null
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "financial_profiles_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "unified_users"
            referencedColumns: ["id"]
          },
        ]
      }
      forecasts: {
        Row: {
          confidence_interval: number[]
          created_at: string | null
          domain: string
          id: string
          models_used: string[]
          probability: number
          problem: string
          rationale: string
          scenario_analysis: Json
          status: string
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          confidence_interval?: number[]
          created_at?: string | null
          domain: string
          id?: string
          models_used?: string[]
          probability: number
          problem: string
          rationale?: string
          scenario_analysis?: Json
          status?: string
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          confidence_interval?: number[]
          created_at?: string | null
          domain?: string
          id?: string
          models_used?: string[]
          probability?: number
          problem?: string
          rationale?: string
          scenario_analysis?: Json
          status?: string
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      generated_code: {
        Row: {
          code_content: Json
          created_at: string | null
          framework: string
          id: string
          language: string
          paper_id: string | null
          user_id: string | null
        }
        Insert: {
          code_content: Json
          created_at?: string | null
          framework: string
          id?: string
          language: string
          paper_id?: string | null
          user_id?: string | null
        }
        Update: {
          code_content?: Json
          created_at?: string | null
          framework?: string
          id?: string
          language?: string
          paper_id?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "generated_code_paper_id_fkey"
            columns: ["paper_id"]
            isOneToOne: false
            referencedRelation: "research_papers"
            referencedColumns: ["id"]
          },
        ]
      }
      generated_websites: {
        Row: {
          about_section: Json
          business_id: string
          contact_section: Json
          generated_at: string
          hero_section: Json
          id: string
          meta_description: string | null
          schema_markup: Json | null
          seo_keywords: string[] | null
          services_section: Json
          status: string | null
          title: string
        }
        Insert: {
          about_section: Json
          business_id: string
          contact_section: Json
          generated_at?: string
          hero_section: Json
          id?: string
          meta_description?: string | null
          schema_markup?: Json | null
          seo_keywords?: string[] | null
          services_section: Json
          status?: string | null
          title: string
        }
        Update: {
          about_section?: Json
          business_id?: string
          contact_section?: Json
          generated_at?: string
          hero_section?: Json
          id?: string
          meta_description?: string | null
          schema_markup?: Json | null
          seo_keywords?: string[] | null
          services_section?: Json
          status?: string | null
          title?: string
        }
        Relationships: [
          {
            foreignKeyName: "generated_websites_business_id_fkey"
            columns: ["business_id"]
            isOneToOne: false
            referencedRelation: "businesses"
            referencedColumns: ["id"]
          },
        ]
      }
      health_checkins: {
        Row: {
          created_at: string | null
          energy_level: number | null
          id: string
          mood_rating: number | null
          notes: string | null
          sleep_quality: number | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          energy_level?: number | null
          id?: string
          mood_rating?: number | null
          notes?: string | null
          sleep_quality?: number | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          energy_level?: number | null
          id?: string
          mood_rating?: number | null
          notes?: string | null
          sleep_quality?: number | null
          user_id?: string | null
        }
        Relationships: []
      }
      historical_events: {
        Row: {
          created_at: string | null
          description: string | null
          economic_impact: number | null
          end_date: string | null
          id: string
          name: string
          region: string
          severity: number
          start_date: string
          total_cases: number | null
          type: string
        }
        Insert: {
          created_at?: string | null
          description?: string | null
          economic_impact?: number | null
          end_date?: string | null
          id?: string
          name: string
          region: string
          severity: number
          start_date: string
          total_cases?: number | null
          type: string
        }
        Update: {
          created_at?: string | null
          description?: string | null
          economic_impact?: number | null
          end_date?: string | null
          id?: string
          name?: string
          region?: string
          severity?: number
          start_date?: string
          total_cases?: number | null
          type?: string
        }
        Relationships: []
      }
      historical_patterns: {
        Row: {
          created_at: string | null
          description: string
          examples: Json
          id: string
          pattern_type: string
          statistical_significance: number | null
        }
        Insert: {
          created_at?: string | null
          description: string
          examples: Json
          id?: string
          pattern_type: string
          statistical_significance?: number | null
        }
        Update: {
          created_at?: string | null
          description?: string
          examples?: Json
          id?: string
          pattern_type?: string
          statistical_significance?: number | null
        }
        Relationships: []
      }
      indicators: {
        Row: {
          id: string
          indicators: Json
          summary: string
          updated_at: string | null
        }
        Insert: {
          id?: string
          indicators?: Json
          summary: string
          updated_at?: string | null
        }
        Update: {
          id?: string
          indicators?: Json
          summary?: string
          updated_at?: string | null
        }
        Relationships: []
      }
      integrations: {
        Row: {
          config: Json
          created_at: string
          id: string
          integration_type: string
          is_active: boolean
          updated_at: string
          user_id: string
        }
        Insert: {
          config?: Json
          created_at?: string
          id?: string
          integration_type: string
          is_active?: boolean
          updated_at?: string
          user_id: string
        }
        Update: {
          config?: Json
          created_at?: string
          id?: string
          integration_type?: string
          is_active?: boolean
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      intervention_tests: {
        Row: {
          created_at: string
          id: string
          interventions: Json
          results: Json | null
          scenario_id: string
          user_id: string | null
        }
        Insert: {
          created_at?: string
          id?: string
          interventions?: Json
          results?: Json | null
          scenario_id: string
          user_id?: string | null
        }
        Update: {
          created_at?: string
          id?: string
          interventions?: Json
          results?: Json | null
          scenario_id?: string
          user_id?: string | null
        }
        Relationships: []
      }
      job_matches: {
        Row: {
          ai_reasoning: string | null
          created_at: string
          id: string
          job_opportunity_id: string
          job_seeker_id: string
          match_score: number
          match_status: string | null
          matching_skills: string[] | null
          skill_gaps: string[] | null
          updated_at: string
        }
        Insert: {
          ai_reasoning?: string | null
          created_at?: string
          id?: string
          job_opportunity_id: string
          job_seeker_id: string
          match_score: number
          match_status?: string | null
          matching_skills?: string[] | null
          skill_gaps?: string[] | null
          updated_at?: string
        }
        Update: {
          ai_reasoning?: string | null
          created_at?: string
          id?: string
          job_opportunity_id?: string
          job_seeker_id?: string
          match_score?: number
          match_status?: string | null
          matching_skills?: string[] | null
          skill_gaps?: string[] | null
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "job_matches_job_opportunity_id_fkey"
            columns: ["job_opportunity_id"]
            isOneToOne: false
            referencedRelation: "job_opportunities"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "job_matches_job_seeker_id_fkey"
            columns: ["job_seeker_id"]
            isOneToOne: false
            referencedRelation: "job_seekers"
            referencedColumns: ["id"]
          },
        ]
      }
      job_opportunities: {
        Row: {
          company_name: string | null
          created_at: string
          description: string
          experience_level: string | null
          expires_at: string | null
          id: string
          is_active: boolean | null
          job_type: string | null
          location: string | null
          posted_at: string
          preferred_skills: string[] | null
          remote_friendly: boolean | null
          required_skills: string[] | null
          salary_range: string | null
          title: string
        }
        Insert: {
          company_name?: string | null
          created_at?: string
          description: string
          experience_level?: string | null
          expires_at?: string | null
          id?: string
          is_active?: boolean | null
          job_type?: string | null
          location?: string | null
          posted_at?: string
          preferred_skills?: string[] | null
          remote_friendly?: boolean | null
          required_skills?: string[] | null
          salary_range?: string | null
          title: string
        }
        Update: {
          company_name?: string | null
          created_at?: string
          description?: string
          experience_level?: string | null
          expires_at?: string | null
          id?: string
          is_active?: boolean | null
          job_type?: string | null
          location?: string | null
          posted_at?: string
          preferred_skills?: string[] | null
          remote_friendly?: boolean | null
          required_skills?: string[] | null
          salary_range?: string | null
          title?: string
        }
        Relationships: []
      }
      job_seekers: {
        Row: {
          created_at: string
          current_job_title: string | null
          desired_roles: string[] | null
          education_level: string | null
          experience_years: number | null
          id: string
          location: string | null
          resume_text: string | null
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          current_job_title?: string | null
          desired_roles?: string[] | null
          education_level?: string | null
          experience_years?: number | null
          id?: string
          location?: string | null
          resume_text?: string | null
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          current_job_title?: string | null
          desired_roles?: string[] | null
          education_level?: string | null
          experience_years?: number | null
          id?: string
          location?: string | null
          resume_text?: string | null
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      lab_results: {
        Row: {
          created_at: string | null
          id: string
          reference_range: string | null
          status: string | null
          test_date: string | null
          test_name: string
          unit: string | null
          user_id: string | null
          value: number | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          reference_range?: string | null
          status?: string | null
          test_date?: string | null
          test_name: string
          unit?: string | null
          user_id?: string | null
          value?: number | null
        }
        Update: {
          created_at?: string | null
          id?: string
          reference_range?: string | null
          status?: string | null
          test_date?: string | null
          test_name?: string
          unit?: string | null
          user_id?: string | null
          value?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "lab_results_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      learning_content: {
        Row: {
          content_data: Json | null
          content_type: string
          content_url: string | null
          created_at: string | null
          created_by: string | null
          description: string | null
          difficulty_level: number | null
          estimated_duration_minutes: number | null
          id: string
          is_active: boolean | null
          prerequisites: string[] | null
          skill_ids: string[] | null
          tags: string[] | null
          title: string
          updated_at: string | null
        }
        Insert: {
          content_data?: Json | null
          content_type: string
          content_url?: string | null
          created_at?: string | null
          created_by?: string | null
          description?: string | null
          difficulty_level?: number | null
          estimated_duration_minutes?: number | null
          id?: string
          is_active?: boolean | null
          prerequisites?: string[] | null
          skill_ids?: string[] | null
          tags?: string[] | null
          title: string
          updated_at?: string | null
        }
        Update: {
          content_data?: Json | null
          content_type?: string
          content_url?: string | null
          created_at?: string | null
          created_by?: string | null
          description?: string | null
          difficulty_level?: number | null
          estimated_duration_minutes?: number | null
          id?: string
          is_active?: boolean | null
          prerequisites?: string[] | null
          skill_ids?: string[] | null
          tags?: string[] | null
          title?: string
          updated_at?: string | null
        }
        Relationships: []
      }
      learning_content_files: {
        Row: {
          content_id: string | null
          file_name: string
          file_path: string
          file_size: number | null
          file_type: string
          id: string
          upload_status: string | null
          uploaded_at: string | null
          uploaded_by: string | null
        }
        Insert: {
          content_id?: string | null
          file_name: string
          file_path: string
          file_size?: number | null
          file_type: string
          id?: string
          upload_status?: string | null
          uploaded_at?: string | null
          uploaded_by?: string | null
        }
        Update: {
          content_id?: string | null
          file_name?: string
          file_path?: string
          file_size?: number | null
          file_type?: string
          id?: string
          upload_status?: string | null
          uploaded_at?: string | null
          uploaded_by?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "learning_content_files_content_id_fkey"
            columns: ["content_id"]
            isOneToOne: false
            referencedRelation: "learning_content"
            referencedColumns: ["id"]
          },
        ]
      }
      learning_path_recommendations: {
        Row: {
          expires_at: string | null
          generated_at: string | null
          id: string
          metadata: Json | null
          priority_score: number | null
          reason: string
          recommended_path_id: string | null
          status: string | null
          user_id: string | null
        }
        Insert: {
          expires_at?: string | null
          generated_at?: string | null
          id?: string
          metadata?: Json | null
          priority_score?: number | null
          reason: string
          recommended_path_id?: string | null
          status?: string | null
          user_id?: string | null
        }
        Update: {
          expires_at?: string | null
          generated_at?: string | null
          id?: string
          metadata?: Json | null
          priority_score?: number | null
          reason?: string
          recommended_path_id?: string | null
          status?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "learning_path_recommendations_recommended_path_id_fkey"
            columns: ["recommended_path_id"]
            isOneToOne: false
            referencedRelation: "learning_paths"
            referencedColumns: ["id"]
          },
        ]
      }
      learning_paths: {
        Row: {
          content_sequence: string[] | null
          created_at: string | null
          created_by: string | null
          description: string | null
          difficulty_level: number | null
          estimated_duration_hours: number | null
          id: string
          is_template: boolean | null
          learning_objectives: string[] | null
          name: string
          prerequisites: Json | null
          target_skill_ids: string[] | null
          updated_at: string | null
        }
        Insert: {
          content_sequence?: string[] | null
          created_at?: string | null
          created_by?: string | null
          description?: string | null
          difficulty_level?: number | null
          estimated_duration_hours?: number | null
          id?: string
          is_template?: boolean | null
          learning_objectives?: string[] | null
          name: string
          prerequisites?: Json | null
          target_skill_ids?: string[] | null
          updated_at?: string | null
        }
        Update: {
          content_sequence?: string[] | null
          created_at?: string | null
          created_by?: string | null
          description?: string | null
          difficulty_level?: number | null
          estimated_duration_hours?: number | null
          id?: string
          is_template?: boolean | null
          learning_objectives?: string[] | null
          name?: string
          prerequisites?: Json | null
          target_skill_ids?: string[] | null
          updated_at?: string | null
        }
        Relationships: []
      }
      learning_progress: {
        Row: {
          completion_percentage: number | null
          id: string
          last_accessed: string | null
          module_id: string
          performance_data: Json | null
          user_id: string | null
        }
        Insert: {
          completion_percentage?: number | null
          id?: string
          last_accessed?: string | null
          module_id: string
          performance_data?: Json | null
          user_id?: string | null
        }
        Update: {
          completion_percentage?: number | null
          id?: string
          last_accessed?: string | null
          module_id?: string
          performance_data?: Json | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "learning_progress_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "user_profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      learning_recommendations: {
        Row: {
          generated_at: string | null
          id: string
          reason: string | null
          recommendation_json: Json
          status: string | null
          user_id: string
        }
        Insert: {
          generated_at?: string | null
          id?: string
          reason?: string | null
          recommendation_json: Json
          status?: string | null
          user_id: string
        }
        Update: {
          generated_at?: string | null
          id?: string
          reason?: string | null
          recommendation_json?: Json
          status?: string | null
          user_id?: string
        }
        Relationships: []
      }
      lesson_modules: {
        Row: {
          content: string | null
          course_id: string
          created_at: string
          id: string
          order_index: number
          status: string
          title: string
          updated_at: string
          video_url: string | null
        }
        Insert: {
          content?: string | null
          course_id: string
          created_at?: string
          id?: string
          order_index?: number
          status?: string
          title: string
          updated_at?: string
          video_url?: string | null
        }
        Update: {
          content?: string | null
          course_id?: string
          created_at?: string
          id?: string
          order_index?: number
          status?: string
          title?: string
          updated_at?: string
          video_url?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "lesson_modules_course_id_fkey"
            columns: ["course_id"]
            isOneToOne: false
            referencedRelation: "courses"
            referencedColumns: ["id"]
          },
        ]
      }
      lesson_progress: {
        Row: {
          completed_at: string | null
          course_id: string | null
          id: string
          is_completed: boolean
          lesson_id: string | null
          updated_at: string
          user_id: string | null
        }
        Insert: {
          completed_at?: string | null
          course_id?: string | null
          id?: string
          is_completed?: boolean
          lesson_id?: string | null
          updated_at?: string
          user_id?: string | null
        }
        Update: {
          completed_at?: string | null
          course_id?: string | null
          id?: string
          is_completed?: boolean
          lesson_id?: string | null
          updated_at?: string
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "lesson_progress_course_id_fkey"
            columns: ["course_id"]
            isOneToOne: false
            referencedRelation: "courses"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "lesson_progress_lesson_id_fkey"
            columns: ["lesson_id"]
            isOneToOne: false
            referencedRelation: "lesson_modules"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "lesson_progress_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      linguistic_analyses: {
        Row: {
          analysis_results: Json
          analysis_type: string
          created_at: string
          cultural_notes: string | null
          gemini_model_used: string | null
          id: string
          insights: string | null
          patterns_identified: string[] | null
          preservation_recommendations: string | null
          processing_time_ms: number | null
          transcription_id: string
          updated_at: string
          user_id: string
        }
        Insert: {
          analysis_results: Json
          analysis_type: string
          created_at?: string
          cultural_notes?: string | null
          gemini_model_used?: string | null
          id?: string
          insights?: string | null
          patterns_identified?: string[] | null
          preservation_recommendations?: string | null
          processing_time_ms?: number | null
          transcription_id: string
          updated_at?: string
          user_id: string
        }
        Update: {
          analysis_results?: Json
          analysis_type?: string
          created_at?: string
          cultural_notes?: string | null
          gemini_model_used?: string | null
          id?: string
          insights?: string | null
          patterns_identified?: string[] | null
          preservation_recommendations?: string | null
          processing_time_ms?: number | null
          transcription_id?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "linguistic_analyses_transcription_id_fkey"
            columns: ["transcription_id"]
            isOneToOne: false
            referencedRelation: "transcriptions"
            referencedColumns: ["id"]
          },
        ]
      }
      llm_providers: {
        Row: {
          config: Json | null
          cost_per_token: number | null
          created_at: string
          enabled: boolean | null
          endpoint_url: string | null
          id: string
          name: string
          provider_type: string
          status: string
          tenant_id: string
          updated_at: string
        }
        Insert: {
          config?: Json | null
          cost_per_token?: number | null
          created_at?: string
          enabled?: boolean | null
          endpoint_url?: string | null
          id?: string
          name: string
          provider_type: string
          status?: string
          tenant_id: string
          updated_at?: string
        }
        Update: {
          config?: Json | null
          cost_per_token?: number | null
          created_at?: string
          enabled?: boolean | null
          endpoint_url?: string | null
          id?: string
          name?: string
          provider_type?: string
          status?: string
          tenant_id?: string
          updated_at?: string
        }
        Relationships: []
      }
      loneliness_assessments: {
        Row: {
          ai_recommendations: Json | null
          assessment_responses: Json
          community_belonging_score: number | null
          created_at: string
          follow_up_date: string | null
          id: string
          intervention_priority: string
          loneliness_score: number
          social_connection_quality: number | null
          user_id: string
        }
        Insert: {
          ai_recommendations?: Json | null
          assessment_responses: Json
          community_belonging_score?: number | null
          created_at?: string
          follow_up_date?: string | null
          id?: string
          intervention_priority?: string
          loneliness_score: number
          social_connection_quality?: number | null
          user_id: string
        }
        Update: {
          ai_recommendations?: Json | null
          assessment_responses?: Json
          community_belonging_score?: number | null
          created_at?: string
          follow_up_date?: string | null
          id?: string
          intervention_priority?: string
          loneliness_score?: number
          social_connection_quality?: number | null
          user_id?: string
        }
        Relationships: []
      }
      loneliness_profiles: {
        Row: {
          availability_schedule: Json | null
          comfort_zones: string[] | null
          communication_style: string | null
          created_at: string
          id: string
          interests: Json | null
          isolation_level: number | null
          life_situation: string[] | null
          life_stage: string | null
          location_data: Json | null
          mobility_considerations: string[] | null
          preferred_activities: Json | null
          seeking_connection_types: string[] | null
          social_anxiety_level: number | null
          updated_at: string
          user_id: string
          values_priorities: Json | null
        }
        Insert: {
          availability_schedule?: Json | null
          comfort_zones?: string[] | null
          communication_style?: string | null
          created_at?: string
          id?: string
          interests?: Json | null
          isolation_level?: number | null
          life_situation?: string[] | null
          life_stage?: string | null
          location_data?: Json | null
          mobility_considerations?: string[] | null
          preferred_activities?: Json | null
          seeking_connection_types?: string[] | null
          social_anxiety_level?: number | null
          updated_at?: string
          user_id: string
          values_priorities?: Json | null
        }
        Update: {
          availability_schedule?: Json | null
          comfort_zones?: string[] | null
          communication_style?: string | null
          created_at?: string
          id?: string
          interests?: Json | null
          isolation_level?: number | null
          life_situation?: string[] | null
          life_stage?: string | null
          location_data?: Json | null
          mobility_considerations?: string[] | null
          preferred_activities?: Json | null
          seeking_connection_types?: string[] | null
          social_anxiety_level?: number | null
          updated_at?: string
          user_id?: string
          values_priorities?: Json | null
        }
        Relationships: []
      }
      medical_chat_messages: {
        Row: {
          content: string
          created_at: string
          id: string
          message_type: string | null
          metadata: Json | null
          role: string
          session_id: string | null
        }
        Insert: {
          content: string
          created_at?: string
          id?: string
          message_type?: string | null
          metadata?: Json | null
          role: string
          session_id?: string | null
        }
        Update: {
          content?: string
          created_at?: string
          id?: string
          message_type?: string | null
          metadata?: Json | null
          role?: string
          session_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "medical_chat_messages_session_id_fkey"
            columns: ["session_id"]
            isOneToOne: false
            referencedRelation: "medical_chat_sessions"
            referencedColumns: ["id"]
          },
        ]
      }
      medical_chat_sessions: {
        Row: {
          created_at: string
          id: string
          image_id: string | null
          session_title: string | null
          updated_at: string
          user_id: string | null
        }
        Insert: {
          created_at?: string
          id?: string
          image_id?: string | null
          session_title?: string | null
          updated_at?: string
          user_id?: string | null
        }
        Update: {
          created_at?: string
          id?: string
          image_id?: string | null
          session_title?: string | null
          updated_at?: string
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "medical_chat_sessions_image_id_fkey"
            columns: ["image_id"]
            isOneToOne: false
            referencedRelation: "medical_images"
            referencedColumns: ["id"]
          },
        ]
      }
      medical_images: {
        Row: {
          body_part: string | null
          created_at: string
          description: string | null
          file_size: number | null
          file_type: string
          file_url: string | null
          id: string
          is_processed: boolean | null
          metadata: Json | null
          modality: string | null
          name: string
          updated_at: string
          upload_date: string
          user_id: string | null
        }
        Insert: {
          body_part?: string | null
          created_at?: string
          description?: string | null
          file_size?: number | null
          file_type: string
          file_url?: string | null
          id?: string
          is_processed?: boolean | null
          metadata?: Json | null
          modality?: string | null
          name: string
          updated_at?: string
          upload_date?: string
          user_id?: string | null
        }
        Update: {
          body_part?: string | null
          created_at?: string
          description?: string | null
          file_size?: number | null
          file_type?: string
          file_url?: string | null
          id?: string
          is_processed?: boolean | null
          metadata?: Json | null
          modality?: string | null
          name?: string
          updated_at?: string
          upload_date?: string
          user_id?: string | null
        }
        Relationships: []
      }
      medical_user_profiles: {
        Row: {
          created_at: string
          experience_level: string | null
          id: string
          institution: string | null
          preferences: Json | null
          role: string
          specialization: string | null
          updated_at: string
          user_id: string | null
        }
        Insert: {
          created_at?: string
          experience_level?: string | null
          id?: string
          institution?: string | null
          preferences?: Json | null
          role?: string
          specialization?: string | null
          updated_at?: string
          user_id?: string | null
        }
        Update: {
          created_at?: string
          experience_level?: string | null
          id?: string
          institution?: string | null
          preferences?: Json | null
          role?: string
          specialization?: string | null
          updated_at?: string
          user_id?: string | null
        }
        Relationships: []
      }
      medication_logs: {
        Row: {
          created_at: string
          id: string
          medication_id: string
          notes: string | null
          status: string
          taken_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          medication_id: string
          notes?: string | null
          status: string
          taken_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          medication_id?: string
          notes?: string | null
          status?: string
          taken_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "medication_logs_medication_id_fkey"
            columns: ["medication_id"]
            isOneToOne: false
            referencedRelation: "medications"
            referencedColumns: ["id"]
          },
        ]
      }
      medications: {
        Row: {
          created_at: string
          dosage: string
          frequency: string
          id: string
          instructions: string | null
          is_active: boolean
          name: string
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          dosage: string
          frequency: string
          id?: string
          instructions?: string | null
          is_active?: boolean
          name: string
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          dosage?: string
          frequency?: string
          id?: string
          instructions?: string | null
          is_active?: boolean
          name?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      mental_health_assessments: {
        Row: {
          analysis_metadata: Json | null
          assessment_type: string
          confidence_score: number
          created_at: string
          id: string
          indicators_detected: Json | null
          input_text: string | null
          intervention_timeline: string | null
          recommended_actions: Json | null
          resources_provided: Json | null
          risk_level: number
          updated_at: string
          user_id: string
        }
        Insert: {
          analysis_metadata?: Json | null
          assessment_type?: string
          confidence_score: number
          created_at?: string
          id?: string
          indicators_detected?: Json | null
          input_text?: string | null
          intervention_timeline?: string | null
          recommended_actions?: Json | null
          resources_provided?: Json | null
          risk_level: number
          updated_at?: string
          user_id: string
        }
        Update: {
          analysis_metadata?: Json | null
          assessment_type?: string
          confidence_score?: number
          created_at?: string
          id?: string
          indicators_detected?: Json | null
          input_text?: string | null
          intervention_timeline?: string | null
          recommended_actions?: Json | null
          resources_provided?: Json | null
          risk_level?: number
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      mental_health_monitoring: {
        Row: {
          baseline_mood_score: number | null
          care_team_alerts: Json | null
          created_at: string
          current_trend: string | null
          emergency_contacts: Json | null
          high_risk_episodes: number | null
          id: string
          last_assessment_date: string | null
          monitoring_active: boolean | null
          total_assessments: number | null
          updated_at: string
          user_id: string
        }
        Insert: {
          baseline_mood_score?: number | null
          care_team_alerts?: Json | null
          created_at?: string
          current_trend?: string | null
          emergency_contacts?: Json | null
          high_risk_episodes?: number | null
          id?: string
          last_assessment_date?: string | null
          monitoring_active?: boolean | null
          total_assessments?: number | null
          updated_at?: string
          user_id: string
        }
        Update: {
          baseline_mood_score?: number | null
          care_team_alerts?: Json | null
          created_at?: string
          current_trend?: string | null
          emergency_contacts?: Json | null
          high_risk_episodes?: number | null
          id?: string
          last_assessment_date?: string | null
          monitoring_active?: boolean | null
          total_assessments?: number | null
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      mental_model_collaborations: {
        Row: {
          comments: Json | null
          created_at: string | null
          id: string
          participants: Json
          problem_id: string | null
          shared_solutions: string[] | null
          status: string | null
          version_history: Json | null
        }
        Insert: {
          comments?: Json | null
          created_at?: string | null
          id?: string
          participants?: Json
          problem_id?: string | null
          shared_solutions?: string[] | null
          status?: string | null
          version_history?: Json | null
        }
        Update: {
          comments?: Json | null
          created_at?: string | null
          id?: string
          participants?: Json
          problem_id?: string | null
          shared_solutions?: string[] | null
          status?: string | null
          version_history?: Json | null
        }
        Relationships: [
          {
            foreignKeyName: "mental_model_collaborations_problem_id_fkey"
            columns: ["problem_id"]
            isOneToOne: false
            referencedRelation: "mental_model_problems"
            referencedColumns: ["id"]
          },
        ]
      }
      mental_model_problems: {
        Row: {
          context: Json | null
          created_at: string | null
          domain: string
          id: string
          problem_text: string
          stakeholders: string[] | null
          structured_data: Json
          urgency: string
          user_id: string | null
        }
        Insert: {
          context?: Json | null
          created_at?: string | null
          domain: string
          id?: string
          problem_text: string
          stakeholders?: string[] | null
          structured_data?: Json
          urgency: string
          user_id?: string | null
        }
        Update: {
          context?: Json | null
          created_at?: string | null
          domain?: string
          id?: string
          problem_text?: string
          stakeholders?: string[] | null
          structured_data?: Json
          urgency?: string
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "mental_model_problems_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "user_profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      mental_model_sessions: {
        Row: {
          created_at: string | null
          expires_at: string
          id: string
          is_guest: boolean | null
          max_requests: number | null
          preferences: Json | null
          problems: string[] | null
          request_count: number | null
          solutions: string[] | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          expires_at: string
          id?: string
          is_guest?: boolean | null
          max_requests?: number | null
          preferences?: Json | null
          problems?: string[] | null
          request_count?: number | null
          solutions?: string[] | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          expires_at?: string
          id?: string
          is_guest?: boolean | null
          max_requests?: number | null
          preferences?: Json | null
          problems?: string[] | null
          request_count?: number | null
          solutions?: string[] | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "mental_model_sessions_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "user_profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      mental_model_solutions: {
        Row: {
          bias_analysis: Json
          complexity_level: string
          created_at: string | null
          export_formats: Json | null
          id: string
          model_id: string | null
          problem_id: string | null
          solution_variants: Json
          stakeholder_views: Json | null
          user_rating: number | null
        }
        Insert: {
          bias_analysis?: Json
          complexity_level: string
          created_at?: string | null
          export_formats?: Json | null
          id?: string
          model_id?: string | null
          problem_id?: string | null
          solution_variants?: Json
          stakeholder_views?: Json | null
          user_rating?: number | null
        }
        Update: {
          bias_analysis?: Json
          complexity_level?: string
          created_at?: string | null
          export_formats?: Json | null
          id?: string
          model_id?: string | null
          problem_id?: string | null
          solution_variants?: Json
          stakeholder_views?: Json | null
          user_rating?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "mental_model_solutions_model_id_fkey"
            columns: ["model_id"]
            isOneToOne: false
            referencedRelation: "mental_models"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "mental_model_solutions_problem_id_fkey"
            columns: ["problem_id"]
            isOneToOne: false
            referencedRelation: "mental_model_problems"
            referencedColumns: ["id"]
          },
        ]
      }
      mental_models: {
        Row: {
          application_scenarios: string[]
          case_study: string | null
          category: string
          complexity_score: number
          created_at: string | null
          description: string
          id: string
          limitations: string[] | null
          name: string
          performance_metrics: Json
          prompt_template: string
          updated_at: string | null
        }
        Insert: {
          application_scenarios?: string[]
          case_study?: string | null
          category: string
          complexity_score: number
          created_at?: string | null
          description: string
          id: string
          limitations?: string[] | null
          name: string
          performance_metrics?: Json
          prompt_template: string
          updated_at?: string | null
        }
        Update: {
          application_scenarios?: string[]
          case_study?: string | null
          category?: string
          complexity_score?: number
          created_at?: string | null
          description?: string
          id?: string
          limitations?: string[] | null
          name?: string
          performance_metrics?: Json
          prompt_template?: string
          updated_at?: string | null
        }
        Relationships: []
      }
      messages: {
        Row: {
          agent_id: string
          content: string
          created_at: string
          id: string
          metadata: Json | null
          project_id: string
          role: string
        }
        Insert: {
          agent_id: string
          content: string
          created_at?: string
          id?: string
          metadata?: Json | null
          project_id: string
          role: string
        }
        Update: {
          agent_id?: string
          content?: string
          created_at?: string
          id?: string
          metadata?: Json | null
          project_id?: string
          role?: string
        }
        Relationships: [
          {
            foreignKeyName: "messages_agent_id_fkey"
            columns: ["agent_id"]
            isOneToOne: false
            referencedRelation: "agents"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "messages_project_id_fkey"
            columns: ["project_id"]
            isOneToOne: false
            referencedRelation: "projects"
            referencedColumns: ["id"]
          },
        ]
      }
      model_performance: {
        Row: {
          accuracy_score: number
          calibration_score: number
          correct_predictions: number
          created_at: string | null
          domain: string
          id: string
          model_name: string
          total_predictions: number
          updated_at: string | null
        }
        Insert: {
          accuracy_score: number
          calibration_score: number
          correct_predictions?: number
          created_at?: string | null
          domain: string
          id?: string
          model_name: string
          total_predictions?: number
          updated_at?: string | null
        }
        Update: {
          accuracy_score?: number
          calibration_score?: number
          correct_predictions?: number
          created_at?: string | null
          domain?: string
          id?: string
          model_name?: string
          total_predictions?: number
          updated_at?: string | null
        }
        Relationships: []
      }
      model_performance_tracking: {
        Row: {
          created_at: string | null
          id: string
          model_id: string | null
          problem_domain: string
          solution_effectiveness: number | null
          time_to_solution: number | null
          user_feedback: string | null
          user_rating: number | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          model_id?: string | null
          problem_domain: string
          solution_effectiveness?: number | null
          time_to_solution?: number | null
          user_feedback?: string | null
          user_rating?: number | null
        }
        Update: {
          created_at?: string | null
          id?: string
          model_id?: string | null
          problem_domain?: string
          solution_effectiveness?: number | null
          time_to_solution?: number | null
          user_feedback?: string | null
          user_rating?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "model_performance_tracking_model_id_fkey"
            columns: ["model_id"]
            isOneToOne: false
            referencedRelation: "mental_models"
            referencedColumns: ["id"]
          },
        ]
      }
      news_feeds: {
        Row: {
          created_at: string | null
          id: string
          published_at: string
          relevance_score: number
          sentiment: string
          source: string
          summary: string
          title: string
          topics: string[]
        }
        Insert: {
          created_at?: string | null
          id?: string
          published_at: string
          relevance_score: number
          sentiment: string
          source: string
          summary: string
          title: string
          topics?: string[]
        }
        Update: {
          created_at?: string | null
          id?: string
          published_at?: string
          relevance_score?: number
          sentiment?: string
          source?: string
          summary?: string
          title?: string
          topics?: string[]
        }
        Relationships: []
      }
      notification_logs: {
        Row: {
          alert_id: string | null
          channel: string
          error_message: string | null
          id: string
          sent_at: string
          status: string
          user_id: string | null
        }
        Insert: {
          alert_id?: string | null
          channel: string
          error_message?: string | null
          id?: string
          sent_at?: string
          status: string
          user_id?: string | null
        }
        Update: {
          alert_id?: string | null
          channel?: string
          error_message?: string | null
          id?: string
          sent_at?: string
          status?: string
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "notification_logs_alert_id_fkey"
            columns: ["alert_id"]
            isOneToOne: false
            referencedRelation: "alerts"
            referencedColumns: ["id"]
          },
        ]
      }
      notification_preferences: {
        Row: {
          analysis_complete: boolean
          created_at: string
          email_notifications: boolean
          id: string
          push_notifications: boolean
          share_notifications: boolean
          system_updates: boolean
          updated_at: string
          user_id: string
          weekly_summary: boolean
        }
        Insert: {
          analysis_complete?: boolean
          created_at?: string
          email_notifications?: boolean
          id?: string
          push_notifications?: boolean
          share_notifications?: boolean
          system_updates?: boolean
          updated_at?: string
          user_id: string
          weekly_summary?: boolean
        }
        Update: {
          analysis_complete?: boolean
          created_at?: string
          email_notifications?: boolean
          id?: string
          push_notifications?: boolean
          share_notifications?: boolean
          system_updates?: boolean
          updated_at?: string
          user_id?: string
          weekly_summary?: boolean
        }
        Relationships: []
      }
      notification_templates: {
        Row: {
          created_at: string | null
          id: string
          is_active: boolean | null
          name: string
          template_body: string
          template_subject: string
          type: string
          variables: Json | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          is_active?: boolean | null
          name: string
          template_body: string
          template_subject: string
          type: string
          variables?: Json | null
        }
        Update: {
          created_at?: string | null
          id?: string
          is_active?: boolean | null
          name?: string
          template_body?: string
          template_subject?: string
          type?: string
          variables?: Json | null
        }
        Relationships: []
      }
      notifications: {
        Row: {
          created_at: string | null
          id: string
          message: string
          metadata: Json | null
          read: boolean | null
          title: string
          type: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          message: string
          metadata?: Json | null
          read?: boolean | null
          title: string
          type?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          message?: string
          metadata?: Json | null
          read?: boolean | null
          title?: string
          type?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      orders: {
        Row: {
          amount: number | null
          course_id: string | null
          created_at: string
          currency: string | null
          id: string
          status: string | null
          stripe_session_id: string | null
          updated_at: string
          user_id: string | null
        }
        Insert: {
          amount?: number | null
          course_id?: string | null
          created_at?: string
          currency?: string | null
          id?: string
          status?: string | null
          stripe_session_id?: string | null
          updated_at?: string
          user_id?: string | null
        }
        Update: {
          amount?: number | null
          course_id?: string | null
          created_at?: string
          currency?: string | null
          id?: string
          status?: string | null
          stripe_session_id?: string | null
          updated_at?: string
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "orders_course_id_fkey"
            columns: ["course_id"]
            isOneToOne: false
            referencedRelation: "courses"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "orders_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      paper_uploads: {
        Row: {
          created_at: string
          file_size: number
          file_type: string
          filename: string
          id: string
          processing_metadata: Json | null
          storage_path: string
          updated_at: string
          upload_status: string | null
          user_id: string
        }
        Insert: {
          created_at?: string
          file_size: number
          file_type: string
          filename: string
          id?: string
          processing_metadata?: Json | null
          storage_path: string
          updated_at?: string
          upload_status?: string | null
          user_id: string
        }
        Update: {
          created_at?: string
          file_size?: number
          file_type?: string
          filename?: string
          id?: string
          processing_metadata?: Json | null
          storage_path?: string
          updated_at?: string
          upload_status?: string | null
          user_id?: string
        }
        Relationships: []
      }
      personal_reminders: {
        Row: {
          created_at: string | null
          description: string | null
          id: string
          is_active: boolean | null
          reminder_days: number[] | null
          reminder_time: string
          reminder_type: string | null
          title: string
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          description?: string | null
          id?: string
          is_active?: boolean | null
          reminder_days?: number[] | null
          reminder_time: string
          reminder_type?: string | null
          title: string
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          description?: string | null
          id?: string
          is_active?: boolean | null
          reminder_days?: number[] | null
          reminder_time?: string
          reminder_type?: string | null
          title?: string
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      physiological_data: {
        Row: {
          body_temperature: number | null
          created_at: string | null
          heart_rate: number | null
          id: string
          llm_analysis: Json | null
          location: string | null
          movement_level: number | null
          processed_by_llm: boolean | null
          respiration_rate: number | null
          skin_conductance: number | null
          sleep_quality: number | null
          user_id: string | null
        }
        Insert: {
          body_temperature?: number | null
          created_at?: string | null
          heart_rate?: number | null
          id?: string
          llm_analysis?: Json | null
          location?: string | null
          movement_level?: number | null
          processed_by_llm?: boolean | null
          respiration_rate?: number | null
          skin_conductance?: number | null
          sleep_quality?: number | null
          user_id?: string | null
        }
        Update: {
          body_temperature?: number | null
          created_at?: string | null
          heart_rate?: number | null
          id?: string
          llm_analysis?: Json | null
          location?: string | null
          movement_level?: number | null
          processed_by_llm?: boolean | null
          respiration_rate?: number | null
          skin_conductance?: number | null
          sleep_quality?: number | null
          user_id?: string | null
        }
        Relationships: []
      }
      portfolio_wave_status: {
        Row: {
          current_wave_type: string | null
          id: string
          last_updated: string | null
          risk_level: string | null
          symbol: string
          trend_direction: string | null
          user_id: string | null
          wave_position: string | null
        }
        Insert: {
          current_wave_type?: string | null
          id?: string
          last_updated?: string | null
          risk_level?: string | null
          symbol: string
          trend_direction?: string | null
          user_id?: string | null
          wave_position?: string | null
        }
        Update: {
          current_wave_type?: string | null
          id?: string
          last_updated?: string | null
          risk_level?: string | null
          symbol?: string
          trend_direction?: string | null
          user_id?: string | null
          wave_position?: string | null
        }
        Relationships: []
      }
      prediction_shares: {
        Row: {
          created_at: string
          expires_at: string | null
          id: string
          is_active: boolean
          prediction_id: string
          share_token: string
          user_id: string
        }
        Insert: {
          created_at?: string
          expires_at?: string | null
          id?: string
          is_active?: boolean
          prediction_id: string
          share_token: string
          user_id: string
        }
        Update: {
          created_at?: string
          expires_at?: string | null
          id?: string
          is_active?: boolean
          prediction_id?: string
          share_token?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "prediction_shares_prediction_id_fkey"
            columns: ["prediction_id"]
            isOneToOne: false
            referencedRelation: "predictions"
            referencedColumns: ["id"]
          },
        ]
      }
      predictions: {
        Row: {
          automation_date: string
          confidence: string
          created_at: string
          drivers: string[]
          id: string
          industry: string
          job_title: string
          skills: string[]
          user_id: string
        }
        Insert: {
          automation_date: string
          confidence: string
          created_at?: string
          drivers: string[]
          id?: string
          industry: string
          job_title: string
          skills: string[]
          user_id: string
        }
        Update: {
          automation_date?: string
          confidence?: string
          created_at?: string
          drivers?: string[]
          id?: string
          industry?: string
          job_title?: string
          skills?: string[]
          user_id?: string
        }
        Relationships: []
      }
      profiles: {
        Row: {
          api_credits: number | null
          avatar_url: string | null
          created_at: string
          email: string | null
          full_name: string | null
          id: string
          subscription_tier: string | null
          updated_at: string
        }
        Insert: {
          api_credits?: number | null
          avatar_url?: string | null
          created_at?: string
          email?: string | null
          full_name?: string | null
          id: string
          subscription_tier?: string | null
          updated_at?: string
        }
        Update: {
          api_credits?: number | null
          avatar_url?: string | null
          created_at?: string
          email?: string | null
          full_name?: string | null
          id?: string
          subscription_tier?: string | null
          updated_at?: string
        }
        Relationships: []
      }
      progress_entries: {
        Row: {
          created_at: string | null
          date: string
          energy_level: number | null
          id: string
          mood_score: number | null
          notes: string | null
          symptoms: Json
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          date: string
          energy_level?: number | null
          id?: string
          mood_score?: number | null
          notes?: string | null
          symptoms: Json
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          date?: string
          energy_level?: number | null
          id?: string
          mood_score?: number | null
          notes?: string | null
          symptoms?: Json
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "progress_entries_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      progress_sessions: {
        Row: {
          completed: boolean
          created_at: string
          hints_used: number
          id: string
          problem_text: string
          subject: string
          time_spent: number
          updated_at: string
          user_id: string
        }
        Insert: {
          completed?: boolean
          created_at?: string
          hints_used?: number
          id?: string
          problem_text: string
          subject: string
          time_spent?: number
          updated_at?: string
          user_id: string
        }
        Update: {
          completed?: boolean
          created_at?: string
          hints_used?: number
          id?: string
          problem_text?: string
          subject?: string
          time_spent?: number
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      project_analytics: {
        Row: {
          active_agents: number | null
          ai_interactions: number | null
          completion_percentage: number | null
          created_at: string
          date: string
          files_uploaded: number | null
          id: string
          project_id: string
          time_spent_minutes: number | null
          total_messages: number | null
          user_id: string
        }
        Insert: {
          active_agents?: number | null
          ai_interactions?: number | null
          completion_percentage?: number | null
          created_at?: string
          date?: string
          files_uploaded?: number | null
          id?: string
          project_id: string
          time_spent_minutes?: number | null
          total_messages?: number | null
          user_id: string
        }
        Update: {
          active_agents?: number | null
          ai_interactions?: number | null
          completion_percentage?: number | null
          created_at?: string
          date?: string
          files_uploaded?: number | null
          id?: string
          project_id?: string
          time_spent_minutes?: number | null
          total_messages?: number | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "project_analytics_project_id_fkey"
            columns: ["project_id"]
            isOneToOne: false
            referencedRelation: "projects"
            referencedColumns: ["id"]
          },
        ]
      }
      project_files: {
        Row: {
          analysis_results: Json | null
          analysis_status: string | null
          created_at: string
          file_name: string
          file_size: number
          file_type: string
          id: string
          project_id: string
          storage_path: string
          updated_at: string
          user_id: string
        }
        Insert: {
          analysis_results?: Json | null
          analysis_status?: string | null
          created_at?: string
          file_name: string
          file_size: number
          file_type: string
          id?: string
          project_id: string
          storage_path: string
          updated_at?: string
          user_id: string
        }
        Update: {
          analysis_results?: Json | null
          analysis_status?: string | null
          created_at?: string
          file_name?: string
          file_size?: number
          file_type?: string
          id?: string
          project_id?: string
          storage_path?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "project_files_project_id_fkey"
            columns: ["project_id"]
            isOneToOne: false
            referencedRelation: "projects"
            referencedColumns: ["id"]
          },
        ]
      }
      project_templates: {
        Row: {
          created_at: string
          created_by: string | null
          description: string
          id: string
          is_public: boolean
          name: string
          template_data: Json
          updated_at: string
        }
        Insert: {
          created_at?: string
          created_by?: string | null
          description: string
          id?: string
          is_public?: boolean
          name: string
          template_data?: Json
          updated_at?: string
        }
        Update: {
          created_at?: string
          created_by?: string | null
          description?: string
          id?: string
          is_public?: boolean
          name?: string
          template_data?: Json
          updated_at?: string
        }
        Relationships: []
      }
      projects: {
        Row: {
          created_at: string
          description: string | null
          id: string
          is_public: boolean
          name: string
          project_id: string | null
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          description?: string | null
          id?: string
          is_public?: boolean
          name: string
          project_id?: string | null
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          description?: string | null
          id?: string
          is_public?: boolean
          name?: string
          project_id?: string | null
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      prompt_optimizations: {
        Row: {
          applied: boolean | null
          created_at: string | null
          id: string
          impact_score: number | null
          suggestion: string
          suggestion_type: string
          template_id: string | null
          user_id: string | null
        }
        Insert: {
          applied?: boolean | null
          created_at?: string | null
          id?: string
          impact_score?: number | null
          suggestion: string
          suggestion_type: string
          template_id?: string | null
          user_id?: string | null
        }
        Update: {
          applied?: boolean | null
          created_at?: string | null
          id?: string
          impact_score?: number | null
          suggestion?: string
          suggestion_type?: string
          template_id?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "prompt_optimizations_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "prompt_templates"
            referencedColumns: ["id"]
          },
        ]
      }
      prompt_templates: {
        Row: {
          category: string | null
          components: Json | null
          created_at: string | null
          created_by: string | null
          description: string | null
          id: string
          industry: string | null
          is_public: boolean | null
          name: string
          performance: Json | null
          rating: number | null
          tags: string[] | null
          test_cases: Json | null
          updated_at: string | null
          usage_count: number | null
          user_id: string | null
          variables: Json | null
        }
        Insert: {
          category?: string | null
          components?: Json | null
          created_at?: string | null
          created_by?: string | null
          description?: string | null
          id?: string
          industry?: string | null
          is_public?: boolean | null
          name: string
          performance?: Json | null
          rating?: number | null
          tags?: string[] | null
          test_cases?: Json | null
          updated_at?: string | null
          usage_count?: number | null
          user_id?: string | null
          variables?: Json | null
        }
        Update: {
          category?: string | null
          components?: Json | null
          created_at?: string | null
          created_by?: string | null
          description?: string | null
          id?: string
          industry?: string | null
          is_public?: boolean | null
          name?: string
          performance?: Json | null
          rating?: number | null
          tags?: string[] | null
          test_cases?: Json | null
          updated_at?: string | null
          usage_count?: number | null
          user_id?: string | null
          variables?: Json | null
        }
        Relationships: []
      }
      prompt_test_cases: {
        Row: {
          actual_output: string | null
          created_at: string | null
          expected_output: string | null
          id: string
          inputs: Json | null
          last_tested: string | null
          metrics: Json | null
          name: string
          score: number | null
          template_id: string | null
          user_id: string | null
        }
        Insert: {
          actual_output?: string | null
          created_at?: string | null
          expected_output?: string | null
          id?: string
          inputs?: Json | null
          last_tested?: string | null
          metrics?: Json | null
          name: string
          score?: number | null
          template_id?: string | null
          user_id?: string | null
        }
        Update: {
          actual_output?: string | null
          created_at?: string | null
          expected_output?: string | null
          id?: string
          inputs?: Json | null
          last_tested?: string | null
          metrics?: Json | null
          name?: string
          score?: number | null
          template_id?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "prompt_test_cases_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "prompt_templates"
            referencedColumns: ["id"]
          },
        ]
      }
      prompt_test_results: {
        Row: {
          cost: number | null
          created_at: string | null
          execution_time_ms: number | null
          id: string
          metrics: Json | null
          model_used: string | null
          output: string
          template_id: string | null
          test_case_id: string | null
          tokens_used: number | null
          user_id: string | null
        }
        Insert: {
          cost?: number | null
          created_at?: string | null
          execution_time_ms?: number | null
          id?: string
          metrics?: Json | null
          model_used?: string | null
          output: string
          template_id?: string | null
          test_case_id?: string | null
          tokens_used?: number | null
          user_id?: string | null
        }
        Update: {
          cost?: number | null
          created_at?: string | null
          execution_time_ms?: number | null
          id?: string
          metrics?: Json | null
          model_used?: string | null
          output?: string
          template_id?: string | null
          test_case_id?: string | null
          tokens_used?: number | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "prompt_test_results_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "prompt_templates"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "prompt_test_results_test_case_id_fkey"
            columns: ["test_case_id"]
            isOneToOne: false
            referencedRelation: "prompt_test_cases"
            referencedColumns: ["id"]
          },
        ]
      }
      protocol_reminders: {
        Row: {
          created_at: string | null
          description: string | null
          enabled: boolean | null
          frequency: string
          id: string
          protocol_id: string
          time: string
          title: string
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          description?: string | null
          enabled?: boolean | null
          frequency: string
          id?: string
          protocol_id: string
          time: string
          title: string
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          description?: string | null
          enabled?: boolean | null
          frequency?: string
          id?: string
          protocol_id?: string
          time?: string
          title?: string
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "protocol_reminders_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      protocols: {
        Row: {
          actions: Json
          created_at: string | null
          expected_outcomes: Json | null
          id: string
          root_cause_id: string
          status: string | null
          timeline: string | null
          title: string
          user_id: string | null
        }
        Insert: {
          actions: Json
          created_at?: string | null
          expected_outcomes?: Json | null
          id?: string
          root_cause_id: string
          status?: string | null
          timeline?: string | null
          title: string
          user_id?: string | null
        }
        Update: {
          actions?: Json
          created_at?: string | null
          expected_outcomes?: Json | null
          id?: string
          root_cause_id?: string
          status?: string | null
          timeline?: string | null
          title?: string
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "protocols_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      purchases: {
        Row: {
          course_id: string
          created_at: string
          id: string
          stripe_session_id: string | null
          user_id: string
        }
        Insert: {
          course_id: string
          created_at?: string
          id?: string
          stripe_session_id?: string | null
          user_id: string
        }
        Update: {
          course_id?: string
          created_at?: string
          id?: string
          stripe_session_id?: string | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "purchases_course_id_fkey"
            columns: ["course_id"]
            isOneToOne: false
            referencedRelation: "courses"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "purchases_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      push_subscriptions: {
        Row: {
          created_at: string | null
          id: string
          subscription: Json
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          subscription: Json
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          subscription?: Json
          user_id?: string | null
        }
        Relationships: []
      }
      quiz_attempts: {
        Row: {
          completed_at: string | null
          created_at: string
          id: string
          quiz_id: string | null
          responses: Json | null
          score: number | null
          user_id: string | null
        }
        Insert: {
          completed_at?: string | null
          created_at?: string
          id?: string
          quiz_id?: string | null
          responses?: Json | null
          score?: number | null
          user_id?: string | null
        }
        Update: {
          completed_at?: string | null
          created_at?: string
          id?: string
          quiz_id?: string | null
          responses?: Json | null
          score?: number | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "quiz_attempts_quiz_id_fkey"
            columns: ["quiz_id"]
            isOneToOne: false
            referencedRelation: "quizzes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "quiz_attempts_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      quiz_modules: {
        Row: {
          ai_model: string | null
          created_at: string
          id: string
          lesson_id: string
          questions: Json | null
          status: string
        }
        Insert: {
          ai_model?: string | null
          created_at?: string
          id?: string
          lesson_id: string
          questions?: Json | null
          status?: string
        }
        Update: {
          ai_model?: string | null
          created_at?: string
          id?: string
          lesson_id?: string
          questions?: Json | null
          status?: string
        }
        Relationships: [
          {
            foreignKeyName: "quiz_modules_lesson_id_fkey"
            columns: ["lesson_id"]
            isOneToOne: false
            referencedRelation: "lesson_modules"
            referencedColumns: ["id"]
          },
        ]
      }
      quizzes: {
        Row: {
          created_at: string
          id: string
          lesson_id: string | null
          questions: Json | null
          status: string
        }
        Insert: {
          created_at?: string
          id?: string
          lesson_id?: string | null
          questions?: Json | null
          status?: string
        }
        Update: {
          created_at?: string
          id?: string
          lesson_id?: string | null
          questions?: Json | null
          status?: string
        }
        Relationships: [
          {
            foreignKeyName: "quizzes_lesson_id_fkey"
            columns: ["lesson_id"]
            isOneToOne: false
            referencedRelation: "lesson_modules"
            referencedColumns: ["id"]
          },
        ]
      }
      rag_queries: {
        Row: {
          created_at: string
          id: string
          llm_provider: string | null
          project_id: string
          query_text: string
          response_text: string | null
          response_time_ms: number | null
          retrieved_chunks: Json | null
          tokens_used: number | null
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          llm_provider?: string | null
          project_id: string
          query_text: string
          response_text?: string | null
          response_time_ms?: number | null
          retrieved_chunks?: Json | null
          tokens_used?: number | null
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          llm_provider?: string | null
          project_id?: string
          query_text?: string
          response_text?: string | null
          response_time_ms?: number | null
          retrieved_chunks?: Json | null
          tokens_used?: number | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "rag_queries_project_id_fkey"
            columns: ["project_id"]
            isOneToOne: false
            referencedRelation: "ai_projects"
            referencedColumns: ["id"]
          },
        ]
      }
      renewai_ai_insights: {
        Row: {
          confidence_score: number | null
          content: string
          created_at: string | null
          id: string
          insight_type: string
          is_active: boolean | null
          metadata: Json | null
          title: string
          user_id: string
        }
        Insert: {
          confidence_score?: number | null
          content: string
          created_at?: string | null
          id?: string
          insight_type: string
          is_active?: boolean | null
          metadata?: Json | null
          title: string
          user_id: string
        }
        Update: {
          confidence_score?: number | null
          content?: string
          created_at?: string | null
          id?: string
          insight_type?: string
          is_active?: boolean | null
          metadata?: Json | null
          title?: string
          user_id?: string
        }
        Relationships: []
      }
      renewai_energy_data: {
        Row: {
          created_at: string | null
          energy_type: string
          id: string
          metadata: Json | null
          timestamp: string | null
          unit: string
          user_id: string
          value: number
        }
        Insert: {
          created_at?: string | null
          energy_type: string
          id?: string
          metadata?: Json | null
          timestamp?: string | null
          unit?: string
          user_id: string
          value: number
        }
        Update: {
          created_at?: string | null
          energy_type?: string
          id?: string
          metadata?: Json | null
          timestamp?: string | null
          unit?: string
          user_id?: string
          value?: number
        }
        Relationships: []
      }
      renewai_notifications: {
        Row: {
          created_at: string | null
          id: string
          is_read: boolean | null
          message: string
          metadata: Json | null
          title: string
          type: string | null
          user_id: string
        }
        Insert: {
          created_at?: string | null
          id?: string
          is_read?: boolean | null
          message: string
          metadata?: Json | null
          title: string
          type?: string | null
          user_id: string
        }
        Update: {
          created_at?: string | null
          id?: string
          is_read?: boolean | null
          message?: string
          metadata?: Json | null
          title?: string
          type?: string | null
          user_id?: string
        }
        Relationships: []
      }
      research_papers: {
        Row: {
          analysis: Json | null
          content: string
          created_at: string | null
          file_size: number | null
          filename: string
          id: string
          title: string
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          analysis?: Json | null
          content: string
          created_at?: string | null
          file_size?: number | null
          filename: string
          id?: string
          title: string
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          analysis?: Json | null
          content?: string
          created_at?: string | null
          file_size?: number | null
          filename?: string
          id?: string
          title?: string
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      reskilling_paths: {
        Row: {
          completion_percentage: number | null
          created_at: string
          estimated_duration_weeks: number | null
          id: string
          job_seeker_id: string
          path_status: string | null
          recommended_courses: Json | null
          skill_gaps: Json | null
          target_job_role: string
          updated_at: string
        }
        Insert: {
          completion_percentage?: number | null
          created_at?: string
          estimated_duration_weeks?: number | null
          id?: string
          job_seeker_id: string
          path_status?: string | null
          recommended_courses?: Json | null
          skill_gaps?: Json | null
          target_job_role: string
          updated_at?: string
        }
        Update: {
          completion_percentage?: number | null
          created_at?: string
          estimated_duration_weeks?: number | null
          id?: string
          job_seeker_id?: string
          path_status?: string | null
          recommended_courses?: Json | null
          skill_gaps?: Json | null
          target_job_role?: string
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "reskilling_paths_job_seeker_id_fkey"
            columns: ["job_seeker_id"]
            isOneToOne: false
            referencedRelation: "job_seekers"
            referencedColumns: ["id"]
          },
        ]
      }
      risk_assessments: {
        Row: {
          confidence_interval: Json
          created_at: string | null
          expires_at: string
          factors: Json
          id: string
          region: string
          risk_score: number
        }
        Insert: {
          confidence_interval: Json
          created_at?: string | null
          expires_at: string
          factors: Json
          id?: string
          region: string
          risk_score: number
        }
        Update: {
          confidence_interval?: Json
          created_at?: string | null
          expires_at?: string
          factors?: Json
          id?: string
          region?: string
          risk_score?: number
        }
        Relationships: []
      }
      saved_analyses: {
        Row: {
          analysis_data: Json
          created_at: string
          id: string
          notes: string | null
          occupation_code: string
          occupation_title: string
          tags: string[] | null
          updated_at: string
          user_id: string
        }
        Insert: {
          analysis_data: Json
          created_at?: string
          id?: string
          notes?: string | null
          occupation_code: string
          occupation_title: string
          tags?: string[] | null
          updated_at?: string
          user_id: string
        }
        Update: {
          analysis_data?: Json
          created_at?: string
          id?: string
          notes?: string | null
          occupation_code?: string
          occupation_title?: string
          tags?: string[] | null
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      scenario_simulations: {
        Row: {
          created_at: string | null
          id: string
          results: Json | null
          scenario_config: Json
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          results?: Json | null
          scenario_config: Json
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          results?: Json | null
          scenario_config?: Json
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "scenario_simulations_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "user_profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      scenarios: {
        Row: {
          created_at: string | null
          data: Json | null
          decision_id: string | null
          description: string | null
          id: string
          impact: number | null
          name: string
          probability: number | null
        }
        Insert: {
          created_at?: string | null
          data?: Json | null
          decision_id?: string | null
          description?: string | null
          id?: string
          impact?: number | null
          name: string
          probability?: number | null
        }
        Update: {
          created_at?: string | null
          data?: Json | null
          decision_id?: string | null
          description?: string | null
          id?: string
          impact?: number | null
          name?: string
          probability?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "scenarios_decision_id_fkey"
            columns: ["decision_id"]
            isOneToOne: false
            referencedRelation: "decisions"
            referencedColumns: ["id"]
          },
        ]
      }
      scheduled_audits: {
        Row: {
          created_at: string
          email_notifications: boolean | null
          frequency: Database["public"]["Enums"]["audit_frequency"]
          id: string
          is_active: boolean
          last_run_at: string | null
          next_run_at: string
          updated_at: string
          url: string
          user_id: string
        }
        Insert: {
          created_at?: string
          email_notifications?: boolean | null
          frequency: Database["public"]["Enums"]["audit_frequency"]
          id?: string
          is_active?: boolean
          last_run_at?: string | null
          next_run_at: string
          updated_at?: string
          url: string
          user_id: string
        }
        Update: {
          created_at?: string
          email_notifications?: boolean | null
          frequency?: Database["public"]["Enums"]["audit_frequency"]
          id?: string
          is_active?: boolean
          last_run_at?: string | null
          next_run_at?: string
          updated_at?: string
          url?: string
          user_id?: string
        }
        Relationships: []
      }
      search_history: {
        Row: {
          id: string
          results_count: number | null
          search_term: string
          searched_at: string
          user_id: string
        }
        Insert: {
          id?: string
          results_count?: number | null
          search_term: string
          searched_at?: string
          user_id: string
        }
        Update: {
          id?: string
          results_count?: number | null
          search_term?: string
          searched_at?: string
          user_id?: string
        }
        Relationships: []
      }
      sentiment_data: {
        Row: {
          created_at: string | null
          id: string
          platform: string
          region: string
          sentiment_score: number
          topics: Json
          volume: number
        }
        Insert: {
          created_at?: string | null
          id?: string
          platform: string
          region: string
          sentiment_score: number
          topics: Json
          volume: number
        }
        Update: {
          created_at?: string | null
          id?: string
          platform?: string
          region?: string
          sentiment_score?: number
          topics?: Json
          volume?: number
        }
        Relationships: []
      }
      shared_analyses: {
        Row: {
          analysis_id: string
          created_at: string
          expires_at: string | null
          id: string
          is_active: boolean
          max_views: number | null
          share_token: string
          share_type: string
          shared_with_email: string | null
          updated_at: string
          user_id: string
          view_count: number
        }
        Insert: {
          analysis_id: string
          created_at?: string
          expires_at?: string | null
          id?: string
          is_active?: boolean
          max_views?: number | null
          share_token?: string
          share_type?: string
          shared_with_email?: string | null
          updated_at?: string
          user_id: string
          view_count?: number
        }
        Update: {
          analysis_id?: string
          created_at?: string
          expires_at?: string | null
          id?: string
          is_active?: boolean
          max_views?: number | null
          share_token?: string
          share_type?: string
          shared_with_email?: string | null
          updated_at?: string
          user_id?: string
          view_count?: number
        }
        Relationships: [
          {
            foreignKeyName: "shared_analyses_analysis_id_fkey"
            columns: ["analysis_id"]
            isOneToOne: false
            referencedRelation: "saved_analyses"
            referencedColumns: ["id"]
          },
        ]
      }
      shared_resources: {
        Row: {
          access_level: string
          created_at: string | null
          expires_at: string | null
          id: string
          is_public: boolean | null
          name: string
          resource_id: string
          resource_type: string
          share_token: string | null
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          access_level: string
          created_at?: string | null
          expires_at?: string | null
          id?: string
          is_public?: boolean | null
          name: string
          resource_id: string
          resource_type: string
          share_token?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          access_level?: string
          created_at?: string | null
          expires_at?: string | null
          id?: string
          is_public?: boolean | null
          name?: string
          resource_id?: string
          resource_type?: string
          share_token?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      similar_papers: {
        Row: {
          created_at: string | null
          id: string
          paper_id: string | null
          search_query: string | null
          similar_papers: Json
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          paper_id?: string | null
          search_query?: string | null
          similar_papers: Json
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          paper_id?: string | null
          search_query?: string | null
          similar_papers?: Json
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "similar_papers_paper_id_fkey"
            columns: ["paper_id"]
            isOneToOne: false
            referencedRelation: "research_papers"
            referencedColumns: ["id"]
          },
        ]
      }
      simulations: {
        Row: {
          city_id: string
          created_at: string | null
          id: string
          parameters: Json
          results: Json
          type: string
        }
        Insert: {
          city_id: string
          created_at?: string | null
          id?: string
          parameters?: Json
          results?: Json
          type: string
        }
        Update: {
          city_id?: string
          created_at?: string | null
          id?: string
          parameters?: Json
          results?: Json
          type?: string
        }
        Relationships: [
          {
            foreignKeyName: "simulations_city_id_fkey"
            columns: ["city_id"]
            isOneToOne: false
            referencedRelation: "cities"
            referencedColumns: ["id"]
          },
        ]
      }
      skill_analytics: {
        Row: {
          created_at: string | null
          id: string
          metadata: Json | null
          metric_type: string
          metric_value: number
          period_end: string
          period_start: string
          skill_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          metadata?: Json | null
          metric_type: string
          metric_value: number
          period_end: string
          period_start: string
          skill_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          metadata?: Json | null
          metric_type?: string
          metric_value?: number
          period_end?: string
          period_start?: string
          skill_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "skill_analytics_skill_id_fkey"
            columns: ["skill_id"]
            isOneToOne: false
            referencedRelation: "skills"
            referencedColumns: ["id"]
          },
        ]
      }
      skill_assessment_sessions: {
        Row: {
          completed_at: string | null
          created_at: string | null
          feedback: string | null
          id: string
          responses: Json | null
          score: number | null
          started_at: string | null
          status: string | null
          template_id: string | null
          time_spent_minutes: number | null
          user_id: string | null
        }
        Insert: {
          completed_at?: string | null
          created_at?: string | null
          feedback?: string | null
          id?: string
          responses?: Json | null
          score?: number | null
          started_at?: string | null
          status?: string | null
          template_id?: string | null
          time_spent_minutes?: number | null
          user_id?: string | null
        }
        Update: {
          completed_at?: string | null
          created_at?: string | null
          feedback?: string | null
          id?: string
          responses?: Json | null
          score?: number | null
          started_at?: string | null
          status?: string | null
          template_id?: string | null
          time_spent_minutes?: number | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "skill_assessment_sessions_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "skill_assessment_templates"
            referencedColumns: ["id"]
          },
        ]
      }
      skill_assessment_templates: {
        Row: {
          assessment_type: string
          created_at: string | null
          created_by: string | null
          description: string | null
          difficulty_level: number | null
          id: string
          is_active: boolean | null
          name: string
          passing_score: number | null
          questions: Json | null
          skill_id: string | null
          time_limit_minutes: number | null
          updated_at: string | null
        }
        Insert: {
          assessment_type?: string
          created_at?: string | null
          created_by?: string | null
          description?: string | null
          difficulty_level?: number | null
          id?: string
          is_active?: boolean | null
          name: string
          passing_score?: number | null
          questions?: Json | null
          skill_id?: string | null
          time_limit_minutes?: number | null
          updated_at?: string | null
        }
        Update: {
          assessment_type?: string
          created_at?: string | null
          created_by?: string | null
          description?: string | null
          difficulty_level?: number | null
          id?: string
          is_active?: boolean | null
          name?: string
          passing_score?: number | null
          questions?: Json | null
          skill_id?: string | null
          time_limit_minutes?: number | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "skill_assessment_templates_skill_id_fkey"
            columns: ["skill_id"]
            isOneToOne: false
            referencedRelation: "skills"
            referencedColumns: ["id"]
          },
        ]
      }
      skill_assessments: {
        Row: {
          assessment_method: string | null
          confidence_score: number | null
          created_at: string
          id: string
          identified_skills: Json | null
          job_seeker_id: string
          skill_levels: Json | null
          updated_at: string
        }
        Insert: {
          assessment_method?: string | null
          confidence_score?: number | null
          created_at?: string
          id?: string
          identified_skills?: Json | null
          job_seeker_id: string
          skill_levels?: Json | null
          updated_at?: string
        }
        Update: {
          assessment_method?: string | null
          confidence_score?: number | null
          created_at?: string
          id?: string
          identified_skills?: Json | null
          job_seeker_id?: string
          skill_levels?: Json | null
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "skill_assessments_job_seeker_id_fkey"
            columns: ["job_seeker_id"]
            isOneToOne: false
            referencedRelation: "job_seekers"
            referencedColumns: ["id"]
          },
        ]
      }
      skill_gap_analyses: {
        Row: {
          analysis_type: string
          created_at: string | null
          gap_data: Json
          generated_at: string | null
          id: string
          priority_score: number | null
          recommendations: Json | null
          reviewed_at: string | null
          status: string | null
          team_id: string | null
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          analysis_type: string
          created_at?: string | null
          gap_data: Json
          generated_at?: string | null
          id?: string
          priority_score?: number | null
          recommendations?: Json | null
          reviewed_at?: string | null
          status?: string | null
          team_id?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          analysis_type?: string
          created_at?: string | null
          gap_data?: Json
          generated_at?: string | null
          id?: string
          priority_score?: number | null
          recommendations?: Json | null
          reviewed_at?: string | null
          status?: string | null
          team_id?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "skill_gap_analyses_team_id_fkey"
            columns: ["team_id"]
            isOneToOne: false
            referencedRelation: "teams"
            referencedColumns: ["id"]
          },
        ]
      }
      skill_progress: {
        Row: {
          skill: string
          status: string | null
          updated_at: string | null
          user_id: string
        }
        Insert: {
          skill: string
          status?: string | null
          updated_at?: string | null
          user_id: string
        }
        Update: {
          skill?: string
          status?: string | null
          updated_at?: string | null
          user_id?: string
        }
        Relationships: []
      }
      skill_recommendations: {
        Row: {
          created_at: string | null
          id: number
          occupation: string | null
          recommendations: Json | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: number
          occupation?: string | null
          recommendations?: Json | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: number
          occupation?: string | null
          recommendations?: Json | null
          user_id?: string | null
        }
        Relationships: []
      }
      skill_requests: {
        Row: {
          category: string
          created_at: string
          description: string | null
          id: string
          industry_tags: string[] | null
          skill_name: string
          status: string
          updated_at: string
          user_id: string
        }
        Insert: {
          category: string
          created_at?: string
          description?: string | null
          id?: string
          industry_tags?: string[] | null
          skill_name: string
          status?: string
          updated_at?: string
          user_id: string
        }
        Update: {
          category?: string
          created_at?: string
          description?: string | null
          id?: string
          industry_tags?: string[] | null
          skill_name?: string
          status?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      skills: {
        Row: {
          category: string
          created_at: string | null
          description: string | null
          id: string
          industry_tags: string[] | null
          level_definitions: Json | null
          name: string
          updated_at: string | null
        }
        Insert: {
          category: string
          created_at?: string | null
          description?: string | null
          id?: string
          industry_tags?: string[] | null
          level_definitions?: Json | null
          name: string
          updated_at?: string | null
        }
        Update: {
          category?: string
          created_at?: string | null
          description?: string | null
          id?: string
          industry_tags?: string[] | null
          level_definitions?: Json | null
          name?: string
          updated_at?: string | null
        }
        Relationships: []
      }
      skills_profiles: {
        Row: {
          career_goals: string[] | null
          certifications: Json | null
          completed_courses: Json | null
          created_at: string | null
          current_enrollments: Json | null
          id: string
          learning_preferences: Json | null
          skill_categories: string[] | null
          time_availability: number | null
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          career_goals?: string[] | null
          certifications?: Json | null
          completed_courses?: Json | null
          created_at?: string | null
          current_enrollments?: Json | null
          id?: string
          learning_preferences?: Json | null
          skill_categories?: string[] | null
          time_availability?: number | null
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          career_goals?: string[] | null
          certifications?: Json | null
          completed_courses?: Json | null
          created_at?: string | null
          current_enrollments?: Json | null
          id?: string
          learning_preferences?: Json | null
          skill_categories?: string[] | null
          time_availability?: number | null
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "skills_profiles_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "unified_users"
            referencedColumns: ["id"]
          },
        ]
      }
      structures: {
        Row: {
          city_id: string
          created_at: string | null
          footprint: string | null
          green_elements: string[] | null
          height: number | null
          id: string
          materials: string[] | null
          position: Json
          type: string
          updated_at: string | null
        }
        Insert: {
          city_id: string
          created_at?: string | null
          footprint?: string | null
          green_elements?: string[] | null
          height?: number | null
          id?: string
          materials?: string[] | null
          position?: Json
          type: string
          updated_at?: string | null
        }
        Update: {
          city_id?: string
          created_at?: string | null
          footprint?: string | null
          green_elements?: string[] | null
          height?: number | null
          id?: string
          materials?: string[] | null
          position?: Json
          type?: string
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "structures_city_id_fkey"
            columns: ["city_id"]
            isOneToOne: false
            referencedRelation: "cities"
            referencedColumns: ["id"]
          },
        ]
      }
      student_progress: {
        Row: {
          completed_at: string | null
          course_id: string
          id: string
          is_completed: boolean
          lesson_id: string
          quiz_score: number | null
          updated_at: string
          user_id: string
        }
        Insert: {
          completed_at?: string | null
          course_id: string
          id?: string
          is_completed?: boolean
          lesson_id: string
          quiz_score?: number | null
          updated_at?: string
          user_id: string
        }
        Update: {
          completed_at?: string | null
          course_id?: string
          id?: string
          is_completed?: boolean
          lesson_id?: string
          quiz_score?: number | null
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "student_progress_course_id_fkey"
            columns: ["course_id"]
            isOneToOne: false
            referencedRelation: "courses"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "student_progress_lesson_id_fkey"
            columns: ["lesson_id"]
            isOneToOne: false
            referencedRelation: "lesson_modules"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "student_progress_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      summaries: {
        Row: {
          content: Json
          created_at: string | null
          id: string
          paper_id: string | null
          target_age: number
          user_id: string | null
        }
        Insert: {
          content: Json
          created_at?: string | null
          id?: string
          paper_id?: string | null
          target_age: number
          user_id?: string | null
        }
        Update: {
          content?: Json
          created_at?: string | null
          id?: string
          paper_id?: string | null
          target_age?: number
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "summaries_paper_id_fkey"
            columns: ["paper_id"]
            isOneToOne: false
            referencedRelation: "research_papers"
            referencedColumns: ["id"]
          },
        ]
      }
      supply_chain_profiles: {
        Row: {
          created_at: string | null
          customer_base: Json | null
          id: string
          inventory_categories: string[] | null
          logistics_preferences: Json | null
          marketplace_participation: string[] | null
          storage_capacity: number | null
          supplier_network: Json | null
          transportation_access: Json | null
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          customer_base?: Json | null
          id?: string
          inventory_categories?: string[] | null
          logistics_preferences?: Json | null
          marketplace_participation?: string[] | null
          storage_capacity?: number | null
          supplier_network?: Json | null
          transportation_access?: Json | null
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          customer_base?: Json | null
          id?: string
          inventory_categories?: string[] | null
          logistics_preferences?: Json | null
          marketplace_participation?: string[] | null
          storage_capacity?: number | null
          supplier_network?: Json | null
          transportation_access?: Json | null
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "supply_chain_profiles_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "unified_users"
            referencedColumns: ["id"]
          },
        ]
      }
      swarm_members: {
        Row: {
          id: string
          joined_at: string | null
          role: string | null
          strengths: string[] | null
          swarm_id: string | null
          user_id: string | null
        }
        Insert: {
          id?: string
          joined_at?: string | null
          role?: string | null
          strengths?: string[] | null
          swarm_id?: string | null
          user_id?: string | null
        }
        Update: {
          id?: string
          joined_at?: string | null
          role?: string | null
          strengths?: string[] | null
          swarm_id?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "swarm_members_swarm_id_fkey"
            columns: ["swarm_id"]
            isOneToOne: false
            referencedRelation: "therapeutic_swarms"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "swarm_members_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      symptoms: {
        Row: {
          created_at: string | null
          duration: string | null
          frequency: string | null
          id: string
          name: string
          notes: string | null
          severity: number | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          duration?: string | null
          frequency?: string | null
          id?: string
          name: string
          notes?: string | null
          severity?: number | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          duration?: string | null
          frequency?: string | null
          id?: string
          name?: string
          notes?: string | null
          severity?: number | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "symptoms_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      system_configurations: {
        Row: {
          config_key: string
          config_value: Json
          created_at: string | null
          description: string | null
          id: string
          is_public: boolean | null
          updated_at: string | null
        }
        Insert: {
          config_key: string
          config_value: Json
          created_at?: string | null
          description?: string | null
          id?: string
          is_public?: boolean | null
          updated_at?: string | null
        }
        Update: {
          config_key?: string
          config_value?: Json
          created_at?: string | null
          description?: string | null
          id?: string
          is_public?: boolean | null
          updated_at?: string | null
        }
        Relationships: []
      }
      system_health: {
        Row: {
          checked_at: string | null
          error_message: string | null
          id: string
          metadata: Json | null
          response_time_ms: number | null
          service_name: string
          status: string
        }
        Insert: {
          checked_at?: string | null
          error_message?: string | null
          id?: string
          metadata?: Json | null
          response_time_ms?: number | null
          service_name: string
          status: string
        }
        Update: {
          checked_at?: string | null
          error_message?: string | null
          id?: string
          metadata?: Json | null
          response_time_ms?: number | null
          service_name?: string
          status?: string
        }
        Relationships: []
      }
      system_metrics: {
        Row: {
          id: string
          metric_name: string
          metric_type: string
          metric_value: number
          recorded_at: string | null
          tags: Json | null
        }
        Insert: {
          id?: string
          metric_name: string
          metric_type: string
          metric_value: number
          recorded_at?: string | null
          tags?: Json | null
        }
        Update: {
          id?: string
          metric_name?: string
          metric_type?: string
          metric_value?: number
          recorded_at?: string | null
          tags?: Json | null
        }
        Relationships: []
      }
      system_settings: {
        Row: {
          created_at: string
          description: string | null
          id: string
          is_public: boolean
          setting_key: string
          setting_value: Json
          updated_at: string
        }
        Insert: {
          created_at?: string
          description?: string | null
          id?: string
          is_public?: boolean
          setting_key: string
          setting_value: Json
          updated_at?: string
        }
        Update: {
          created_at?: string
          description?: string | null
          id?: string
          is_public?: boolean
          setting_key?: string
          setting_value?: Json
          updated_at?: string
        }
        Relationships: []
      }
      team_members: {
        Row: {
          id: string
          is_active: boolean | null
          joined_at: string | null
          role: string | null
          team_id: string | null
          user_id: string | null
        }
        Insert: {
          id?: string
          is_active?: boolean | null
          joined_at?: string | null
          role?: string | null
          team_id?: string | null
          user_id?: string | null
        }
        Update: {
          id?: string
          is_active?: boolean | null
          joined_at?: string | null
          role?: string | null
          team_id?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "team_members_team_id_fkey"
            columns: ["team_id"]
            isOneToOne: false
            referencedRelation: "teams"
            referencedColumns: ["id"]
          },
        ]
      }
      team_skill_matrices: {
        Row: {
          created_at: string | null
          current_avg_level: number | null
          id: string
          last_updated: string | null
          priority: string | null
          required_level: number
          skill_gap_score: number | null
          skill_id: string | null
          team_id: string | null
        }
        Insert: {
          created_at?: string | null
          current_avg_level?: number | null
          id?: string
          last_updated?: string | null
          priority?: string | null
          required_level?: number
          skill_gap_score?: number | null
          skill_id?: string | null
          team_id?: string | null
        }
        Update: {
          created_at?: string | null
          current_avg_level?: number | null
          id?: string
          last_updated?: string | null
          priority?: string | null
          required_level?: number
          skill_gap_score?: number | null
          skill_id?: string | null
          team_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "team_skill_matrices_skill_id_fkey"
            columns: ["skill_id"]
            isOneToOne: false
            referencedRelation: "skills"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "team_skill_matrices_team_id_fkey"
            columns: ["team_id"]
            isOneToOne: false
            referencedRelation: "teams"
            referencedColumns: ["id"]
          },
        ]
      }
      teams: {
        Row: {
          created_at: string | null
          department: string | null
          description: string | null
          id: string
          manager_id: string | null
          name: string
          skill_requirements: Json | null
          team_goals: Json | null
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          department?: string | null
          description?: string | null
          id?: string
          manager_id?: string | null
          name: string
          skill_requirements?: Json | null
          team_goals?: Json | null
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          department?: string | null
          description?: string | null
          id?: string
          manager_id?: string | null
          name?: string
          skill_requirements?: Json | null
          team_goals?: Json | null
          updated_at?: string | null
        }
        Relationships: []
      }
      tenants: {
        Row: {
          created_at: string | null
          id: string
          name: string
        }
        Insert: {
          created_at?: string | null
          id?: string
          name: string
        }
        Update: {
          created_at?: string | null
          id?: string
          name?: string
        }
        Relationships: []
      }
      test_recommendations: {
        Row: {
          created_at: string | null
          details: string | null
          estimated_cost: number | null
          id: string
          name: string
          priority: string | null
          purpose: string
          status: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          details?: string | null
          estimated_cost?: number | null
          id?: string
          name: string
          priority?: string | null
          purpose: string
          status?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          details?: string | null
          estimated_cost?: number | null
          id?: string
          name?: string
          priority?: string | null
          purpose?: string
          status?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "test_recommendations_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      therapeutic_swarms: {
        Row: {
          created_at: string | null
          description: string | null
          facilitator_id: string | null
          focus: string
          id: string
          is_active: boolean | null
          max_members: number | null
          meeting_schedule: string | null
          name: string
          next_meeting: string | null
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          description?: string | null
          facilitator_id?: string | null
          focus: string
          id?: string
          is_active?: boolean | null
          max_members?: number | null
          meeting_schedule?: string | null
          name: string
          next_meeting?: string | null
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          description?: string | null
          facilitator_id?: string | null
          focus?: string
          id?: string
          is_active?: boolean | null
          max_members?: number | null
          meeting_schedule?: string | null
          name?: string
          next_meeting?: string | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "therapeutic_swarms_facilitator_id_fkey"
            columns: ["facilitator_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      transcriptions: {
        Row: {
          audio_file_id: string
          character_count: number | null
          confidence_score: number | null
          created_at: string
          gemini_model_used: string | null
          id: string
          language: string
          metadata: Json | null
          processing_status: string | null
          processing_time_ms: number | null
          transcript_text: string
          updated_at: string
          user_id: string
          word_count: number | null
        }
        Insert: {
          audio_file_id: string
          character_count?: number | null
          confidence_score?: number | null
          created_at?: string
          gemini_model_used?: string | null
          id?: string
          language: string
          metadata?: Json | null
          processing_status?: string | null
          processing_time_ms?: number | null
          transcript_text: string
          updated_at?: string
          user_id: string
          word_count?: number | null
        }
        Update: {
          audio_file_id?: string
          character_count?: number | null
          confidence_score?: number | null
          created_at?: string
          gemini_model_used?: string | null
          id?: string
          language?: string
          metadata?: Json | null
          processing_status?: string | null
          processing_time_ms?: number | null
          transcript_text?: string
          updated_at?: string
          user_id?: string
          word_count?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "transcriptions_audio_file_id_fkey"
            columns: ["audio_file_id"]
            isOneToOne: false
            referencedRelation: "audio_files"
            referencedColumns: ["id"]
          },
        ]
      }
      transformations: {
        Row: {
          created_at: string | null
          data: Json | null
          decision_id: string | null
          id: string
          name: string
          stage: string | null
          type: string
        }
        Insert: {
          created_at?: string | null
          data?: Json | null
          decision_id?: string | null
          id?: string
          name: string
          stage?: string | null
          type: string
        }
        Update: {
          created_at?: string | null
          data?: Json | null
          decision_id?: string | null
          id?: string
          name?: string
          stage?: string | null
          type?: string
        }
        Relationships: [
          {
            foreignKeyName: "transformations_decision_id_fkey"
            columns: ["decision_id"]
            isOneToOne: false
            referencedRelation: "decisions"
            referencedColumns: ["id"]
          },
        ]
      }
      translations: {
        Row: {
          confidence_score: number | null
          created_at: string
          gemini_model_used: string | null
          id: string
          metadata: Json | null
          processing_time_ms: number | null
          source_language: string
          target_language: string
          transcription_id: string
          translated_text: string
          translation_quality: string | null
          updated_at: string
          user_id: string
        }
        Insert: {
          confidence_score?: number | null
          created_at?: string
          gemini_model_used?: string | null
          id?: string
          metadata?: Json | null
          processing_time_ms?: number | null
          source_language: string
          target_language: string
          transcription_id: string
          translated_text: string
          translation_quality?: string | null
          updated_at?: string
          user_id: string
        }
        Update: {
          confidence_score?: number | null
          created_at?: string
          gemini_model_used?: string | null
          id?: string
          metadata?: Json | null
          processing_time_ms?: number | null
          source_language?: string
          target_language?: string
          transcription_id?: string
          translated_text?: string
          translation_quality?: string | null
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "translations_transcription_id_fkey"
            columns: ["transcription_id"]
            isOneToOne: false
            referencedRelation: "transcriptions"
            referencedColumns: ["id"]
          },
        ]
      }
      tutorial_progress: {
        Row: {
          completed_at: string | null
          created_at: string | null
          id: string
          is_correct: boolean | null
          step_number: number
          tutorial_type: string
          user_id: string | null
          user_labels: Json | null
        }
        Insert: {
          completed_at?: string | null
          created_at?: string | null
          id?: string
          is_correct?: boolean | null
          step_number: number
          tutorial_type?: string
          user_id?: string | null
          user_labels?: Json | null
        }
        Update: {
          completed_at?: string | null
          created_at?: string | null
          id?: string
          is_correct?: boolean | null
          step_number?: number
          tutorial_type?: string
          user_id?: string | null
          user_labels?: Json | null
        }
        Relationships: []
      }
      unified_chat_history: {
        Row: {
          ai_response: string
          context_data: Json | null
          id: string
          module_context: string | null
          response_quality_score: number | null
          session_id: string
          timestamp: string | null
          user_id: string | null
          user_message: string
        }
        Insert: {
          ai_response: string
          context_data?: Json | null
          id?: string
          module_context?: string | null
          response_quality_score?: number | null
          session_id: string
          timestamp?: string | null
          user_id?: string | null
          user_message: string
        }
        Update: {
          ai_response?: string
          context_data?: Json | null
          id?: string
          module_context?: string | null
          response_quality_score?: number | null
          session_id?: string
          timestamp?: string | null
          user_id?: string | null
          user_message?: string
        }
        Relationships: [
          {
            foreignKeyName: "unified_chat_history_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "unified_users"
            referencedColumns: ["id"]
          },
        ]
      }
      unified_users: {
        Row: {
          created_at: string | null
          ecosystem_tier: string | null
          email: string
          full_name: string
          id: string
          language_preference: string | null
          location: Json
          phone: string | null
          profile_completion_score: number | null
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          ecosystem_tier?: string | null
          email: string
          full_name: string
          id?: string
          language_preference?: string | null
          location?: Json
          phone?: string | null
          profile_completion_score?: number | null
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          ecosystem_tier?: string | null
          email?: string
          full_name?: string
          id?: string
          language_preference?: string | null
          location?: Json
          phone?: string | null
          profile_completion_score?: number | null
          updated_at?: string | null
        }
        Relationships: []
      }
      user_career_progress: {
        Row: {
          completed_at: string | null
          created_at: string
          id: string
          module_id: string | null
          notes: string | null
          progress_percentage: number | null
          time_spent_minutes: number | null
          transition_id: string | null
          updated_at: string
          user_id: string
        }
        Insert: {
          completed_at?: string | null
          created_at?: string
          id?: string
          module_id?: string | null
          notes?: string | null
          progress_percentage?: number | null
          time_spent_minutes?: number | null
          transition_id?: string | null
          updated_at?: string
          user_id: string
        }
        Update: {
          completed_at?: string | null
          created_at?: string
          id?: string
          module_id?: string | null
          notes?: string | null
          progress_percentage?: number | null
          time_spent_minutes?: number | null
          transition_id?: string | null
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "user_career_progress_module_id_fkey"
            columns: ["module_id"]
            isOneToOne: false
            referencedRelation: "career_learning_modules"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "user_career_progress_transition_id_fkey"
            columns: ["transition_id"]
            isOneToOne: false
            referencedRelation: "career_transitions"
            referencedColumns: ["id"]
          },
        ]
      }
      user_certifications: {
        Row: {
          certification_id: string | null
          created_at: string | null
          credential_id: string | null
          earned_at: string | null
          expires_at: string | null
          id: string
          status: string | null
          updated_at: string | null
          user_id: string | null
          verification_url: string | null
        }
        Insert: {
          certification_id?: string | null
          created_at?: string | null
          credential_id?: string | null
          earned_at?: string | null
          expires_at?: string | null
          id?: string
          status?: string | null
          updated_at?: string | null
          user_id?: string | null
          verification_url?: string | null
        }
        Update: {
          certification_id?: string | null
          created_at?: string | null
          credential_id?: string | null
          earned_at?: string | null
          expires_at?: string | null
          id?: string
          status?: string | null
          updated_at?: string | null
          user_id?: string | null
          verification_url?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "user_certifications_certification_id_fkey"
            columns: ["certification_id"]
            isOneToOne: false
            referencedRelation: "certifications"
            referencedColumns: ["id"]
          },
        ]
      }
      user_chart_preferences: {
        Row: {
          device_type: string | null
          id: string
          synchronized_timeframes: string[] | null
          updated_at: string | null
          user_id: string | null
          wave_overlay_style: Json | null
          zoom_sync_enabled: boolean | null
        }
        Insert: {
          device_type?: string | null
          id?: string
          synchronized_timeframes?: string[] | null
          updated_at?: string | null
          user_id?: string | null
          wave_overlay_style?: Json | null
          zoom_sync_enabled?: boolean | null
        }
        Update: {
          device_type?: string | null
          id?: string
          synchronized_timeframes?: string[] | null
          updated_at?: string | null
          user_id?: string | null
          wave_overlay_style?: Json | null
          zoom_sync_enabled?: boolean | null
        }
        Relationships: []
      }
      user_credits: {
        Row: {
          available_credits: number | null
          created_at: string | null
          id: string
          last_billing_date: string | null
          subscription_tier: string | null
          total_spent: number | null
          updated_at: string | null
          user_id: string
        }
        Insert: {
          available_credits?: number | null
          created_at?: string | null
          id?: string
          last_billing_date?: string | null
          subscription_tier?: string | null
          total_spent?: number | null
          updated_at?: string | null
          user_id: string
        }
        Update: {
          available_credits?: number | null
          created_at?: string | null
          id?: string
          last_billing_date?: string | null
          subscription_tier?: string | null
          total_spent?: number | null
          updated_at?: string | null
          user_id?: string
        }
        Relationships: []
      }
      user_data_exports: {
        Row: {
          completed_at: string | null
          expires_at: string | null
          export_type: string
          file_path: string | null
          file_size: number | null
          id: string
          requested_at: string | null
          status: string
          user_id: string
        }
        Insert: {
          completed_at?: string | null
          expires_at?: string | null
          export_type: string
          file_path?: string | null
          file_size?: number | null
          id?: string
          requested_at?: string | null
          status?: string
          user_id: string
        }
        Update: {
          completed_at?: string | null
          expires_at?: string | null
          export_type?: string
          file_path?: string | null
          file_size?: number | null
          id?: string
          requested_at?: string | null
          status?: string
          user_id?: string
        }
        Relationships: []
      }
      user_engagement_events: {
        Row: {
          event_type: string
          id: string
          metadata: Json | null
          occurred_at: string | null
          user_id: string
        }
        Insert: {
          event_type: string
          id?: string
          metadata?: Json | null
          occurred_at?: string | null
          user_id: string
        }
        Update: {
          event_type?: string
          id?: string
          metadata?: Json | null
          occurred_at?: string | null
          user_id?: string
        }
        Relationships: []
      }
      user_engagement_metrics: {
        Row: {
          analyses_performed: number | null
          created_at: string
          date: string
          exports_performed: number | null
          features_used: string[] | null
          id: string
          pages_visited: number | null
          searches_conducted: number | null
          shares_created: number | null
          time_spent_minutes: number | null
          updated_at: string
          user_id: string
        }
        Insert: {
          analyses_performed?: number | null
          created_at?: string
          date?: string
          exports_performed?: number | null
          features_used?: string[] | null
          id?: string
          pages_visited?: number | null
          searches_conducted?: number | null
          shares_created?: number | null
          time_spent_minutes?: number | null
          updated_at?: string
          user_id: string
        }
        Update: {
          analyses_performed?: number | null
          created_at?: string
          date?: string
          exports_performed?: number | null
          features_used?: string[] | null
          id?: string
          pages_visited?: number | null
          searches_conducted?: number | null
          shares_created?: number | null
          time_spent_minutes?: number | null
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      user_feedback: {
        Row: {
          admin_response: string | null
          admin_user_id: string | null
          attachments: string[] | null
          browser_info: Json | null
          category: string | null
          created_at: string
          description: string
          feedback_type: string
          id: string
          priority: string
          resolved_at: string | null
          status: string
          title: string
          updated_at: string
          url_context: string | null
          user_id: string
        }
        Insert: {
          admin_response?: string | null
          admin_user_id?: string | null
          attachments?: string[] | null
          browser_info?: Json | null
          category?: string | null
          created_at?: string
          description: string
          feedback_type: string
          id?: string
          priority?: string
          resolved_at?: string | null
          status?: string
          title: string
          updated_at?: string
          url_context?: string | null
          user_id: string
        }
        Update: {
          admin_response?: string | null
          admin_user_id?: string | null
          attachments?: string[] | null
          browser_info?: Json | null
          category?: string | null
          created_at?: string
          description?: string
          feedback_type?: string
          id?: string
          priority?: string
          resolved_at?: string | null
          status?: string
          title?: string
          updated_at?: string
          url_context?: string | null
          user_id?: string
        }
        Relationships: []
      }
      user_learning_paths: {
        Row: {
          completed_at: string | null
          created_at: string | null
          id: string
          learning_path_id: string | null
          progress_percentage: number | null
          started_at: string | null
          status: string | null
          target_completion_date: string | null
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          completed_at?: string | null
          created_at?: string | null
          id?: string
          learning_path_id?: string | null
          progress_percentage?: number | null
          started_at?: string | null
          status?: string | null
          target_completion_date?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          completed_at?: string | null
          created_at?: string | null
          id?: string
          learning_path_id?: string | null
          progress_percentage?: number | null
          started_at?: string | null
          status?: string | null
          target_completion_date?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "user_learning_paths_learning_path_id_fkey"
            columns: ["learning_path_id"]
            isOneToOne: false
            referencedRelation: "learning_paths"
            referencedColumns: ["id"]
          },
        ]
      }
      user_learning_progress: {
        Row: {
          completed_at: string | null
          completion_score: number | null
          content_id: string | null
          created_at: string | null
          id: string
          last_accessed_at: string | null
          notes: string | null
          progress_percentage: number | null
          started_at: string | null
          status: string | null
          time_spent_minutes: number | null
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          completed_at?: string | null
          completion_score?: number | null
          content_id?: string | null
          created_at?: string | null
          id?: string
          last_accessed_at?: string | null
          notes?: string | null
          progress_percentage?: number | null
          started_at?: string | null
          status?: string | null
          time_spent_minutes?: number | null
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          completed_at?: string | null
          completion_score?: number | null
          content_id?: string | null
          created_at?: string | null
          id?: string
          last_accessed_at?: string | null
          notes?: string | null
          progress_percentage?: number | null
          started_at?: string | null
          status?: string | null
          time_spent_minutes?: number | null
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "user_learning_progress_content_id_fkey"
            columns: ["content_id"]
            isOneToOne: false
            referencedRelation: "learning_content"
            referencedColumns: ["id"]
          },
        ]
      }
      user_notification_settings: {
        Row: {
          created_at: string | null
          email_enabled: boolean | null
          frequency: string | null
          id: string
          in_app_enabled: boolean | null
          notification_type: string
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          email_enabled?: boolean | null
          frequency?: string | null
          id?: string
          in_app_enabled?: boolean | null
          notification_type: string
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          email_enabled?: boolean | null
          frequency?: string | null
          id?: string
          in_app_enabled?: boolean | null
          notification_type?: string
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      user_notifications: {
        Row: {
          created_at: string
          id: string
          message: string
          read: boolean
          title: string
          type: string
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          message: string
          read?: boolean
          title: string
          type?: string
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          message?: string
          read?: boolean
          title?: string
          type?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      user_platform_credentials: {
        Row: {
          created_at: string | null
          encrypted_credentials: Json
          id: string
          platform: Database["public"]["Enums"]["platform_type"]
          updated_at: string | null
          user_id: string
        }
        Insert: {
          created_at?: string | null
          encrypted_credentials: Json
          id?: string
          platform: Database["public"]["Enums"]["platform_type"]
          updated_at?: string | null
          user_id: string
        }
        Update: {
          created_at?: string | null
          encrypted_credentials?: Json
          id?: string
          platform?: Database["public"]["Enums"]["platform_type"]
          updated_at?: string | null
          user_id?: string
        }
        Relationships: []
      }
      user_profiles: {
        Row: {
          created_at: string | null
          id: string
          notification_settings: Json | null
          preferences: Json | null
          role: string
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          id: string
          notification_settings?: Json | null
          preferences?: Json | null
          role?: string
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          notification_settings?: Json | null
          preferences?: Json | null
          role?: string
          updated_at?: string | null
        }
        Relationships: []
      }
      user_roles: {
        Row: {
          created_at: string | null
          id: string
          role: Database["public"]["Enums"]["app_role"]
          user_id: string
        }
        Insert: {
          created_at?: string | null
          id?: string
          role: Database["public"]["Enums"]["app_role"]
          user_id: string
        }
        Update: {
          created_at?: string | null
          id?: string
          role?: Database["public"]["Enums"]["app_role"]
          user_id?: string
        }
        Relationships: []
      }
      user_selections: {
        Row: {
          created_at: string
          id: string
          name: string
          selections: Json
          updated_at: string
          user_id: string | null
        }
        Insert: {
          created_at?: string
          id?: string
          name: string
          selections?: Json
          updated_at?: string
          user_id?: string | null
        }
        Update: {
          created_at?: string
          id?: string
          name?: string
          selections?: Json
          updated_at?: string
          user_id?: string | null
        }
        Relationships: []
      }
      user_settings: {
        Row: {
          created_at: string
          id: string
          settings: Json
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          settings?: Json
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          settings?: Json
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      user_skill_assessments: {
        Row: {
          assessment_data: Json | null
          assessment_type: string
          created_at: string
          id: string
          level_achieved: number
          notes: string | null
          score: number
          skill_id: string
          user_id: string
        }
        Insert: {
          assessment_data?: Json | null
          assessment_type?: string
          created_at?: string
          id?: string
          level_achieved: number
          notes?: string | null
          score: number
          skill_id: string
          user_id: string
        }
        Update: {
          assessment_data?: Json | null
          assessment_type?: string
          created_at?: string
          id?: string
          level_achieved?: number
          notes?: string | null
          score?: number
          skill_id?: string
          user_id?: string
        }
        Relationships: []
      }
      user_skills: {
        Row: {
          created_at: string | null
          current_level: number | null
          id: string
          last_assessed_at: string | null
          proficiency_score: number | null
          skill_id: string | null
          target_level: number | null
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          current_level?: number | null
          id?: string
          last_assessed_at?: string | null
          proficiency_score?: number | null
          skill_id?: string | null
          target_level?: number | null
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          current_level?: number | null
          id?: string
          last_assessed_at?: string | null
          proficiency_score?: number | null
          skill_id?: string | null
          target_level?: number | null
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "user_skills_skill_id_fkey"
            columns: ["skill_id"]
            isOneToOne: false
            referencedRelation: "skills"
            referencedColumns: ["id"]
          },
        ]
      }
      user_subscriptions: {
        Row: {
          created_at: string | null
          expires_at: string | null
          features_enabled: string[] | null
          id: string
          tier: string
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          expires_at?: string | null
          features_enabled?: string[] | null
          id?: string
          tier?: string
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          expires_at?: string | null
          features_enabled?: string[] | null
          id?: string
          tier?: string
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      user_watchlist: {
        Row: {
          alert_enabled: boolean | null
          created_at: string | null
          id: string
          is_favorite: boolean | null
          symbol: string
          user_id: string | null
        }
        Insert: {
          alert_enabled?: boolean | null
          created_at?: string | null
          id?: string
          is_favorite?: boolean | null
          symbol: string
          user_id?: string | null
        }
        Update: {
          alert_enabled?: boolean | null
          created_at?: string | null
          id?: string
          is_favorite?: boolean | null
          symbol?: string
          user_id?: string | null
        }
        Relationships: []
      }
      user_wave_settings: {
        Row: {
          degree_preference: string | null
          fibonacci_ratios: Json | null
          id: string
          symbol: string
          updated_at: string | null
          user_id: string | null
          wave_sensitivity: string | null
        }
        Insert: {
          degree_preference?: string | null
          fibonacci_ratios?: Json | null
          id?: string
          symbol: string
          updated_at?: string | null
          user_id?: string | null
          wave_sensitivity?: string | null
        }
        Update: {
          degree_preference?: string | null
          fibonacci_ratios?: Json | null
          id?: string
          symbol?: string
          updated_at?: string | null
          user_id?: string | null
          wave_sensitivity?: string | null
        }
        Relationships: []
      }
      users: {
        Row: {
          created_at: string | null
          email: string | null
          id: string
          role: string | null
          tenant_id: string | null
        }
        Insert: {
          created_at?: string | null
          email?: string | null
          id: string
          role?: string | null
          tenant_id?: string | null
        }
        Update: {
          created_at?: string | null
          email?: string | null
          id?: string
          role?: string | null
          tenant_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "users_tenant_id_fkey"
            columns: ["tenant_id"]
            isOneToOne: false
            referencedRelation: "tenants"
            referencedColumns: ["id"]
          },
        ]
      }
      vertical_bot_conversations: {
        Row: {
          bot_id: string
          escalation_details: string | null
          id: string
          is_escalated: boolean | null
          last_message_at: string | null
          resolved: boolean | null
          started_at: string | null
          user_id: string | null
        }
        Insert: {
          bot_id: string
          escalation_details?: string | null
          id?: string
          is_escalated?: boolean | null
          last_message_at?: string | null
          resolved?: boolean | null
          started_at?: string | null
          user_id?: string | null
        }
        Update: {
          bot_id?: string
          escalation_details?: string | null
          id?: string
          is_escalated?: boolean | null
          last_message_at?: string | null
          resolved?: boolean | null
          started_at?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "vertical_bot_conversations_bot_id_fkey"
            columns: ["bot_id"]
            isOneToOne: false
            referencedRelation: "vertical_bots"
            referencedColumns: ["id"]
          },
        ]
      }
      vertical_bot_messages: {
        Row: {
          content: string
          conversation_id: string
          created_at: string | null
          id: string
          is_important: boolean | null
          sender: string
        }
        Insert: {
          content: string
          conversation_id: string
          created_at?: string | null
          id?: string
          is_important?: boolean | null
          sender: string
        }
        Update: {
          content?: string
          conversation_id?: string
          created_at?: string | null
          id?: string
          is_important?: boolean | null
          sender?: string
        }
        Relationships: [
          {
            foreignKeyName: "vertical_bot_messages_conversation_id_fkey"
            columns: ["conversation_id"]
            isOneToOne: false
            referencedRelation: "vertical_bot_conversations"
            referencedColumns: ["id"]
          },
        ]
      }
      vertical_bot_training_data: {
        Row: {
          bot_id: string
          data: Json
          id: string
          uploaded_at: string | null
          uploaded_by: string
        }
        Insert: {
          bot_id: string
          data: Json
          id?: string
          uploaded_at?: string | null
          uploaded_by: string
        }
        Update: {
          bot_id?: string
          data?: Json
          id?: string
          uploaded_at?: string | null
          uploaded_by?: string
        }
        Relationships: [
          {
            foreignKeyName: "vertical_bot_training_data_bot_id_fkey"
            columns: ["bot_id"]
            isOneToOne: false
            referencedRelation: "vertical_bots"
            referencedColumns: ["id"]
          },
        ]
      }
      vertical_bots: {
        Row: {
          compliance_flags: Json | null
          created_at: string | null
          description: string | null
          id: string
          industry: Database["public"]["Enums"]["industry_vertical"]
          is_active: boolean | null
          name: string
          updated_at: string | null
          user_id: string
        }
        Insert: {
          compliance_flags?: Json | null
          created_at?: string | null
          description?: string | null
          id?: string
          industry?: Database["public"]["Enums"]["industry_vertical"]
          is_active?: boolean | null
          name: string
          updated_at?: string | null
          user_id: string
        }
        Update: {
          compliance_flags?: Json | null
          created_at?: string | null
          description?: string | null
          id?: string
          industry?: Database["public"]["Enums"]["industry_vertical"]
          is_active?: boolean | null
          name?: string
          updated_at?: string | null
          user_id?: string
        }
        Relationships: []
      }
      visualizations: {
        Row: {
          config: Json
          created_at: string | null
          id: string
          paper_id: string | null
          user_id: string | null
          visualization_type: string
        }
        Insert: {
          config: Json
          created_at?: string | null
          id?: string
          paper_id?: string | null
          user_id?: string | null
          visualization_type: string
        }
        Update: {
          config?: Json
          created_at?: string | null
          id?: string
          paper_id?: string | null
          user_id?: string | null
          visualization_type?: string
        }
        Relationships: [
          {
            foreignKeyName: "visualizations_paper_id_fkey"
            columns: ["paper_id"]
            isOneToOne: false
            referencedRelation: "research_papers"
            referencedColumns: ["id"]
          },
        ]
      }
      voice_sessions: {
        Row: {
          agent_id: string
          created_at: string
          duration_seconds: number | null
          ended_at: string | null
          id: string
          project_id: string
          session_status: string | null
          transcription: string | null
          user_id: string
        }
        Insert: {
          agent_id: string
          created_at?: string
          duration_seconds?: number | null
          ended_at?: string | null
          id?: string
          project_id: string
          session_status?: string | null
          transcription?: string | null
          user_id: string
        }
        Update: {
          agent_id?: string
          created_at?: string
          duration_seconds?: number | null
          ended_at?: string | null
          id?: string
          project_id?: string
          session_status?: string | null
          transcription?: string | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "voice_sessions_agent_id_fkey"
            columns: ["agent_id"]
            isOneToOne: false
            referencedRelation: "agents"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "voice_sessions_project_id_fkey"
            columns: ["project_id"]
            isOneToOne: false
            referencedRelation: "projects"
            referencedColumns: ["id"]
          },
        ]
      }
      wave_alerts: {
        Row: {
          alert_type: string
          created_at: string | null
          id: string
          is_active: boolean | null
          last_triggered: string | null
          notification_methods: string[] | null
          symbol: string
          trigger_conditions: Json
          user_id: string | null
        }
        Insert: {
          alert_type: string
          created_at?: string | null
          id?: string
          is_active?: boolean | null
          last_triggered?: string | null
          notification_methods?: string[] | null
          symbol: string
          trigger_conditions: Json
          user_id?: string | null
        }
        Update: {
          alert_type?: string
          created_at?: string | null
          id?: string
          is_active?: boolean | null
          last_triggered?: string | null
          notification_methods?: string[] | null
          symbol?: string
          trigger_conditions?: Json
          user_id?: string | null
        }
        Relationships: []
      }
      wave_detections: {
        Row: {
          confidence_score: number | null
          detected_at: string | null
          fibonacci_levels: Json | null
          id: string
          last_price: number | null
          status: string | null
          symbol: string
          timeframe: string
          wave_degrees: Json | null
          wave_structure: Json
        }
        Insert: {
          confidence_score?: number | null
          detected_at?: string | null
          fibonacci_levels?: Json | null
          id?: string
          last_price?: number | null
          status?: string | null
          symbol: string
          timeframe: string
          wave_degrees?: Json | null
          wave_structure: Json
        }
        Update: {
          confidence_score?: number | null
          detected_at?: string | null
          fibonacci_levels?: Json | null
          id?: string
          last_price?: number | null
          status?: string | null
          symbol?: string
          timeframe?: string
          wave_degrees?: Json | null
          wave_structure?: Json
        }
        Relationships: []
      }
      wave_explanations: {
        Row: {
          confidence_level: number | null
          created_at: string | null
          explanation_text: string
          explanation_type: string
          id: string
          symbol: string
          timeframe: string
          wave_segment: Json
        }
        Insert: {
          confidence_level?: number | null
          created_at?: string | null
          explanation_text: string
          explanation_type: string
          id?: string
          symbol: string
          timeframe: string
          wave_segment: Json
        }
        Update: {
          confidence_level?: number | null
          created_at?: string | null
          explanation_text?: string
          explanation_type?: string
          id?: string
          symbol?: string
          timeframe?: string
          wave_segment?: Json
        }
        Relationships: []
      }
      workflow_runs: {
        Row: {
          finished_at: string | null
          id: string
          started_at: string | null
          status: string
          tenant_id: string | null
          user_id: string | null
          workflow_type: string
        }
        Insert: {
          finished_at?: string | null
          id?: string
          started_at?: string | null
          status: string
          tenant_id?: string | null
          user_id?: string | null
          workflow_type: string
        }
        Update: {
          finished_at?: string | null
          id?: string
          started_at?: string | null
          status?: string
          tenant_id?: string | null
          user_id?: string | null
          workflow_type?: string
        }
        Relationships: [
          {
            foreignKeyName: "workflow_runs_tenant_id_fkey"
            columns: ["tenant_id"]
            isOneToOne: false
            referencedRelation: "tenants"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "workflow_runs_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      workflow_templates: {
        Row: {
          created_at: string
          description: string | null
          domain: string
          id: string
          n8n_workflow: Json
          name: string
        }
        Insert: {
          created_at?: string
          description?: string | null
          domain: string
          id?: string
          n8n_workflow: Json
          name: string
        }
        Update: {
          created_at?: string
          description?: string | null
          domain?: string
          id?: string
          n8n_workflow?: Json
          name?: string
        }
        Relationships: []
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      binary_quantize: {
        Args: { "": string } | { "": unknown }
        Returns: unknown
      }
      calculate_next_run: {
        Args: {
          frequency: Database["public"]["Enums"]["audit_frequency"]
          from_time?: string
        }
        Returns: string
      }
      cleanup_old_cache_entries: {
        Args: Record<PropertyKey, never>
        Returns: undefined
      }
      create_notification: {
        Args: {
          p_user_id: string
          p_title: string
          p_message: string
          p_type?: string
          p_metadata?: Json
        }
        Returns: string
      }
      deduct_api_credits: {
        Args: { p_user_id: string; p_credits_to_deduct?: number }
        Returns: boolean
      }
      generate_share_token: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
      get_global_mood_data: {
        Args: Record<PropertyKey, never>
        Returns: Json
      }
      get_occupation_skill_recommendations: {
        Args: { p_occupation_code: string }
        Returns: {
          id: string
          skill_name: string
          explanation: string
          priority: number
        }[]
      }
      get_occupation_task_assessments: {
        Args: { p_occupation_code: string }
        Returns: {
          id: string
          task_description: string
          category: string
          explanation: string
          confidence: number
        }[]
      }
      get_regional_mood_data: {
        Args: Record<PropertyKey, never>
        Returns: Json
      }
      get_skill_resources: {
        Args: { p_skill_area: string }
        Returns: {
          id: string
          title: string
          url: string
          provider: string
          description: string
          cost_type: string
        }[]
      }
      get_user_analytics: {
        Args: { p_user_id: string }
        Returns: Json
      }
      halfvec_avg: {
        Args: { "": number[] }
        Returns: unknown
      }
      halfvec_out: {
        Args: { "": unknown }
        Returns: unknown
      }
      halfvec_send: {
        Args: { "": unknown }
        Returns: string
      }
      halfvec_typmod_in: {
        Args: { "": unknown[] }
        Returns: number
      }
      health_check: {
        Args: Record<PropertyKey, never>
        Returns: Json
      }
      hnsw_bit_support: {
        Args: { "": unknown }
        Returns: unknown
      }
      hnsw_halfvec_support: {
        Args: { "": unknown }
        Returns: unknown
      }
      hnsw_sparsevec_support: {
        Args: { "": unknown }
        Returns: unknown
      }
      hnswhandler: {
        Args: { "": unknown }
        Returns: unknown
      }
      increment_share_view: {
        Args: { share_token_param: string }
        Returns: Json
      }
      increment_template_usage: {
        Args: { template_id: string }
        Returns: undefined
      }
      ivfflat_bit_support: {
        Args: { "": unknown }
        Returns: unknown
      }
      ivfflat_halfvec_support: {
        Args: { "": unknown }
        Returns: unknown
      }
      ivfflathandler: {
        Args: { "": unknown }
        Returns: unknown
      }
      l2_norm: {
        Args: { "": unknown } | { "": unknown }
        Returns: number
      }
      l2_normalize: {
        Args: { "": string } | { "": unknown } | { "": unknown }
        Returns: unknown
      }
      record_metric: {
        Args: {
          p_metric_name: string
          p_metric_value: number
          p_metric_type?: string
          p_tags?: Json
        }
        Returns: string
      }
      renewai_mark_notification_read: {
        Args: { notification_id: string }
        Returns: undefined
      }
      sparsevec_out: {
        Args: { "": unknown }
        Returns: unknown
      }
      sparsevec_send: {
        Args: { "": unknown }
        Returns: string
      }
      sparsevec_typmod_in: {
        Args: { "": unknown[] }
        Returns: number
      }
      track_user_engagement: {
        Args: { p_user_id: string; p_event_type: string; p_value?: number }
        Returns: undefined
      }
      update_project_analytics: {
        Args: { p_project_id: string; p_user_id: string }
        Returns: undefined
      }
      vector_avg: {
        Args: { "": number[] }
        Returns: string
      }
      vector_dims: {
        Args: { "": string } | { "": unknown }
        Returns: number
      }
      vector_norm: {
        Args: { "": string }
        Returns: number
      }
      vector_out: {
        Args: { "": string }
        Returns: unknown
      }
      vector_send: {
        Args: { "": string }
        Returns: string
      }
      vector_typmod_in: {
        Args: { "": unknown[] }
        Returns: number
      }
    }
    Enums: {
      alert_status: "unread" | "read" | "dismissed"
      alert_type:
        | "score_change"
        | "new_issue"
        | "resolved_issue"
        | "scheduled_audit"
      app_role: "admin" | "moderator" | "user"
      audit_frequency: "daily" | "weekly" | "monthly"
      audit_status: "pending" | "scanning" | "completed" | "failed"
      industry_vertical: "legal" | "healthcare" | "saas" | "other"
      issue_category:
        | "performance"
        | "seo"
        | "accessibility"
        | "security"
        | "mobile"
        | "ux"
      issue_impact: "low" | "medium" | "high" | "critical"
      module_category:
        | "communication"
        | "document_processing"
        | "ecommerce"
        | "analytics"
        | "security"
        | "data_processing"
      module_status: "active" | "deprecated" | "beta"
      platform_type:
        | "bubble"
        | "webflow"
        | "zapier"
        | "airtable"
        | "shopify"
        | "stripe"
      usage_status: "success" | "error" | "pending"
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

type DefaultSchema = Database[Extract<keyof Database, "public">]

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof (Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        Database[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? (Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      Database[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof Database },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof Database },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends { schema: keyof Database }
  ? Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never

export const Constants = {
  public: {
    Enums: {
      alert_status: ["unread", "read", "dismissed"],
      alert_type: [
        "score_change",
        "new_issue",
        "resolved_issue",
        "scheduled_audit",
      ],
      app_role: ["admin", "moderator", "user"],
      audit_frequency: ["daily", "weekly", "monthly"],
      audit_status: ["pending", "scanning", "completed", "failed"],
      industry_vertical: ["legal", "healthcare", "saas", "other"],
      issue_category: [
        "performance",
        "seo",
        "accessibility",
        "security",
        "mobile",
        "ux",
      ],
      issue_impact: ["low", "medium", "high", "critical"],
      module_category: [
        "communication",
        "document_processing",
        "ecommerce",
        "analytics",
        "security",
        "data_processing",
      ],
      module_status: ["active", "deprecated", "beta"],
      platform_type: [
        "bubble",
        "webflow",
        "zapier",
        "airtable",
        "shopify",
        "stripe",
      ],
      usage_status: ["success", "error", "pending"],
    },
  },
} as const
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://kvunnankqgfokeufvsrv.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt2dW5uYW5rcWdmb2tldWZ2c3J2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk4ODYyMTksImV4cCI6MjA2NTQ2MjIxOX0.eFRKKSAWaXQgCCX7UpU0hF0dnEyJ2IXUnaGsc8MEGOU";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);import { useToast, toast } from "@/hooks/use-toast";

export { useToast, toast };
/// <reference types="vite/client" />
import { useEffect, useState, useCallback } from 'react';
import { useMutation } from '@tanstack/react-query';
import { ChatMessage, loadChatHistory, saveChatHistory } from '@/utils/chatCache';
import { useUserProfile } from '@/hooks/useUserProfile';

const FUNCTIONS_BASE = `${import.meta.env.VITE_SUPABASE_URL}/functions/v1`;

interface CoachResponse {
  response: string;
  followUpQuestions?: string[];
  actionItems?: string[];
  usage?: {
    totalTokens: number;
    promptTokens?: number;
    completionTokens?: number;
  };
}

export function useCareerCoach() {
  const { data: userProfile } = useUserProfile();
  const userId = userProfile?.id ?? 'anonymous';

  const [messages, setMessages] = useState<ChatMessage[]>(() =>
    loadChatHistory(userId),
  );

  // Persist chat history when userId changes
  useEffect(() => {
    saveChatHistory(userId, messages);
  }, [userId, messages]);

  const mutation = useMutation<CoachResponse, Error, string>({
    mutationFn: async (message) => {
      const body = {
        message,
        conversationHistory: messages.slice(-20), // send last 20 msgs
        userProfile: userProfile ? { id: userProfile.id, occupationCode: userProfile.occupationCode, careerGoals: userProfile.careerGoals } : undefined,
      };
      const resp = await fetch(`${FUNCTIONS_BASE}/ai-career-coach`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      if (!resp.ok) throw new Error(await resp.text());
      return resp.json();
    },
    onSuccess: (data, newMessage) => {
      const updated: ChatMessage[] = [
        ...messages,
        { id: crypto.randomUUID(), role: 'user', content: newMessage },
        { id: crypto.randomUUID(), role: 'assistant', content: data.response },
      ];
      setMessages(updated);
    },
  });

  const sendMessage = useCallback(
    (msg: string) => {
      if (!msg.trim()) return;
      mutation.mutate(msg);
      // optimistic UI
      setMessages((prev) => [
        ...prev,
        { id: crypto.randomUUID(), role: 'user', content: msg },
      ]);
    },
    [mutation],
  );

  return {
    messages,
    sendMessage,
    isLoading: mutation.isLoading,
    error: mutation.error,
  };
}

import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { User } from "@supabase/supabase-js";

export interface SavedSelection<T> {
  id: string;
  name: string;
  data: T;
  createdAt: number;
}

const STORAGE_KEY = "apo_saved_selections_v1";

// Helpers for localStorage for anonymous users
function getLocalSelections<T>(): SavedSelection<T>[] {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (raw) {
    try {
      return JSON.parse(raw);
    } catch {
      // ignore parsing errors
    }
  }
  return [];
}

function setLocalSelections<T>(selections: SavedSelection<T>[]) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(selections));
}

export function useSavedSelections<T = unknown>() {
  const [user, setUser] = useState<User | null>(null);
  const queryClient = useQueryClient();

  useEffect(() => {
    const checkUserSession = async () => {
      const { data: { session } } = await supabase.auth.getSession();
      setUser(session?.user ?? null);
    };
    checkUserSession();

    const { data: authListener } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
      queryClient.invalidateQueries({ queryKey: ['user_selections'] });
    });

    return () => {
      authListener.subscription.unsubscribe();
    };
  }, [queryClient]);
  
  const queryKey = ['user_selections', user?.id];

  const { data: saved = [], isLoading } = useQuery<SavedSelection<T>[]>({
    queryKey,
    queryFn: async () => {
      if (!user) {
        return getLocalSelections<T>();
      }

      const { data, error } = await supabase
        .from('user_selections')
        .select('id, name, selections, created_at')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching selections from Supabase:', error);
        throw error;
      }
      
      return data.map(d => ({
        id: d.id,
        name: d.name,
        data: d.selections as T,
        createdAt: new Date(d.created_at).getTime(),
      }));
    },
  });

  const saveListMutation = useMutation({
    mutationFn: async ({ name, data: listData }: { name: string, data: T }) => {
      if (!user) {
        const currentSelections = getLocalSelections<T>();
        const newEntry: SavedSelection<T> = {
          id: `local_${Date.now().toString(36)}`,
          name: name || "Untitled",
          data: listData,
          createdAt: Date.now(),
        };
        setLocalSelections([newEntry, ...currentSelections]);
        return newEntry;
      }

      const { data, error } = await supabase
        .from('user_selections')
        .insert({ user_id: user.id, name: name || "Untitled", selections: listData as any })
        .select('id')
        .single();
      
      if (error) {
        console.error('Error saving selection to Supabase:', error);
        throw error;
      }
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
    },
  });

  const updateNameMutation = useMutation({
    mutationFn: async ({ id, newName }: { id: string, newName: string }) => {
      if (!user || id.startsWith('local_')) {
        const selections = getLocalSelections<T>();
        const updatedSelections = selections.map(s => s.id === id ? { ...s, name: newName } : s);
        setLocalSelections(updatedSelections);
        return;
      }

      const { error } = await supabase
        .from('user_selections')
        .update({ name: newName })
        .eq('id', id);

      if (error) {
        console.error("Error updating selection name in Supabase:", error);
        throw error;
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
    }
  });

  const removeListMutation = useMutation({
    mutationFn: async (id: string) => {
      if (!user || id.startsWith('local_')) {
        const selections = getLocalSelections<T>();
        const filteredSelections = selections.filter(s => s.id !== id);
        setLocalSelections(filteredSelections);
        return;
      }

      const { error } = await supabase
        .from('user_selections')
        .delete()
        .eq('id', id);

      if (error) {
        console.error("Error removing selection from Supabase:", error);
        throw error;
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
    }
  });

  return {
    saved,
    isLoading,
    saveList: (name: string, data: T) => saveListMutation.mutate({ name, data }),
    updateName: (id: string, newName: string) => updateNameMutation.mutate({ id, newName }),
    removeList: (id: string) => removeListMutation.mutate(id),
    loadList: (id: string): SavedSelection<T> | undefined => saved.find((entry) => entry.id === id),
  };
}
import { useQuery } from "@tanstack/react-query";

export type FiltersResponse = {
  jobZones: { id: number; name: string }[];
  brightOutlook: { id: number; name: string }[];
  stem: { id: number; name: string }[];
  clusters: { id: number; name: string }[];
  industries: { id: number; name: string }[];
};

export function useFilters(options?: Parameters<typeof useQuery<FiltersResponse>>[2]) {
  const fetcher = async (): Promise<FiltersResponse> => {
    const res = await fetch("/functions/v1/filters", { method: "GET" });
    if (!res.ok) throw new Error(`Filters fetch failed (${res.status})`);
    return (await res.json()) as FiltersResponse;
  };
  return useQuery<FiltersResponse>(["filters"], fetcher, { staleTime: 5 * 60 * 1000, ...options });
}

import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { User } from "@supabase/supabase-js";

export type NotificationPreferences = {
  id: string;
  user_id: string;
  email_notifications: boolean;
  push_notifications: boolean;
  analysis_complete: boolean;
  weekly_summary: boolean;
  share_notifications: boolean;
  system_updates: boolean;
  created_at: string;
  updated_at: string;
};

export function useNotificationPreferences() {
  const [user, setUser] = useState<User | null>(null);
  const queryClient = useQueryClient();

  useEffect(() => {
    const checkUserSession = async () => {
      const { data: { session } } = await supabase.auth.getSession();
      setUser(session?.user ?? null);
    };
    checkUserSession();

    const { data: authListener } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
      queryClient.invalidateQueries({ queryKey: ['notification_preferences'] });
    });

    return () => {
      authListener.subscription.unsubscribe();
    };
  }, [queryClient]);

  const queryKey = ['notification_preferences', user?.id];

  const { data: preferences, isLoading } = useQuery<NotificationPreferences | null>({
    queryKey,
    queryFn: async () => {
      if (!user) return null;
      const { data, error } = await supabase
        .from('notification_preferences')
        .select('*')
        .eq('user_id', user.id)
        .maybeSingle();
      if (error) {
        console.error("Failed to load notification preferences:", error);
        return null;
      }
      return data;
    },
    enabled: !!user,
  });

  const upsertPreferencesMutation = useMutation({
    mutationFn: async (updates: Partial<NotificationPreferences>) => {
      if (!user) throw new Error('User not authenticated');
      const fieldsToUpdate = { ...preferences, ...updates, user_id: user.id };
      const { data, error } = await supabase
        .from('notification_preferences')
        .upsert(fieldsToUpdate)
        .select()
        .maybeSingle();
      if (error) {
        throw error;
      }
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
    },
  });

  return {
    preferences,
    isLoading,
    updatePreferences: (updates: Partial<NotificationPreferences>) => upsertPreferencesMutation.mutate(updates),
    isUpdating: upsertPreferencesMutation.isPending,
    user,
  };
}


import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { User } from "@supabase/supabase-js";

export interface UserSettings {
  theme: 'light' | 'dark';
  emailNotifications: boolean;
  autoSaveAnalyses: boolean;
  defaultExportFormat: 'csv' | 'pdf' | 'json';
}

const DEFAULT_SETTINGS: UserSettings = {
  theme: 'light',
  emailNotifications: true,
  autoSaveAnalyses: true,
  defaultExportFormat: 'csv'
};

export function useUserSettings() {
  const [user, setUser] = useState<User | null>(null);
  const queryClient = useQueryClient();

  useEffect(() => {
    const checkUserSession = async () => {
      const { data: { session } } = await supabase.auth.getSession();
      setUser(session?.user ?? null);
    };
    checkUserSession();

    const { data: authListener } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
      queryClient.invalidateQueries({ queryKey: ['user_settings'] });
    });

    return () => {
      authListener.subscription.unsubscribe();
    };
  }, [queryClient]);

  const queryKey = ['user_settings', user?.id];

  const { data: settings = DEFAULT_SETTINGS, isLoading } = useQuery<UserSettings>({
    queryKey,
    queryFn: async () => {
      if (!user) return DEFAULT_SETTINGS;

      const { data, error } = await supabase
        .from('user_settings')
        .select('settings')
        .eq('user_id', user.id)
        .maybeSingle();

      if (error) {
        console.error('Error fetching user settings:', error);
        return DEFAULT_SETTINGS;
      }

      // Defensive: force settings to be an object if possible
      let settingsObj = {};
      if (data && typeof data.settings === 'object' && data.settings !== null) {
        settingsObj = data.settings;
      }

      return { ...DEFAULT_SETTINGS, ...settingsObj };
    },
    enabled: !!user,
  });

  const updateSettingsMutation = useMutation({
    mutationFn: async (newSettings: Partial<UserSettings>) => {
      if (!user) throw new Error('User not authenticated');

      const updatedSettings = { ...settings, ...newSettings };

      const { error } = await supabase
        .from('user_settings')
        .upsert({
          user_id: user.id,
          settings: updatedSettings
        });

      if (error) {
        console.error('Error updating user settings:', error);
        throw error;
      }
      
      return updatedSettings;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
    },
  });

  return {
    settings,
    isLoading,
    updateSettings: (newSettings: Partial<UserSettings>) => updateSettingsMutation.mutate(newSettings),
    isUpdating: updateSettingsMutation.isPending,
  };
}

import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { User } from "@supabase/supabase-js";

export interface UserProfile {
  id: string;
  email?: string;
  full_name?: string;
  avatar_url?: string;
  subscription_tier?: string;
  api_credits?: number;
  created_at: string;
  updated_at: string;
}

export function useUserProfile() {
  const [user, setUser] = useState<User | null>(null);
  const queryClient = useQueryClient();

  useEffect(() => {
    const checkUserSession = async () => {
      const { data: { session } } = await supabase.auth.getSession();
      setUser(session?.user ?? null);
    };
    checkUserSession();

    const { data: authListener } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
      queryClient.invalidateQueries({ queryKey: ['user_profile'] });
    });

    return () => {
      authListener.subscription.unsubscribe();
    };
  }, [queryClient]);

  const queryKey = ['user_profile', user?.id];

  const { data: profile, isLoading } = useQuery<UserProfile | null>({
    queryKey,
    queryFn: async () => {
      if (!user) return null;

      const { data, error } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', user.id)
        .single();

      if (error) {
        console.error('Error fetching user profile:', error);
        return null;
      }
      
      return data;
    },
    enabled: !!user,
  });

  const updateProfileMutation = useMutation({
    mutationFn: async (updates: Partial<Pick<UserProfile, 'full_name' | 'avatar_url'>>) => {
      if (!user) throw new Error('User not authenticated');

      const { data, error } = await supabase
        .from('profiles')
        .update(updates)
        .eq('id', user.id)
        .select()
        .single();

      if (error) {
        console.error('Error updating profile:', error);
        throw error;
      }
      
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
    },
  });

  return {
    profile,
    isLoading,
    updateProfile: (updates: any) => updateProfileMutation.mutate(updates),
    isUpdating: updateProfileMutation.isPending,
    user,
  };
}
// useGemini: React hook for browser-only Gemini LLM calls
// Usage: const { loading, error, data, generate } = useGemini();

import { useState } from 'react';
import { GeminiService, GeminiResponse } from '@/services/GeminiService';

export function useGemini() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [data, setData] = useState<GeminiResponse | null>(null);

  /**
   * Call Gemini LLM from the browser.
   * @param prompt User/system prompt
   * @param generationConfig Gemini API generationConfig (optional)
   */
  const generate = async (prompt: string, generationConfig?: object) => {
    setLoading(true);
    setError(null);
    setData(null);
    try {
      const result = await GeminiService.generate(prompt, generationConfig);
      setData(result);
    } catch (err: any) {
      setError((err as Error).message || 'Unknown error');
    } finally {
      setLoading(false);
    }
  };

  return { loading, error, data, generate };
}

// Supabase does not export the Json type, so we define it here:
type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json }
  | Json[];

import { supabase } from "@/integrations/supabase/client";

/**
 * Track an analytics event for the current user (basic interface).
 * @param payload - event details
 */
export async function trackAnalyticsEvent(payload: {
  event_name: string;
  event_category: string;
  event_data?: Json;    // Use Json type explicitly!
  page_url?: string;
}) {
  try {
    // Grabs user from supabase auth
    const { data: { session } } = await supabase.auth.getSession();
    const user_id = session?.user?.id;
    await supabase.from('analytics_events').insert({
      user_id,
      event_name: payload.event_name,
      event_category: payload.event_category,
      event_data: payload.event_data ?? {},
      page_url: payload.page_url ?? window.location.pathname,
      user_agent: navigator.userAgent,
      // IP address is not collected from client for privacy, handled server-side if needed
    } as {
      user_id: string | undefined;
      event_name: string;
      event_category: string;
      event_data: Json;
      page_url: string;
      user_agent: string;
    });
  } catch (error) {
    console.warn("Analytics event not tracked:", error);
  }
}


import { useState, useEffect } from 'react';

export interface UserSkill {
  id: string;
  name: string;
  currentLevel: number;
  targetLevel: number;
  category: string;
  description?: string;
}

export interface SkillGap {
  id: string;
  skillId: string;
  skillName: string;
  currentLevel: number;
  targetLevel: number;
  gap: number;
  gapSize: number;
  priority: 'high' | 'medium' | 'low';
  recommendations: string[];
}

export interface CourseRecommendation {
  id: string;
  title: string;
  provider: string;
  url: string;
  duration: string;
  level: string;
  rating: number;
  price: string;
  skills: string[];
  description?: string;
  prerequisites?: string[];
}

export interface Milestone {
  id: string;
  title: string;
  description: string;
  targetDate: string;
  completed: boolean;
  skills: string[];
}

export interface LearningPath {
  id: string;
  name: string;
  description: string;
  skills: string[];
  estimatedDuration: string;
  milestones: Milestone[];
  difficulty: string;
  prerequisites: string[];
}

export interface ProgressTracking {
  id: string;
  skillId: string;
  skillName: string;
  initialLevel: number;
  currentLevel: number;
  targetLevel: number;
  progressPercentage: number;
  lastUpdated: string;
  milestones: string[];
  timeSpent: number;
  coursesCompleted: string[];
}

export interface UserProfile {
  id: string;
  name: string;
  email: string;
  currentRole?: string;
  targetRole?: string;
  experience?: string;
  preferences?: {
    learningStyle?: string;
    timeCommitment?: string;
    budget?: string;
  };
}

const STORAGE_KEYS = {
  USER_SKILLS: 'career_planning_user_skills',
  SKILL_GAPS: 'career_planning_skill_gaps',
  COURSE_RECOMMENDATIONS: 'career_planning_course_recommendations',
  LEARNING_PATHS: 'career_planning_learning_paths',
  PROGRESS_TRACKING: 'career_planning_progress_tracking',
  USER_PROFILE: 'career_planning_user_profile',
};

export function useCareerPlanningStorage() {
  const [userSkills, setUserSkills] = useState<UserSkill[]>([]);
  const [skillGaps, setSkillGaps] = useState<SkillGap[]>([]);
  const [courseRecommendations, setCourseRecommendations] = useState<CourseRecommendation[]>([]);
  const [learningPaths, setLearningPaths] = useState<LearningPath[]>([]);
  const [progressTracking, setProgressTracking] = useState<ProgressTracking[]>([]);
  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Load data from localStorage on mount
  useEffect(() => {
    const loadStoredData = () => {
      try {
        const storedUserSkills = localStorage.getItem(STORAGE_KEYS.USER_SKILLS);
        const storedSkillGaps = localStorage.getItem(STORAGE_KEYS.SKILL_GAPS);
        const storedCourseRecommendations = localStorage.getItem(STORAGE_KEYS.COURSE_RECOMMENDATIONS);
        const storedLearningPaths = localStorage.getItem(STORAGE_KEYS.LEARNING_PATHS);
        const storedProgressTracking = localStorage.getItem(STORAGE_KEYS.PROGRESS_TRACKING);
        const storedUserProfile = localStorage.getItem(STORAGE_KEYS.USER_PROFILE);

        if (storedUserSkills) setUserSkills(JSON.parse(storedUserSkills));
        if (storedSkillGaps) setSkillGaps(JSON.parse(storedSkillGaps));
        if (storedCourseRecommendations) setCourseRecommendations(JSON.parse(storedCourseRecommendations));
        if (storedLearningPaths) setLearningPaths(JSON.parse(storedLearningPaths));
        if (storedProgressTracking) setProgressTracking(JSON.parse(storedProgressTracking));
        if (storedUserProfile) setUserProfile(JSON.parse(storedUserProfile));
      } catch (error) {
        console.error('Error loading career planning data from localStorage:', error);
      } finally {
        setIsLoading(false);
      }
    };

    loadStoredData();
  }, []);

  // Save functions
  const saveUserSkills = (skills: UserSkill[]) => {
    setUserSkills(skills);
    localStorage.setItem(STORAGE_KEYS.USER_SKILLS, JSON.stringify(skills));
  };

  const saveSkillGaps = (gaps: SkillGap[]) => {
    setSkillGaps(gaps);
    localStorage.setItem(STORAGE_KEYS.SKILL_GAPS, JSON.stringify(gaps));
  };

  const saveCourseRecommendations = (courses: CourseRecommendation[]) => {
    setCourseRecommendations(courses);
    localStorage.setItem(STORAGE_KEYS.COURSE_RECOMMENDATIONS, JSON.stringify(courses));
  };

  const saveLearningPaths = (paths: LearningPath[]) => {
    setLearningPaths(paths);
    localStorage.setItem(STORAGE_KEYS.LEARNING_PATHS, JSON.stringify(paths));
  };

  const saveProgressTracking = (progress: ProgressTracking[]) => {
    setProgressTracking(progress);
    localStorage.setItem(STORAGE_KEYS.PROGRESS_TRACKING, JSON.stringify(progress));
  };

  const saveUserProfile = (profile: UserProfile) => {
    setUserProfile(profile);
    localStorage.setItem(STORAGE_KEYS.USER_PROFILE, JSON.stringify(profile));
  };

  // Helper functions
  const addUserSkill = (skill: Omit<UserSkill, 'id'>) => {
    const newSkill: UserSkill = {
      ...skill,
      id: `skill_${Date.now()}`,
    };
    saveUserSkills([...userSkills, newSkill]);
  };

  const updateUserSkill = (skillId: string, updates: Partial<UserSkill>) => {
    const updatedSkills = userSkills.map(skill =>
      skill.id === skillId ? { ...skill, ...updates } : skill
    );
    saveUserSkills(updatedSkills);
  };

  const removeUserSkill = (skillId: string) => {
    const filteredSkills = userSkills.filter(skill => skill.id !== skillId);
    saveUserSkills(filteredSkills);
  };

  const addLearningPath = (path: Omit<LearningPath, 'id'>) => {
    const newPath: LearningPath = {
      ...path,
      id: `path_${Date.now()}`,
    };
    saveLearningPaths([...learningPaths, newPath]);
  };

  const updateProgressTracking = (skillId: string, progressPercentage: number) => {
    const skill = userSkills.find(s => s.id === skillId);
    if (!skill) return;

    const existingProgress = progressTracking.find(p => p.skillId === skillId);
    
    if (existingProgress) {
      const updatedProgress = progressTracking.map(p =>
        p.skillId === skillId
          ? { ...p, progressPercentage, lastUpdated: new Date().toISOString() }
          : p
      );
      saveProgressTracking(updatedProgress);
    } else {
      const newProgress: ProgressTracking = {
        id: `progress_${Date.now()}`,
        skillId,
        skillName: skill.name,
        initialLevel: skill.currentLevel,
        currentLevel: skill.currentLevel,
        targetLevel: skill.targetLevel,
        progressPercentage,
        lastUpdated: new Date().toISOString(),
        milestones: [],
        timeSpent: 0,
        coursesCompleted: [],
      };
      saveProgressTracking([...progressTracking, newProgress]);
    }
  };

  const updateSkillProgress = (skillId: string, newLevel: number, hoursSpent: number) => {
    const skill = userSkills.find(s => s.id === skillId);
    if (!skill) return;

    // Update skill current level
    updateUserSkill(skillId, { currentLevel: newLevel });

    // Update progress tracking
    const existingProgress = progressTracking.find(p => p.skillId === skillId);
    const progressPercentage = Math.min(100, (newLevel / skill.targetLevel) * 100);
    
    if (existingProgress) {
      const updatedProgress = progressTracking.map(p =>
        p.skillId === skillId
          ? { 
              ...p, 
              currentLevel: newLevel,
              progressPercentage,
              timeSpent: p.timeSpent + hoursSpent,
              lastUpdated: new Date().toISOString() 
            }
          : p
      );
      saveProgressTracking(updatedProgress);
    } else {
      const newProgress: ProgressTracking = {
        id: `progress_${Date.now()}`,
        skillId,
        skillName: skill.name,
        initialLevel: skill.currentLevel,
        currentLevel: newLevel,
        targetLevel: skill.targetLevel,
        progressPercentage,
        lastUpdated: new Date().toISOString(),
        milestones: [],
        timeSpent: hoursSpent,
        coursesCompleted: [],
      };
      saveProgressTracking([...progressTracking, newProgress]);
    }
  };

  const analyzeSkillGaps = (skills: UserSkill[]): SkillGap[] => {
    return skills
      .filter(skill => skill.currentLevel < skill.targetLevel)
      .map(skill => {
        const gap = skill.targetLevel - skill.currentLevel;
        const gapSize = gap;
        let priority: 'high' | 'medium' | 'low' = 'low';
        
        if (gap >= 3) priority = 'high';
        else if (gap >= 2) priority = 'medium';

        const recommendations = [
          `Focus on practical exercises to improve ${skill.name}`,
          `Consider taking online courses in ${skill.name}`,
          `Practice ${skill.name} through real-world projects`,
        ];

        return {
          id: `gap_${skill.id}`,
          skillId: skill.id,
          skillName: skill.name,
          currentLevel: skill.currentLevel,
          targetLevel: skill.targetLevel,
          gap,
          gapSize,
          priority,
          recommendations,
        };
      });
  };

  return {
    // Data
    userSkills,
    skillGaps,
    courseRecommendations,
    learningPaths,
    progressTracking,
    userProfile,
    isLoading,
    
    // Save functions
    saveUserSkills,
    saveSkillGaps,
    saveCourseRecommendations,
    saveLearningPaths,
    saveProgressTracking,
    saveUserProfile,
    
    // Helper functions
    addUserSkill,
    updateUserSkill,
    removeUserSkill,
    addLearningPath,
    updateProgressTracking,
    updateSkillProgress,
    analyzeSkillGaps,
  };
}
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
import { useQuery, UseQueryOptions } from "@tanstack/react-query";

/**
 * Hook: useOnet
 * Fetches live data from the O*NET Web-Services via the onetProxy edge function.
 *
 * @param path  The O*NET Web Service path starting with a leading `/`,
 *              e.g. `/ws/online/present/taxonomy/occupation/11-1011.00`.
 * @param options Optional React-Query options (staleTime, cacheTime, enabled …)
 */
export function useOnet<T = unknown>(
  path: string,
  options?: UseQueryOptions<T, Error, T, readonly unknown[]>
) {
  const fetcher = async (): Promise<T> => {
    if (!path.startsWith("/")) {
      throw new Error("useOnet path must start with / (e.g. /ws/…)");
    }
    const devBase = typeof window !== 'undefined' && window.location.port === '8080'
      ? 'http://localhost:8888'
      : '';
    const url = `${devBase}/.netlify/functions/onet-proxy?path=${encodeURIComponent(path)}`;
    console.debug('[useOnet] fetching', { url, origin: window.location.origin });
    const res = await fetch(url);
    if (!res.ok) {
      throw new Error(`O*NET request failed (${res.status})`);
    }
    // O*NET can return XML or JSON depending on endpoint; try JSON first
    const contentType = res.headers.get("Content-Type") || "";
    console.debug('[useOnet] response', { status: res.status, contentType });
    if (contentType.toLowerCase().includes("json")) {
      return (await res.json()) as T;
    }
    const text = await res.text();
    // naive XML-to-string return. Callers can parse as needed.
    return text as unknown as T;
  };

  return useQuery<T>({
    queryKey: ["onet", path],
    queryFn: fetcher,
    staleTime: 1000 * 60 * 5, // 5 min
    gcTime: 1000 * 60 * 30,
    retry: 2,
    ...(options as any),
  });
}

import { useEffect, useState } from "react";
import { supabase } from "@/integrations/supabase/client";
import type { User, Session } from "@supabase/supabase-js";

/**
 * useSession - Hook to manage Supabase user & session state.
 */
export function useSession() {
  const [user, setUser] = useState<User | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Set up auth state change listener
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      setSession(session);
      setUser(session?.user ?? null);
      setLoading(false);
    });
    // Fetch initial session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setUser(session?.user ?? null);
      setLoading(false);
    });
    return () => subscription.unsubscribe();
  }, []);

  return { user, session, loading };
}

// Supabase does not export the Json type, so we define it here:
type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json }
  | Json[];

import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { User } from "@supabase/supabase-js";

export type FeedbackType = "bug_report" | "feature_request" | "general" | "support";
export type FeedbackPriority = "low" | "medium" | "high" | "urgent";
export type FeedbackStatus = "open" | "in_progress" | "resolved" | "closed";

export type UserFeedback = {
  id: string;
  user_id: string;
  feedback_type: FeedbackType;
  title: string;
  description: string;
  priority: FeedbackPriority;
  status: FeedbackStatus;
  category?: string;
  browser_info?: Json;
  url_context?: string;
  attachments?: string[] | null;
  created_at: string;
  updated_at: string;
  resolved_at?: string;
  admin_response?: string;
};

function fromDbFeedback(row: any): UserFeedback {
  return {
    id: row.id,
    user_id: row.user_id,
    feedback_type: row.feedback_type as FeedbackType,
    title: row.title,
    description: row.description,
    priority: row.priority as FeedbackPriority,
    status: row.status as FeedbackStatus,
    category: row.category ?? undefined,
    browser_info: row.browser_info ?? {},
    url_context: row.url_context ?? undefined,
    attachments: row.attachments ?? null,
    created_at: row.created_at,
    updated_at: row.updated_at,
    resolved_at: row.resolved_at ?? undefined,
    admin_response: row.admin_response ?? undefined,
  };
}

export function useUserFeedback() {
  const [user, setUser] = useState<User | null>(null);
  const queryClient = useQueryClient();

  useEffect(() => {
    const checkUserSession = async () => {
      const { data: { session } } = await supabase.auth.getSession();
      setUser(session?.user ?? null);
    };
    checkUserSession();

    const { data: authListener } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
      queryClient.invalidateQueries({ queryKey: ['user_feedback'] });
    });

    return () => {
      authListener.subscription.unsubscribe();
    };
  }, [queryClient]);

  const queryKey = ['user_feedback', user?.id];

  // Query to fetch all feedback submitted by the user
  const { data: feedback = [], isLoading } = useQuery<UserFeedback[]>({
    queryKey,
    queryFn: async () => {
      if (!user) return [];
      const { data, error } = await supabase
        .from('user_feedback')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error loading feedback:', error);
        return [];
      }
      // Defensive: protect against type errors by mapping/validating
      return (data || []).map(fromDbFeedback);
    },
    enabled: !!user,
  });

  // Mutation to submit new feedback
  const submitFeedbackMutation = useMutation({
    mutationFn: async (
      feedback: Omit<UserFeedback, 'id' | 'user_id' | 'created_at' | 'updated_at' | 'resolved_at' | 'admin_response'>
    ) => {
      if (!user) throw new Error('User not authenticated');
      const insertPayload = {
        ...feedback,
        user_id: user.id,
        browser_info: feedback.browser_info ?? {},
      } as {
        user_id: string;
        feedback_type: FeedbackType;
        title: string;
        description: string;
        priority: FeedbackPriority;
        status: FeedbackStatus;
        category?: string;
        browser_info?: Json;
        url_context?: string;
        attachments?: string[] | null;
      };
      const { data, error } = await supabase
        .from('user_feedback')
        .insert(insertPayload)
        .select()
        .single();
      if (error) throw error;
      return fromDbFeedback(data);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
    },
  });

  return {
    feedback,
    isLoading,
    submitFeedback: submitFeedbackMutation.mutate,
    isSubmitting: submitFeedbackMutation.isPending,
    user,
  };
}


import { useState, useEffect, useCallback } from 'react';
import { useQueryClient } from '@tanstack/react-query';

interface CacheOptions {
  ttl?: number; // Time to live in milliseconds
  maxSize?: number; // Maximum number of items to cache
  serialize?: boolean; // Whether to serialize complex objects
}

interface CacheItem<T> {
  data: T;
  timestamp: number;
  ttl: number;
  accessCount: number;
  lastAccess: number;
}

class AdvancedCache {
  private cache = new Map<string, CacheItem<any>>();
  private maxSize: number;
  private defaultTtl: number;

  constructor(maxSize = 100, defaultTtl = 5 * 60 * 1000) {
    this.maxSize = maxSize;
    this.defaultTtl = defaultTtl;
  }

  set<T>(key: string, data: T, options: CacheOptions = {}): void {
    const ttl = options.ttl || this.defaultTtl;
    const now = Date.now();

    // Clean up expired items before adding new ones
    this.cleanup();

    // If cache is full, remove least recently used item
    if (this.cache.size >= this.maxSize) {
      this.evictLRU();
    }

    this.cache.set(key, {
      data: options.serialize ? JSON.parse(JSON.stringify(data)) : data,
      timestamp: now,
      ttl,
      accessCount: 0,
      lastAccess: now
    });
  }

  get<T>(key: string): T | null {
    const item = this.cache.get(key);
    
    if (!item) return null;

    const now = Date.now();
    
    // Check if item has expired
    if (now - item.timestamp > item.ttl) {
      this.cache.delete(key);
      return null;
    }

    // Update access statistics
    item.accessCount++;
    item.lastAccess = now;

    return item.data;
  }

  has(key: string): boolean {
    const item = this.cache.get(key);
    if (!item) return false;

    const now = Date.now();
    if (now - item.timestamp > item.ttl) {
      this.cache.delete(key);
      return false;
    }

    return true;
  }

  delete(key: string): boolean {
    return this.cache.delete(key);
  }

  clear(): void {
    this.cache.clear();
  }

  private cleanup(): void {
    const now = Date.now();
    for (const [key, item] of this.cache.entries()) {
      if (now - item.timestamp > item.ttl) {
        this.cache.delete(key);
      }
    }
  }

  private evictLRU(): void {
    let oldestKey = '';
    let oldestAccess = Date.now();

    for (const [key, item] of this.cache.entries()) {
      if (item.lastAccess < oldestAccess) {
        oldestAccess = item.lastAccess;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }

  getStats() {
    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      keys: Array.from(this.cache.keys()),
      totalAccesses: Array.from(this.cache.values()).reduce((sum, item) => sum + item.accessCount, 0)
    };
  }
}

// Global cache instance
const globalCache = new AdvancedCache();

export function useAdvancedCaching() {
  const queryClient = useQueryClient();
  
  const [cacheStats, setCacheStats] = useState(globalCache.getStats());

  const updateStats = useCallback(() => {
    setCacheStats(globalCache.getStats());
  }, []);

  useEffect(() => {
    // Update stats periodically
    const interval = setInterval(updateStats, 10000);
    return () => clearInterval(interval);
  }, [updateStats]);

  const setCache = useCallback(<T>(key: string, data: T, options?: CacheOptions) => {
    globalCache.set(key, data, options);
    updateStats();
  }, [updateStats]);

  const getCache = useCallback(<T>(key: string): T | null => {
    const result = globalCache.get<T>(key);
    updateStats();
    return result;
  }, [updateStats]);

  const hasCache = useCallback((key: string): boolean => {
    return globalCache.has(key);
  }, []);

  const deleteCache = useCallback((key: string): boolean => {
    const result = globalCache.delete(key);
    updateStats();
    return result;
  }, [updateStats]);

  const clearCache = useCallback(() => {
    globalCache.clear();
    queryClient.clear(); // Also clear React Query cache
    updateStats();
  }, [queryClient, updateStats]);

  const invalidatePattern = useCallback((pattern: string) => {
    const regex = new RegExp(pattern);
    const keys = Array.from(globalCache.getStats().keys);
    
    keys.forEach(key => {
      if (regex.test(key)) {
        globalCache.delete(key);
      }
    });
    
    // Also invalidate matching React Query keys
    queryClient.invalidateQueries({
      predicate: (query) => regex.test(query.queryKey.join('-'))
    });
    
    updateStats();
  }, [queryClient, updateStats]);

  return {
    setCache,
    getCache,
    hasCache,
    deleteCache,
    clearCache,
    invalidatePattern,
    cacheStats
  };
}

import { useState } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { useToast } from "@/hooks/use-toast";
import { APIErrorHandler, withRetry } from "@/utils/apiErrorHandler";
import { apoRateLimiter, checkRateLimit } from "@/utils/rateLimiting";

export interface APOAnalysis {
  occupation_code: string;
  occupation_title: string;
  overall_score: number;
  confidence_level: number;
  automation_timeline: string;
  risk_level: 'Low' | 'Medium' | 'Med-High' | 'High';
  category_breakdown: {
    tasks: { score: number; details: any[] };
    knowledge: { score: number; details: any[] };
    skills: { score: number; details: any[] };
    abilities: { score: number; details: any[] };
    technology: { score: number; details: any[] };
  };
  insights: {
    opportunities: string[];
    challenges: string[];
    recommendations: string[];
  };
  job_market: {
    current_demand: string;
    salary_range: string;
    growth_outlook: string;
    locations: string[];
  };
}

export function useAPOCalculation() {
  const [isCalculating, setIsCalculating] = useState(false);
  const queryClient = useQueryClient();
  const { toast } = useToast();

  // Health check mutation
  const healthCheckMutation = useMutation({
    mutationFn: async () => {
      const { data, error } = await supabase.rpc('health_check');
      if (error) throw error;
      return data;
    }
  });

  const calculateAPO = async (occupationCode: string, occupationTitle: string): Promise<APOAnalysis> => {
    setIsCalculating(true);
    
    try {
      // Get current user
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        throw new Error('Authentication required');
      }

      // Check rate limiting
      const rateCheck = checkRateLimit(apoRateLimiter, user.id);
      if (!rateCheck.allowed) {
        const resetTime = new Date(rateCheck.resetTime);
        throw new Error(`Rate limit exceeded. Try again at ${resetTime.toLocaleTimeString()}`);
      }

      // Check and deduct API credits before processing
      const { data: creditsDeducted, error: creditsError } = await supabase.rpc('deduct_api_credits', {
        p_user_id: user.id,
        p_credits_to_deduct: 1.0
      });

      if (creditsError) {
        console.error('Credits deduction error:', creditsError);
        throw new Error('Failed to process credits');
      }

      if (!creditsDeducted) {
        // Send notification about insufficient credits
        await supabase.rpc('create_notification', {
          p_user_id: user.id,
          p_title: 'Insufficient Credits',
          p_message: 'You don\'t have enough API credits to perform this analysis. Please upgrade your plan.',
          p_type: 'warning'
        });
        
        throw new Error('Insufficient API credits. Please upgrade your plan.');
      }

      // Check cache first
      const { data: cached } = await supabase
        .from('apo_analysis_cache')
        .select('*')
        .eq('occupation_code', occupationCode)
        .single();

      if (cached && cached.analysis_data) {
        console.log('Using cached APO analysis');
        setIsCalculating(false);
        
        // Send success notification
        await supabase.rpc('create_notification', {
          p_user_id: user.id,
          p_title: 'Analysis Complete',
          p_message: `APO analysis completed for ${occupationTitle}`,
          p_type: 'success'
        });

        return cached.analysis_data as unknown as APOAnalysis;
      }

      // Calculate new APO analysis with retry logic
      const analysis = await withRetry(async () => {
        const { data, error } = await supabase.functions.invoke('calculate-apo', {
          body: { 
            occupation_code: occupationCode, 
            occupation_title: occupationTitle 
          }
        });

        if (error) throw error;
        return data.analysis;
      }, 'APO calculation');

      // Cache the result
      await supabase
        .from('apo_analysis_cache')
        .upsert({
          occupation_code: occupationCode,
          occupation_title: occupationTitle,
          analysis_data: analysis
        });

      // Send success notification
      await supabase.rpc('create_notification', {
        p_user_id: user.id,
        p_title: 'Analysis Complete',
        p_message: `APO analysis completed for ${occupationTitle}`,
        p_type: 'success'
      });

      // Invalidate user profile to update credits display
      queryClient.invalidateQueries({ queryKey: ['user_profile'] });

      setIsCalculating(false);
      return analysis;

    } catch (error) {
      setIsCalculating(false);
      const apiError = APIErrorHandler.handle(error);
      APIErrorHandler.logError(apiError, 'APO Calculation');
      
      console.error('APO Calculation Error:', error);
      
      toast({
        variant: 'destructive',
        title: 'Analysis Failed',
        description: apiError.message,
      });
      
      throw error;
    }
  };

  const getJobMarketData = async (occupationTitle: string) => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return null;

      const data = await withRetry(async () => {
        const { data, error } = await supabase.functions.invoke('serpapi-jobs', {
          body: { occupation_title: occupationTitle }
        });
        
        if (error) throw error;
        return data;
      }, 'Job market data fetch');

      return data;
    } catch (error) {
      const apiError = APIErrorHandler.handle(error);
      APIErrorHandler.logError(apiError, 'Job Market Data');
      console.error('Job Market Data Error:', error);
      return null;
    }
  };

  return {
    calculateAPO,
    getJobMarketData,
    isCalculating,
    healthCheck: () => healthCheckMutation.mutate()
  };
}
import { useState, useEffect } from "react";

export interface SavedAnalysis {
  id: string;
  occupation_code: string;
  occupation_title: string;
  analysis_data: any;
  tags: string[];
  notes?: string;
  created_at: string;
  updated_at: string;
}

const STORAGE_KEY = "savedAnalyses";

function loadAnalyses(): SavedAnalysis[] {
  try {
    const data = localStorage.getItem(STORAGE_KEY);
    return data ? JSON.parse(data) : [];
  } catch {
    return [];
  }
}

function saveAnalyses(analyses: SavedAnalysis[]) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(analyses));
}

export function useSavedAnalysesLocal() {
  const [savedAnalyses, setSavedAnalyses] = useState<SavedAnalysis[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    setSavedAnalyses(loadAnalyses());
    setIsLoading(false);
  }, []);

  const saveAnalysis = (analysis: Omit<SavedAnalysis, "id" | "created_at" | "updated_at"> & { id?: string }) => {
    setSavedAnalyses(prev => {
      const now = new Date().toISOString();
      let updated: SavedAnalysis[];
      if (analysis.id) {
        updated = prev.map(a =>
          a.id === analysis.id ? { ...a, ...analysis, updated_at: now } : a
        );
      } else {
        const newAnalysis: SavedAnalysis = {
          ...analysis,
          id: `analysis_${Date.now()}`,
          created_at: now,
          updated_at: now,
        };
        updated = [newAnalysis, ...prev];
      }
      saveAnalyses(updated);
      return updated;
    });
  };

  const updateAnalysis = (id: string, updates: Partial<SavedAnalysis>) => {
    setSavedAnalyses(prev => {
      const now = new Date().toISOString();
      const updated = prev.map(a =>
        a.id === id ? { ...a, ...updates, updated_at: now } : a
      );
      saveAnalyses(updated);
      return updated;
    });
  };

  const deleteAnalysis = (id: string) => {
    setSavedAnalyses(prev => {
      const updated = prev.filter(a => a.id !== id);
      saveAnalyses(updated);
      return updated;
    });
  };

  return {
    savedAnalyses,
    isLoading,
    saveAnalysis,
    updateAnalysis,
    deleteAnalysis,
  };
}

import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { User } from "@supabase/supabase-js";

export interface SearchHistoryItem {
  id: string;
  search_term: string;
  results_count: number;
  searched_at: string;
}

export function useSearchHistory() {
  const [user, setUser] = useState<User | null>(null);
  const queryClient = useQueryClient();

  useEffect(() => {
    const checkUserSession = async () => {
      const { data: { session } } = await supabase.auth.getSession();
      setUser(session?.user ?? null);
    };
    checkUserSession();

    const { data: authListener } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
      queryClient.invalidateQueries({ queryKey: ['search_history'] });
    });

    return () => {
      authListener.subscription.unsubscribe();
    };
  }, [queryClient]);

  const queryKey = ['search_history', user?.id];

  const { data: searchHistory = [], isLoading } = useQuery<SearchHistoryItem[]>({
    queryKey,
    queryFn: async () => {
      if (!user) return [];

      const { data, error } = await supabase
        .from('search_history')
        .select('*')
        .eq('user_id', user.id)
        .order('searched_at', { ascending: false })
        .limit(50);

      if (error) {
        console.error('Error fetching search history:', error);
        throw error;
      }
      
      return data || [];
    },
    enabled: !!user,
  });

  const addSearchMutation = useMutation({
    mutationFn: async ({ 
      search_term, 
      results_count 
    }: {
      search_term: string;
      results_count: number;
    }) => {
      if (!user) return;

      const { error } = await supabase
        .from('search_history')
        .insert({
          user_id: user.id,
          search_term,
          results_count
        });
      
      if (error) {
        console.error('Error saving search history:', error);
        throw error;
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
    },
  });

  const clearHistoryMutation = useMutation({
    mutationFn: async () => {
      if (!user) throw new Error('User not authenticated');

      const { error } = await supabase
        .from('search_history')
        .delete()
        .eq('user_id', user.id);

      if (error) {
        console.error('Error clearing search history:', error);
        throw error;
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
    }
  });

  return {
    searchHistory,
    isLoading,
    addSearch: (data: any) => addSearchMutation.mutate(data),
    clearHistory: () => clearHistoryMutation.mutate(),
    isClearing: clearHistoryMutation.isPending,
  };
}

import { useState } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { toast } from "sonner";

export interface ShareAnalysisData {
  analysis_id: string;
  share_type: 'link' | 'email' | 'token';
  shared_with_email?: string;
  expires_at?: string;
  max_views?: number;
}

export interface SharedAnalysis {
  id: string;
  share_token: string;
  share_type: string;
  shared_with_email?: string;
  expires_at?: string;
  view_count: number;
  max_views?: number;
  is_active: boolean;
  created_at: string;
  analysis_id: string;
}

interface ShareViewResponse {
  success?: boolean;
  analysis?: any;
  shared_by?: string;
  view_count?: number;
  error?: string;
}

export function useShareAnalysis() {
  const [isSharing, setIsSharing] = useState(false);
  const queryClient = useQueryClient();

  const shareAnalysisMutation = useMutation({
    mutationFn: async (shareData: ShareAnalysisData) => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('User not authenticated');

      const { data, error } = await supabase
        .from('shared_analyses')
        .insert({
          user_id: user.id,
          analysis_id: shareData.analysis_id,
          share_type: shareData.share_type,
          shared_with_email: shareData.shared_with_email,
          expires_at: shareData.expires_at,
          max_views: shareData.max_views
        })
        .select()
        .single();

      if (error) throw error;

      // If sharing via email, send the email
      if (shareData.share_type === 'email' && shareData.shared_with_email) {
        const emailResult = await supabase.functions.invoke('send-shared-analysis', {
          body: {
            share_token: data.share_token,
            recipient_email: shareData.shared_with_email,
            analysis_id: shareData.analysis_id
          }
        });

        if (emailResult.error) {
          console.warn('Email sending failed:', emailResult.error);
          toast.warning('Analysis shared but email delivery failed');
        }
      }

      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['shared_analyses'] });
      toast.success('Analysis shared successfully!');
    },
    onError: (error) => {
      console.error('Error sharing analysis:', error);
      toast.error('Failed to share analysis');
    }
  });

  const getSharedAnalysis = async (shareToken: string): Promise<ShareViewResponse> => {
    try {
      setIsSharing(true);
      const { data, error } = await supabase.rpc('increment_share_view', {
        share_token_param: shareToken
      });

      if (error) throw error;
      
      // Type cast the Json response to our expected interface
      const response = data as ShareViewResponse;
      
      if (response?.error) {
        throw new Error(response.error);
      }

      return response;
    } catch (error) {
      console.error('Error getting shared analysis:', error);
      throw error;
    } finally {
      setIsSharing(false);
    }
  };

  const revokeShare = async (shareId: string) => {
    const { error } = await supabase
      .from('shared_analyses')
      .update({ is_active: false })
      .eq('id', shareId);

    if (error) throw error;
    
    queryClient.invalidateQueries({ queryKey: ['shared_analyses'] });
    toast.success('Share access revoked');
  };

  return {
    shareAnalysis: shareAnalysisMutation.mutate,
    getSharedAnalysis,
    revokeShare,
    isSharing: isSharing || shareAnalysisMutation.isPending
  };
}
import { useQuery } from "@tanstack/react-query";

export type CrosswalkFrom = "MOC" | "CIP" | "RAPIDS" | "ESCO" | "DOT" | "SOC";
export type CrosswalkTo = "MOC" | "CIP" | "RAPIDS" | "ESCO" | "DOT" | "SOC";

export interface CrosswalkParams {
  from: CrosswalkFrom;
  code: string;
  to?: CrosswalkTo;
  enabled?: boolean;
}

export function useCrosswalk<T = unknown>({ from, code, to, enabled = true }: CrosswalkParams) {
  const key = ["crosswalk", from, code, to ?? "ALL"] as const;

  const fetcher = async (): Promise<T> => {
    if (!code) throw new Error("Crosswalk requires a code");
    const qs = new URLSearchParams({ from, code });
    if (to) qs.set("to", to);
    const url = `/functions/v1/crosswalk?${qs.toString()}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error(`Crosswalk request failed (${res.status})`);
    const ct = res.headers.get("Content-Type") || "";
    if (ct.includes("json")) return (await res.json()) as T;
    return (await res.text()) as unknown as T;
  };

  return useQuery<T>({
    queryKey: key,
    queryFn: fetcher,
    enabled: !!code && enabled,
    staleTime: 1000 * 60 * 5,
    retry: 2,
  });
}

import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { User } from "@supabase/supabase-js";

export interface SavedAnalysis {
  id: string;
  occupation_code: string;
  occupation_title: string;
  analysis_data: any;
  tags: string[];
  notes?: string;
  created_at: string;
  updated_at: string;
}

export function useSavedAnalyses() {
  const [user, setUser] = useState<User | null>(null);
  const queryClient = useQueryClient();

  useEffect(() => {
    const checkUserSession = async () => {
      const { data: { session } } = await supabase.auth.getSession();
      setUser(session?.user ?? null);
    };
    checkUserSession();

    const { data: authListener } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
      queryClient.invalidateQueries({ queryKey: ['saved_analyses'] });
    });

    return () => {
      authListener.subscription.unsubscribe();
    };
  }, [queryClient]);

  const queryKey = ['saved_analyses', user?.id];

  const { data: savedAnalyses = [], isLoading } = useQuery<SavedAnalysis[]>({
    queryKey,
    queryFn: async () => {
      if (!user) return [];

      const { data, error } = await supabase
        .from('saved_analyses')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching saved analyses:', error);
        throw error;
      }
      
      return data || [];
    },
    enabled: !!user,
  });

  const saveAnalysisMutation = useMutation({
    mutationFn: async ({ 
      occupation_code, 
      occupation_title, 
      analysis_data, 
      tags = [], 
      notes 
    }: {
      occupation_code: string;
      occupation_title: string;
      analysis_data: any;
      tags?: string[];
      notes?: string;
    }) => {
      if (!user) throw new Error('User not authenticated');

      const { data, error } = await supabase
        .from('saved_analyses')
        .insert({
          user_id: user.id,
          occupation_code,
          occupation_title,
          analysis_data,
          tags,
          notes
        })
        .select()
        .single();
      
      if (error) {
        console.error('Error saving analysis:', error);
        throw error;
      }
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
    },
  });

  const updateAnalysisMutation = useMutation({
    mutationFn: async ({ 
      id, 
      tags, 
      notes 
    }: {
      id: string;
      tags?: string[];
      notes?: string;
    }) => {
      if (!user) throw new Error('User not authenticated');

      const { data, error } = await supabase
        .from('saved_analyses')
        .update({ tags, notes })
        .eq('id', id)
        .eq('user_id', user.id)
        .select()
        .single();

      if (error) {
        console.error('Error updating analysis:', error);
        throw error;
      }
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
    }
  });

  const deleteAnalysisMutation = useMutation({
    mutationFn: async (id: string) => {
      if (!user) throw new Error('User not authenticated');

      const { error } = await supabase
        .from('saved_analyses')
        .delete()
        .eq('id', id)
        .eq('user_id', user.id);

      if (error) {
        console.error('Error deleting analysis:', error);
        throw error;
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
    }
  });

  return {
    savedAnalyses,
    isLoading,
    saveAnalysis: (data: any) => saveAnalysisMutation.mutate(data),
    updateAnalysis: (data: any) => updateAnalysisMutation.mutate(data),
    deleteAnalysis: (id: string) => deleteAnalysisMutation.mutate(id),
    isSaving: saveAnalysisMutation.isPending,
    isUpdating: updateAnalysisMutation.isPending,
    isDeleting: deleteAnalysisMutation.isPending,
  };
}
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
// GeminiService: Direct browser API client for Gemini 2.5 Flash
// Usage: GeminiService.generate(prompt, config?)

export interface GeminiResponse {
  text: string;
  usageMetadata?: Record<string, any>;
  latency_ms?: number;
}

export class GeminiService {
  /**
   * Generate LLM output using Gemini 2.5 Flash directly from browser.
   * @param prompt User/system prompt
   * @param generationConfig Gemini API generationConfig (optional)
   * @param model Model name (optional, defaults to gemini-2.5-flash)
   */
  static async generate(
    prompt: string,
    generationConfig?: object,
    model: string = 'gemini-2.5-flash'
  ): Promise<GeminiResponse> {
    const apiKey = import.meta.env.VITE_GEMINI_API_KEY;
    if (!apiKey) throw new Error('VITE_GEMINI_API_KEY not set');
    const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
    const started = Date.now();
    const body = {
      contents: [{ parts: [{ text: prompt }] }],
      generationConfig: generationConfig ?? {
        temperature: 0.2,
        topK: 1,
        topP: 0.8,
        maxOutputTokens: 4096,
      }
    };
    const res = await fetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    const latency = Date.now() - started;
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`Gemini API error: ${res.status} ${res.statusText} ${errorText}`);
    }
    const { candidates, usageMetadata } = await res.json();
    if (!candidates?.length) throw new Error('No candidates in Gemini response');
    const text = candidates[0]?.content?.parts?.[0]?.text ?? '';
    return { text, usageMetadata, latency_ms: latency };
  }
}
