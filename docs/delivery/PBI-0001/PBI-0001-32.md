# PBI-0001-32: Durable Rate Limiting Design

Type: doc
Status: InProgress

## Goal
Design a durable, centralized rate-limiting solution to replace in-memory per-instance buckets used in Edge Functions. Ensure consistent quotas across instances and deploys.

## Requirements
- Per-identity keys: IP, userId, or deviceId (guest) depending on endpoint.
- Sliding window / token bucket semantics (configurable window, burst, refill).
- Low-latency store (Redis or managed KV) with TTL and atomic increments.
- Observability (metrics for hit/miss/exceeded) and simple admin overrides.

## Candidate Backends
- Redis (Upstash, Fly, or any managed Redis)
  - Pros: Mature, atomic ops, expirations, easy counters.
  - Cons: Extra infra/service.
- Deno KV / Supabase KV (when GA/stable for functions)
  - Pros: Built-in, simple.
  - Cons: Availability/SLA and operations maturity vary; evaluate quotas.

## Data Model (Redis)
- Key format: `rl:{route}:{identity}` (e.g., `rl:calculate-apo:user-<uuid>`)
- Value: JSON `{ count: number, reset: epoch_ms }` or use multiple keys (counter + reset)
- TTL: windowMs
- Algorithm: On request: `INCRBY counter`; if `> max`, reject; else allow. If first increment, set TTL and compute reset.

## API Shape (Library)
```
interface RLOpts { max: number; windowMs: number; now?: number }
interface RLResult { allowed: boolean; remaining: number; resetMs: number }
async function durableRateLimit(key: string, opts: RLOpts): Promise<RLResult>
```

## Integration Points
- `supabase/functions/calculate-apo/index.ts` — replace in-memory limiter.
- `supabase/functions/*` where external calls are expensive (Gemini/SerpAPI/O*NET) or subject to abuse.

## Phased Rollout
1) Library + Redis adapter + environment config (URLs, auth).
2) Shadow mode: Log decisions alongside current in-memory limiter; compare.
3) Cutover: Enable durable limiter; keep in-memory as fallback.
4) Observability: counters in `analytics_events` and dashboards.

## Risks & Mitigations
- Redis connectivity issues → fallback to in-memory conservative deny after N errors.
- Key cardinality explosion → enforce normalized identity (hash IP / clamp deviceId lifetimes).
- Cost → tune windows, apply only to high-cost endpoints.

## Next
- Prototype `lib/DurableRateLimiter.ts` and wire to `calculate-apo` behind env flag `APO_DURABLE_RL=true`.
